
<!DOCTYPE html>

<html lang="pt_BR">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17: http://docutils.sourceforge.net/" />

    <title>Protocolo de Buffer &#8212; documentação Python 3.10.4</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pydoctheme.css?2022.1" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Pesquisar dentro de documentação Python 3.10.4"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="Sobre esses documentos" href="../about.html" />
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Buscar" href="../search.html" />
    <link rel="copyright" title="Direitos autorais" href="../copyright.html" />
    <link rel="next" title="Protocolo de Buffer Antigo" href="objbuffer.html" />
    <link rel="prev" title="Protocolo Iterador" href="iter.html" />
    <link rel="canonical" href="https://docs.python.org/3/c-api/buffer.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <label for="menuToggler" class="toggler__label">
        <span></span>
    </label>
    <nav class="nav-content" role="navigation">
         <a href="https://www.python.org/" class="nav-logo">
             <img src="../_static/py.svg" alt="Logo"/>
         </a>
        <div class="version_switcher_placeholder"></div>
        <form role="search" class="search" action="../search.html" method="get">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                <path fill-rule="nonzero"
                        d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="#444"></path>
            </svg>
            <input type="text" name="q" aria-label="Busca rápida"/>
            <input type="submit" value="Ir"/>
        </form>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
  <h3><a href="../contents.html">Tabela de Conteúdo</a></h3>
  <ul>
<li><a class="reference internal" href="#">Protocolo de Buffer</a><ul>
<li><a class="reference internal" href="#buffer-structure">Estrutura de Buffer</a></li>
<li><a class="reference internal" href="#buffer-request-types">Tipos de solicitação do buffer</a><ul>
<li><a class="reference internal" href="#request-independent-fields">campos independentes do pedido</a></li>
<li><a class="reference internal" href="#readonly-format">apenas em formato</a></li>
<li><a class="reference internal" href="#shape-strides-suboffsets">forma, avanços, suboffsets</a></li>
<li><a class="reference internal" href="#contiguity-requests">requisições contíguas</a></li>
<li><a class="reference internal" href="#compound-requests">requisições compostas</a></li>
</ul>
</li>
<li><a class="reference internal" href="#complex-arrays">Vetores Complexos</a><ul>
<li><a class="reference internal" href="#numpy-style-shape-and-strides">Estilo NumPy: forma e avanços</a></li>
<li><a class="reference internal" href="#pil-style-shape-strides-and-suboffsets">Estilo-PIL: forma, avanços e suboffsets</a></li>
</ul>
</li>
<li><a class="reference internal" href="#buffer-related-functions">Buffer-related functions</a></li>
</ul>
</li>
</ul>

  <h4>Tópico anterior</h4>
  <p class="topless"><a href="iter.html"
                        title="capítulo anterior">Protocolo Iterador</a></p>
  <h4>Próximo tópico</h4>
  <p class="topless"><a href="objbuffer.html"
                        title="próximo capítulo">Protocolo de Buffer Antigo</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Relatar um erro</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.10/Doc/c-api/buffer.rst"
            rel="nofollow">Exibir código-fonte
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegação</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice geral"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="objbuffer.html" title="Protocolo de Buffer Antigo"
             accesskey="N">próximo</a> |</li>
        <li class="right" >
          <a href="iter.html" title="Protocolo Iterador"
             accesskey="P">anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.10.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Manual de referência da API Python/C</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="abstract.html" accesskey="U">Camada de Objetos Abstratos</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Protocolo de Buffer</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Busca rápida" aria-label="Busca rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="buffer-protocol">
<span id="bufferobjects"></span><span id="index-0"></span><h1>Protocolo de Buffer<a class="headerlink" href="#buffer-protocol" title="Link permanente para este título">¶</a></h1>
<p>Certos objetos disponíveis em Python envolvem o acesso a um vetor ou <em>buffer</em> de memória subjacente. Esses objetos incluem as <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> e <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> embutidas, e alguns tipos de extensão como <a class="reference internal" href="../library/array.html#array.array" title="array.array"><code class="xref py py-class docutils literal notranslate"><span class="pre">array.array</span></code></a>. As bibliotecas de terceiros podem definir seus próprios tipos para fins especiais, como processamento de imagem ou análise numérica.</p>
<p>Embora cada um desses tipos tenha sua própria semântica, eles compartilham a característica comum de serem suportados por um buffer de memória possivelmente grande. É desejável, em algumas situações, acessar esse buffer diretamente e sem cópia intermediária.</p>
<p>Python fornece essa facilidade no nível C sob a forma de <a class="reference internal" href="#bufferobjects"><span class="std std-ref">protocolo de buffer</span></a>. Este protocolo tem dois lados:</p>
<ul class="simple" id="index-1">
<li><p>do lado do produtor, um tipo pode exportar uma “interface de buffer” que permite que objetos desse tipo exponham informações sobre o buffer subjacente. Esta interface é descrita na seção <a class="reference internal" href="typeobj.html#buffer-structs"><span class="std std-ref">Buffer Object Structures</span></a>;</p></li>
<li><p>do lado do consumidor, vários meios estão disponíveis para obter o ponteiro para os dados subjacentes de um objeto (por exemplo, um parâmetro de método).</p></li>
</ul>
<p>Objetos simples como <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> e <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> expõem seu buffer subjacente em uma forma orientada a byte. Outras formas são possíveis; por exemplo, os elementos expostos por uma <a class="reference internal" href="../library/array.html#array.array" title="array.array"><code class="xref py py-class docutils literal notranslate"><span class="pre">array.array</span></code></a> podem ser valores de vários bytes.</p>
<p>Um exemplo de consumidor da interface de buffer é o método <a class="reference internal" href="../library/io.html#io.BufferedIOBase.write" title="io.BufferedIOBase.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code></a> de objetos arquivo: qualquer objeto que pode exportar uma série de bytes através da interface de buffer pode ser gravado em um arquivo. Enquanto <code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code> só precisa de acesso somente leitura aos conteúdos internos do objeto passado, outros métodos, tais como <a class="reference internal" href="../library/io.html#io.BufferedIOBase.readinto" title="io.BufferedIOBase.readinto"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readinto()</span></code></a> precisam de acesso de gravação ao conteúdo de seu argumento. A interface de buffer permite aos objetos permitir ou rejeitar seletivamente a exportação de buffers de leitura e escrita e de somente leitura.</p>
<p>Existem duas maneiras para um usuário da interface de buffer adquirir um buffer em um objeto alvo:</p>
<ul class="simple">
<li><p>chamada <a class="reference internal" href="#c.PyObject_GetBuffer" title="PyObject_GetBuffer"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GetBuffer()</span></code></a> com os parâmetros certos;</p></li>
<li><p>chamada <a class="reference internal" href="arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a> (ou um dos seus irmãos) com um dos <code class="docutils literal notranslate"><span class="pre">y*</span></code>, <code class="docutils literal notranslate"><span class="pre">w*</span></code> ou <code class="docutils literal notranslate"><span class="pre">s*</span></code> <a class="reference internal" href="arg.html#arg-parsing"><span class="std std-ref">format codes</span></a>.</p></li>
</ul>
<p>Em ambos os casos, <a class="reference internal" href="#c.PyBuffer_Release" title="PyBuffer_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyBuffer_Release()</span></code></a> deve ser chamado quando o buffer não é mais necessário. A falta de tal pode levar a várias questões, tais como vazamentos de recursos.</p>
<section id="buffer-structure">
<span id="id1"></span><h2>Estrutura de Buffer<a class="headerlink" href="#buffer-structure" title="Link permanente para este título">¶</a></h2>
<p>As estruturas de buffer (ou simplesmente “buffers”) são úteis como uma maneira de expor os dados binários de outro objeto para o programador Python. Eles também podem ser usados como um mecanismo de cópia silenciosa. Usando sua capacidade de fazer referência a um bloco de memória, é possível expor facilmente qualquer dado ao programador Python. A memória pode ser uma matriz grande e constante em uma extensão C, pode ser um bloco bruto de memória para manipulação antes de passar para uma biblioteca do sistema operacional, ou pode ser usado para transmitir dados estruturados no formato nativo e formato de memória .</p>
<p>Ao contrário da maioria dos tipos de dados expostos pelo interpretador Python, os buffers não são ponteiros <a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> mas sim estruturas C simples. Isso permite que eles sejam criados e copiados de forma muito simples. Quando um invólucro genérico em torno de um buffer é necessário, um objeto <a class="reference internal" href="memoryview.html#memoryview-objects"><span class="std std-ref">memoryview</span></a> pode ser criado.</p>
<p>Para obter instruções curtas sobre como escrever um objeto exportador, consulte <a class="reference internal" href="typeobj.html#buffer-structs"><span class="std std-ref">Buffer Object Structures</span></a>. Para obter um buffer, veja <a class="reference internal" href="#c.PyObject_GetBuffer" title="PyObject_GetBuffer"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GetBuffer()</span></code></a>.</p>
<dl class="c type">
<dt id="c.Py_buffer">
<em class="property">type </em><code class="sig-name descname">Py_buffer</code><a class="headerlink" href="#c.Py_buffer" title="Link permanente para esta definição">¶</a><br /></dt>
<dd><dl class="c member">
<dt id="c.Py_buffer.buf">
void *<code class="sig-name descname">buf</code><a class="headerlink" href="#c.Py_buffer.buf" title="Link permanente para esta definição">¶</a><br /></dt>
<dd><p>Um ponteiro para o início da estrutura lógica descrita pelos campos do buffer. Este pode ser qualquer local dentro do bloco de memória física subjacente do exportador. Por exemplo, com negativo <a class="reference internal" href="#c.Py_buffer.strides" title="Py_buffer.strides"><code class="xref c c-member docutils literal notranslate"><span class="pre">strides</span></code></a> o valor pode apontar para o final do bloco de memória.</p>
<p>Para vetores <a class="reference internal" href="../glossary.html#term-contiguous"><span class="xref std std-term">contíguos</span></a>, o valor aponta para o início do bloco de memória.</p>
</dd></dl>

<dl class="c member">
<dt id="c.Py_buffer.obj">
void *<code class="sig-name descname">obj</code><a class="headerlink" href="#c.Py_buffer.obj" title="Link permanente para esta definição">¶</a><br /></dt>
<dd><p>Uma nova referência ao objeto exportador. A referência é possuída pelo consumidor e automaticamente decrementada e definida para <code class="docutils literal notranslate"><span class="pre">NULL</span></code> por <a class="reference internal" href="#c.PyBuffer_Release" title="PyBuffer_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyBuffer_Release()</span></code></a>. O campo é o equivalente ao valor de retorno de qualquer função padrão C-API.</p>
<p>Como um caso especial, para buffers <em>temporários</em> que são encapsulados por <a class="reference internal" href="memoryview.html#c.PyMemoryView_FromBuffer" title="PyMemoryView_FromBuffer"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMemoryView_FromBuffer()</span></code></a> ou <a class="reference internal" href="#c.PyBuffer_FillInfo" title="PyBuffer_FillInfo"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyBuffer_FillInfo()</span></code></a> esse campo é <code class="docutils literal notranslate"><span class="pre">NULL</span></code>. Em geral, objetos exportadores NÃO DEVEM usar esse esquema.</p>
</dd></dl>

<dl class="c member">
<dt id="c.Py_buffer.len">
<a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t">Py_ssize_t</a> <code class="sig-name descname">len</code><a class="headerlink" href="#c.Py_buffer.len" title="Link permanente para esta definição">¶</a><br /></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">product(shape)</span> <span class="pre">*</span> <span class="pre">itemsize</span></code>. Para matrizes contíguas, este é o comprimento do bloco de memória subjacente. Para matrizes não contíguas, é o comprimento que a estrutura lógica teria se fosse copiado para uma representação contígua.</p>
<p>Acessando <code class="docutils literal notranslate"><span class="pre">((char</span> <span class="pre">*)buf)[0]</span> <span class="pre">up</span> <span class="pre">to</span> <span class="pre">((char</span> <span class="pre">*)buf)[len-1]</span></code> só é válido se o buffer tiver sido obtido por uma solicitação que garanta a contiguidade. Na maioria dos casos, esse pedido será <a class="reference internal" href="#c.PyBUF_SIMPLE" title="PyBUF_SIMPLE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyBUF_SIMPLE</span></code></a> ou <a class="reference internal" href="#c.PyBUF_WRITABLE" title="PyBUF_WRITABLE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyBUF_WRITABLE</span></code></a>.</p>
</dd></dl>

<dl class="c member">
<dt id="c.Py_buffer.readonly">
int <code class="sig-name descname">readonly</code><a class="headerlink" href="#c.Py_buffer.readonly" title="Link permanente para esta definição">¶</a><br /></dt>
<dd><p>Um indicador de se o buffer é somente leitura. Este campo é controlado pelo sinalizador <a class="reference internal" href="#c.PyBUF_WRITABLE" title="PyBUF_WRITABLE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyBUF_WRITABLE</span></code></a>.</p>
</dd></dl>

<dl class="c member">
<dt id="c.Py_buffer.itemsize">
<a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t">Py_ssize_t</a> <code class="sig-name descname">itemsize</code><a class="headerlink" href="#c.Py_buffer.itemsize" title="Link permanente para esta definição">¶</a><br /></dt>
<dd><p>O tamanho do item em bytes de um único elemento. O mesmo que o valor de <a class="reference internal" href="../library/struct.html#struct.calcsize" title="struct.calcsize"><code class="xref py py-func docutils literal notranslate"><span class="pre">struct.calcsize()</span></code></a> chamado em valores não <code class="docutils literal notranslate"><span class="pre">NULL</span></code> de <a class="reference internal" href="#c.Py_buffer.format" title="Py_buffer.format"><code class="xref c c-member docutils literal notranslate"><span class="pre">format</span></code></a>.</p>
<p>Exceção importante: Se um consumidor requisita um buffer sem sinalizador <a class="reference internal" href="#c.PyBUF_FORMAT" title="PyBUF_FORMAT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyBUF_FORMAT</span></code></a>, <a class="reference internal" href="#c.Py_buffer.format" title="Py_buffer.format"><code class="xref c c-member docutils literal notranslate"><span class="pre">format</span></code></a> será definido como <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, mas <a class="reference internal" href="#c.Py_buffer.itemsize" title="Py_buffer.itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">itemsize</span></code></a> ainda terá seu valor para o formato original.</p>
<p>Se <a class="reference internal" href="#c.Py_buffer.shape" title="Py_buffer.shape"><code class="xref c c-member docutils literal notranslate"><span class="pre">shape</span></code></a> está presente, a igualdade <code class="docutils literal notranslate"><span class="pre">product(shape)</span> <span class="pre">*</span> <span class="pre">itemsize</span> <span class="pre">==</span> <span class="pre">len</span></code> ainda é válida e o usuário pode usar <a class="reference internal" href="#c.Py_buffer.itemsize" title="Py_buffer.itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">itemsize</span></code></a> para navegar o buffer.</p>
<p>Se <a class="reference internal" href="#c.Py_buffer.shape" title="Py_buffer.shape"><code class="xref c c-member docutils literal notranslate"><span class="pre">shape</span></code></a> é <code class="docutils literal notranslate"><span class="pre">NULL</span></code> como resultado de uma <a class="reference internal" href="#c.PyBUF_SIMPLE" title="PyBUF_SIMPLE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyBUF_SIMPLE</span></code></a> ou uma requisição <a class="reference internal" href="#c.PyBUF_WRITABLE" title="PyBUF_WRITABLE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyBUF_WRITABLE</span></code></a>, o consumidor deve ignorar <a class="reference internal" href="#c.Py_buffer.itemsize" title="Py_buffer.itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">itemsize</span></code></a> e assumir <code class="docutils literal notranslate"><span class="pre">itemsize</span> <span class="pre">==</span> <span class="pre">1</span></code>.</p>
</dd></dl>

<dl class="c member">
<dt id="c.Py_buffer.format">
<em class="property">const</em> char *<code class="sig-name descname">format</code><a class="headerlink" href="#c.Py_buffer.format" title="Link permanente para esta definição">¶</a><br /></dt>
<dd><p>Uma string terminada por <em>NUL</em> no estilo de sintaxe de módulo <a class="reference internal" href="../library/struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code></a> descrevendo os conteúdos de um único item. Se isso é <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;B&quot;</span></code> (unsigned bytes) é assumido.</p>
<p>Este campo é controlado pelo sinalizador <a class="reference internal" href="#c.PyBUF_FORMAT" title="PyBUF_FORMAT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyBUF_FORMAT</span></code></a>.</p>
</dd></dl>

<dl class="c member">
<dt id="c.Py_buffer.ndim">
int <code class="sig-name descname">ndim</code><a class="headerlink" href="#c.Py_buffer.ndim" title="Link permanente para esta definição">¶</a><br /></dt>
<dd><p>O número de dimensões que a memória representa como um vetor n-dimensional. Se é <code class="docutils literal notranslate"><span class="pre">0</span></code>, <a class="reference internal" href="#c.Py_buffer.buf" title="Py_buffer.buf"><code class="xref c c-member docutils literal notranslate"><span class="pre">buf</span></code></a> aponta para um único item representando um escalar. Neste caso, <a class="reference internal" href="#c.Py_buffer.shape" title="Py_buffer.shape"><code class="xref c c-member docutils literal notranslate"><span class="pre">shape</span></code></a>, <a class="reference internal" href="#c.Py_buffer.strides" title="Py_buffer.strides"><code class="xref c c-member docutils literal notranslate"><span class="pre">strides</span></code></a> e <a class="reference internal" href="#c.Py_buffer.suboffsets" title="Py_buffer.suboffsets"><code class="xref c c-member docutils literal notranslate"><span class="pre">suboffsets</span></code></a> DEVEM ser <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<p>A macro <code class="xref c c-macro docutils literal notranslate"><span class="pre">PyBUF_MAX_NDIM</span></code> limita o número máximo de dimensões a 64. Os exportadores DEVEM respeitar esse limite, os consumidores de buffers multidimensionais DEVEM ser capazes de lidar com dimensões <code class="xref c c-macro docutils literal notranslate"><span class="pre">PyBUF_MAX_NDIM</span></code>.</p>
</dd></dl>

<dl class="c member">
<dt id="c.Py_buffer.shape">
<a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t">Py_ssize_t</a> *<code class="sig-name descname">shape</code><a class="headerlink" href="#c.Py_buffer.shape" title="Link permanente para esta definição">¶</a><br /></dt>
<dd><p>Uma matriz de <a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a> do comprimento <a class="reference internal" href="#c.Py_buffer.ndim" title="Py_buffer.ndim"><code class="xref c c-member docutils literal notranslate"><span class="pre">ndim</span></code></a> indicando a forma da memória como uma matriz n-dimensional. Observe que a forma <code class="docutils literal notranslate"><span class="pre">shape[0]</span> <span class="pre">*</span> <span class="pre">...</span> <span class="pre">*</span> <span class="pre">shape[ndim-1]</span> <span class="pre">*</span> <span class="pre">itemsize</span></code> DEVE ser igual a <a class="reference internal" href="#c.Py_buffer.len" title="Py_buffer.len"><code class="xref c c-member docutils literal notranslate"><span class="pre">len</span></code></a>.</p>
<p>Os valores da forma são restritos a <code class="docutils literal notranslate"><span class="pre">shape[n]</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code>. The case <code class="docutils literal notranslate"><span class="pre">shape[n]</span> <span class="pre">==</span> <span class="pre">0</span></code> requer atenção especial. Veja <a class="reference internal" href="#complex-arrays">complex arrays</a> para mais informações.</p>
<p>A forma de acesso a matriz é de somente leitura para o usuário.</p>
</dd></dl>

<dl class="c member">
<dt id="c.Py_buffer.strides">
<a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t">Py_ssize_t</a> *<code class="sig-name descname">strides</code><a class="headerlink" href="#c.Py_buffer.strides" title="Link permanente para esta definição">¶</a><br /></dt>
<dd><p>Um vetor de <a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a> de comprimento <a class="reference internal" href="#c.Py_buffer.ndim" title="Py_buffer.ndim"><code class="xref c c-member docutils literal notranslate"><span class="pre">ndim</span></code></a> dando o número de bytes para saltar para obter um novo elemento em cada dimensão.</p>
<p>Os valores de Stride podem ser qualquer número inteiro. Para arrays regulares, os passos são geralmente positivos, mas um consumidor DEVE ser capaz de lidar com o caso <code class="docutils literal notranslate"><span class="pre">strides[n]</span> <span class="pre">&lt;=</span> <span class="pre">0</span></code>. Veja <a class="reference internal" href="#complex-arrays">complex arrays</a> para mais informações.</p>
<p>A matriz de passos é somente leitura para o consumidor.</p>
</dd></dl>

<dl class="c member">
<dt id="c.Py_buffer.suboffsets">
<a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t">Py_ssize_t</a> *<code class="sig-name descname">suboffsets</code><a class="headerlink" href="#c.Py_buffer.suboffsets" title="Link permanente para esta definição">¶</a><br /></dt>
<dd><p>Uma matriz de <a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a> de comprimento <a class="reference internal" href="#c.Py_buffer.ndim" title="Py_buffer.ndim"><code class="xref c c-member docutils literal notranslate"><span class="pre">ndim</span></code></a>. Se <code class="docutils literal notranslate"><span class="pre">suboffsets[n]</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code>, os valores armazenados ao longo da n-ésima dimensão são ponteiros e o valor suboffset determina quantos bytes para adicionar a cada ponteiro após desreferenciar. Um valor de suboffset que é negativo indica que não deve ocorrer desreferenciação (caminhando em um bloco de memória contíguo).</p>
<p>Se todos os subconjuntos forem negativos (ou seja, não é necessário fazer referência), então este campo deve ser <code class="docutils literal notranslate"><span class="pre">NULL</span></code> (o valor padrão).</p>
<p>Esse tipo de representação de matriz é usado pela Python Imaging Library (PIL). Veja <a class="reference internal" href="#complex-arrays">complex arrays</a> para obter mais informações sobre como acessar elementos dessa matriz.a matriz.</p>
<p>A matriz de subconjuntos é somente leitura para o consumidor.</p>
</dd></dl>

<dl class="c member">
<dt id="c.Py_buffer.internal">
void *<code class="sig-name descname">internal</code><a class="headerlink" href="#c.Py_buffer.internal" title="Link permanente para esta definição">¶</a><br /></dt>
<dd><p>Isso é para uso interno pelo objeto exportador. Por exemplo, isso pode ser re-moldado como um número inteiro pelo exportador e usado para armazenar bandeiras sobre se os conjuntos de forma, passos e suboffsets devem ou não ser liberados quando o buffer é liberado. O consumidor NÃO DEVE alterar esse valor.</p>
</dd></dl>

</dd></dl>

</section>
<section id="buffer-request-types">
<span id="id2"></span><h2>Tipos de solicitação do buffer<a class="headerlink" href="#buffer-request-types" title="Link permanente para este título">¶</a></h2>
<p>Os buffers geralmente são obtidos enviando uma solicitação de buffer para um objeto exportador via <a class="reference internal" href="#c.PyObject_GetBuffer" title="PyObject_GetBuffer"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GetBuffer()</span></code></a>. Uma vez que a complexidade da estrutura lógica da memória pode variar drasticamente, o consumidor usa o argumento <em>flags</em> para especificar o tipo de buffer exato que pode manipular.</p>
<p>Todos <a class="reference internal" href="#c.Py_buffer" title="Py_buffer"><code class="xref c c-data docutils literal notranslate"><span class="pre">Py_buffer</span></code></a> são inequivocamente definidos pelo tipo de solicitação.</p>
<section id="request-independent-fields">
<h3>campos independentes do pedido<a class="headerlink" href="#request-independent-fields" title="Link permanente para este título">¶</a></h3>
<p>Os seguintes campos não são influenciados por <em>flags</em> e devem sempre ser preenchidos com os valores corretos: <a class="reference internal" href="#c.Py_buffer.obj" title="Py_buffer.obj"><code class="xref c c-member docutils literal notranslate"><span class="pre">obj</span></code></a>, <a class="reference internal" href="#c.Py_buffer.buf" title="Py_buffer.buf"><code class="xref c c-member docutils literal notranslate"><span class="pre">buf</span></code></a>, <a class="reference internal" href="#c.Py_buffer.len" title="Py_buffer.len"><code class="xref c c-member docutils literal notranslate"><span class="pre">len</span></code></a>, <a class="reference internal" href="#c.Py_buffer.itemsize" title="Py_buffer.itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">itemsize</span></code></a>, <a class="reference internal" href="#c.Py_buffer.ndim" title="Py_buffer.ndim"><code class="xref c c-member docutils literal notranslate"><span class="pre">ndim</span></code></a>.</p>
</section>
<section id="readonly-format">
<h3>apenas em formato<a class="headerlink" href="#readonly-format" title="Link permanente para este título">¶</a></h3>
<blockquote>
<div><dl class="c macro">
<dt id="c.PyBUF_WRITABLE">
<code class="sig-name descname">PyBUF_WRITABLE</code><a class="headerlink" href="#c.PyBUF_WRITABLE" title="Link permanente para esta definição">¶</a><br /></dt>
<dd><p>Controla o campo <a class="reference internal" href="#c.Py_buffer.readonly" title="Py_buffer.readonly"><code class="xref c c-member docutils literal notranslate"><span class="pre">readonly</span></code></a>. Se configurado, o exportador DEVE fornecer um buffer gravável ou então reportar falha. Caso contrário, o exportador pode fornecer um buffer de somente leitura ou gravável, mas a escolha DEVE ser consistente para todos os consumidores.</p>
</dd></dl>

<dl class="c macro">
<dt id="c.PyBUF_FORMAT">
<code class="sig-name descname">PyBUF_FORMAT</code><a class="headerlink" href="#c.PyBUF_FORMAT" title="Link permanente para esta definição">¶</a><br /></dt>
<dd><p>Controla o campo <a class="reference internal" href="#c.Py_buffer.format" title="Py_buffer.format"><code class="xref c c-member docutils literal notranslate"><span class="pre">format</span></code></a>. Se configurado, este campo DEVE ser preenchido corretamente. Caso contrário, este campo DEVE ser <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
</dd></dl>

</div></blockquote>
<p>:<a class="reference internal" href="#c.PyBUF_WRITABLE" title="PyBUF_WRITABLE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyBUF_WRITABLE</span></code></a> pode ser |’d para qualquer um dos sinalizadores na próxima seção. Uma vez que <a class="reference internal" href="#c.PyBUF_WRITABLE" title="PyBUF_WRITABLE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyBUF_WRITABLE</span></code></a> é definido como 0, <a class="reference internal" href="#c.PyBUF_WRITABLE" title="PyBUF_WRITABLE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyBUF_WRITABLE</span></code></a> pode ser usado como uma bandeira autônoma para solicitar um buffer simples gravável.</p>
<p><a class="reference internal" href="#c.PyBUF_FORMAT" title="PyBUF_FORMAT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyBUF_FORMAT</span></code></a> pode ser |’d para qualquer um dos sinalizadores, exceto <a class="reference internal" href="#c.PyBUF_SIMPLE" title="PyBUF_SIMPLE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyBUF_SIMPLE</span></code></a>. O último já implica o formato <code class="docutils literal notranslate"><span class="pre">B</span></code> (bytes não assinados).</p>
</section>
<section id="shape-strides-suboffsets">
<h3>forma, avanços, suboffsets<a class="headerlink" href="#shape-strides-suboffsets" title="Link permanente para este título">¶</a></h3>
<p>As bandeiras que controlam a estrutura lógica da memória estão listadas em ordem decrescente de complexidade. Observe que cada bandeira contém todos os bits das bandeiras abaixo.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 51%" />
<col style="width: 12%" />
<col style="width: 16%" />
<col style="width: 21%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Solicitação</p></th>
<th class="head"><p>Forma</p></th>
<th class="head"><p>Avanços</p></th>
<th class="head"><p>suboffsets</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><dl class="c macro">
<dt id="c.PyBUF_INDIRECT">
<code class="sig-name descname">PyBUF_INDIRECT</code><a class="headerlink" href="#c.PyBUF_INDIRECT" title="Link permanente para esta definição">¶</a><br /></dt>
<dd></dd></dl>

</td>
<td><p>sim</p></td>
<td><p>sim</p></td>
<td><p>se necessário</p></td>
</tr>
<tr class="row-odd"><td><dl class="c macro">
<dt id="c.PyBUF_STRIDES">
<code class="sig-name descname">PyBUF_STRIDES</code><a class="headerlink" href="#c.PyBUF_STRIDES" title="Link permanente para esta definição">¶</a><br /></dt>
<dd></dd></dl>

</td>
<td><p>sim</p></td>
<td><p>sim</p></td>
<td><p>NULL</p></td>
</tr>
<tr class="row-even"><td><dl class="c macro">
<dt id="c.PyBUF_ND">
<code class="sig-name descname">PyBUF_ND</code><a class="headerlink" href="#c.PyBUF_ND" title="Link permanente para esta definição">¶</a><br /></dt>
<dd></dd></dl>

</td>
<td><p>sim</p></td>
<td><p>NULL</p></td>
<td><p>NULL</p></td>
</tr>
<tr class="row-odd"><td><dl class="c macro">
<dt id="c.PyBUF_SIMPLE">
<code class="sig-name descname">PyBUF_SIMPLE</code><a class="headerlink" href="#c.PyBUF_SIMPLE" title="Link permanente para esta definição">¶</a><br /></dt>
<dd></dd></dl>

</td>
<td><p>NULL</p></td>
<td><p>NULL</p></td>
<td><p>NULL</p></td>
</tr>
</tbody>
</table>
</section>
<section id="contiguity-requests">
<span id="index-2"></span><h3>requisições contíguas<a class="headerlink" href="#contiguity-requests" title="Link permanente para este título">¶</a></h3>
<p><a class="reference internal" href="../glossary.html#term-contiguous"><span class="xref std std-term">contiguity</span></a> do C ou Fortran podem ser explicitamente solicitadas, com ou sem informação de avanço. Sem informação de avanço, o buffer deve ser C-contíguo.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 49%" />
<col style="width: 10%" />
<col style="width: 13%" />
<col style="width: 17%" />
<col style="width: 11%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Solicitação</p></th>
<th class="head"><p>Forma</p></th>
<th class="head"><p>Avanços</p></th>
<th class="head"><p>suboffsets</p></th>
<th class="head"><p>contig</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><dl class="c macro">
<dt id="c.PyBUF_C_CONTIGUOUS">
<code class="sig-name descname">PyBUF_C_CONTIGUOUS</code><a class="headerlink" href="#c.PyBUF_C_CONTIGUOUS" title="Link permanente para esta definição">¶</a><br /></dt>
<dd></dd></dl>

</td>
<td><p>sim</p></td>
<td><p>sim</p></td>
<td><p>NULL</p></td>
<td><p>C</p></td>
</tr>
<tr class="row-odd"><td><dl class="c macro">
<dt id="c.PyBUF_F_CONTIGUOUS">
<code class="sig-name descname">PyBUF_F_CONTIGUOUS</code><a class="headerlink" href="#c.PyBUF_F_CONTIGUOUS" title="Link permanente para esta definição">¶</a><br /></dt>
<dd></dd></dl>

</td>
<td><p>sim</p></td>
<td><p>sim</p></td>
<td><p>NULL</p></td>
<td><p>F</p></td>
</tr>
<tr class="row-even"><td><dl class="c macro">
<dt id="c.PyBUF_ANY_CONTIGUOUS">
<code class="sig-name descname">PyBUF_ANY_CONTIGUOUS</code><a class="headerlink" href="#c.PyBUF_ANY_CONTIGUOUS" title="Link permanente para esta definição">¶</a><br /></dt>
<dd></dd></dl>

</td>
<td><p>sim</p></td>
<td><p>sim</p></td>
<td><p>NULL</p></td>
<td><p>C ou F</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyBUF_ND" title="PyBUF_ND"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyBUF_ND</span></code></a></p></td>
<td><p>sim</p></td>
<td><p>NULL</p></td>
<td><p>NULL</p></td>
<td><p>C</p></td>
</tr>
</tbody>
</table>
</section>
<section id="compound-requests">
<h3>requisições compostas<a class="headerlink" href="#compound-requests" title="Link permanente para este título">¶</a></h3>
<p>Todas as requisições possíveis foram completamente definidas por alguma combinação dos sinalizadores na seção anterior. Por conveniência, o protocolo do buffer fornece combinações frequentemente utilizadas como sinalizadores únicos.</p>
<p>Na seguinte tabela <em>U</em> significa contiguidade indefinida. O consumidor deve chamar <a class="reference internal" href="#c.PyBuffer_IsContiguous" title="PyBuffer_IsContiguous"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyBuffer_IsContiguous()</span></code></a> para determinar a contiguidade.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 36%" />
<col style="width: 8%" />
<col style="width: 11%" />
<col style="width: 14%" />
<col style="width: 9%" />
<col style="width: 12%" />
<col style="width: 9%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Solicitação</p></th>
<th class="head"><p>Forma</p></th>
<th class="head"><p>Avanços</p></th>
<th class="head"><p>suboffsets</p></th>
<th class="head"><p>contig</p></th>
<th class="head"><p>readonly</p></th>
<th class="head"><p>formato</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><dl class="c macro">
<dt id="c.PyBUF_FULL">
<code class="sig-name descname">PyBUF_FULL</code><a class="headerlink" href="#c.PyBUF_FULL" title="Link permanente para esta definição">¶</a><br /></dt>
<dd></dd></dl>

</td>
<td><p>sim</p></td>
<td><p>sim</p></td>
<td><p>se necessário</p></td>
<td><p>U</p></td>
<td><p>0</p></td>
<td><p>sim</p></td>
</tr>
<tr class="row-odd"><td><dl class="c macro">
<dt id="c.PyBUF_FULL_RO">
<code class="sig-name descname">PyBUF_FULL_RO</code><a class="headerlink" href="#c.PyBUF_FULL_RO" title="Link permanente para esta definição">¶</a><br /></dt>
<dd></dd></dl>

</td>
<td><p>sim</p></td>
<td><p>sim</p></td>
<td><p>se necessário</p></td>
<td><p>U</p></td>
<td><p>1 ou 0</p></td>
<td><p>sim</p></td>
</tr>
<tr class="row-even"><td><dl class="c macro">
<dt id="c.PyBUF_RECORDS">
<code class="sig-name descname">PyBUF_RECORDS</code><a class="headerlink" href="#c.PyBUF_RECORDS" title="Link permanente para esta definição">¶</a><br /></dt>
<dd></dd></dl>

</td>
<td><p>sim</p></td>
<td><p>sim</p></td>
<td><p>NULL</p></td>
<td><p>U</p></td>
<td><p>0</p></td>
<td><p>sim</p></td>
</tr>
<tr class="row-odd"><td><dl class="c macro">
<dt id="c.PyBUF_RECORDS_RO">
<code class="sig-name descname">PyBUF_RECORDS_RO</code><a class="headerlink" href="#c.PyBUF_RECORDS_RO" title="Link permanente para esta definição">¶</a><br /></dt>
<dd></dd></dl>

</td>
<td><p>sim</p></td>
<td><p>sim</p></td>
<td><p>NULL</p></td>
<td><p>U</p></td>
<td><p>1 ou 0</p></td>
<td><p>sim</p></td>
</tr>
<tr class="row-even"><td><dl class="c macro">
<dt id="c.PyBUF_STRIDED">
<code class="sig-name descname">PyBUF_STRIDED</code><a class="headerlink" href="#c.PyBUF_STRIDED" title="Link permanente para esta definição">¶</a><br /></dt>
<dd></dd></dl>

</td>
<td><p>sim</p></td>
<td><p>sim</p></td>
<td><p>NULL</p></td>
<td><p>U</p></td>
<td><p>0</p></td>
<td><p>NULL</p></td>
</tr>
<tr class="row-odd"><td><dl class="c macro">
<dt id="c.PyBUF_STRIDED_RO">
<code class="sig-name descname">PyBUF_STRIDED_RO</code><a class="headerlink" href="#c.PyBUF_STRIDED_RO" title="Link permanente para esta definição">¶</a><br /></dt>
<dd></dd></dl>

</td>
<td><p>sim</p></td>
<td><p>sim</p></td>
<td><p>NULL</p></td>
<td><p>U</p></td>
<td><p>1 ou 0</p></td>
<td><p>NULL</p></td>
</tr>
<tr class="row-even"><td><dl class="c macro">
<dt id="c.PyBUF_CONTIG">
<code class="sig-name descname">PyBUF_CONTIG</code><a class="headerlink" href="#c.PyBUF_CONTIG" title="Link permanente para esta definição">¶</a><br /></dt>
<dd></dd></dl>

</td>
<td><p>sim</p></td>
<td><p>NULL</p></td>
<td><p>NULL</p></td>
<td><p>C</p></td>
<td><p>0</p></td>
<td><p>NULL</p></td>
</tr>
<tr class="row-odd"><td><dl class="c macro">
<dt id="c.PyBUF_CONTIG_RO">
<code class="sig-name descname">PyBUF_CONTIG_RO</code><a class="headerlink" href="#c.PyBUF_CONTIG_RO" title="Link permanente para esta definição">¶</a><br /></dt>
<dd></dd></dl>

</td>
<td><p>sim</p></td>
<td><p>NULL</p></td>
<td><p>NULL</p></td>
<td><p>C</p></td>
<td><p>1 ou 0</p></td>
<td><p>NULL</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="complex-arrays">
<h2>Vetores Complexos<a class="headerlink" href="#complex-arrays" title="Link permanente para este título">¶</a></h2>
<section id="numpy-style-shape-and-strides">
<h3>Estilo NumPy: forma e avanços<a class="headerlink" href="#numpy-style-shape-and-strides" title="Link permanente para este título">¶</a></h3>
<p>A estrutura lógica de vetores do estilo NumPy é definida por <a class="reference internal" href="#c.Py_buffer.itemsize" title="Py_buffer.itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">itemsize</span></code></a>, <a class="reference internal" href="#c.Py_buffer.ndim" title="Py_buffer.ndim"><code class="xref c c-member docutils literal notranslate"><span class="pre">ndim</span></code></a>, <a class="reference internal" href="#c.Py_buffer.shape" title="Py_buffer.shape"><code class="xref c c-member docutils literal notranslate"><span class="pre">shape</span></code></a> e <a class="reference internal" href="#c.Py_buffer.strides" title="Py_buffer.strides"><code class="xref c c-member docutils literal notranslate"><span class="pre">strides</span></code></a>.</p>
<p>Se <code class="docutils literal notranslate"><span class="pre">ndim</span> <span class="pre">==</span> <span class="pre">0</span></code>, a localização da memória apontada para <a class="reference internal" href="#c.Py_buffer.buf" title="Py_buffer.buf"><code class="xref c c-member docutils literal notranslate"><span class="pre">buf</span></code></a> é interpretada como um escalar de tamanho <a class="reference internal" href="#c.Py_buffer.itemsize" title="Py_buffer.itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">itemsize</span></code></a>. Nesse caso, ambos <a class="reference internal" href="#c.Py_buffer.shape" title="Py_buffer.shape"><code class="xref c c-member docutils literal notranslate"><span class="pre">shape</span></code></a> e <a class="reference internal" href="#c.Py_buffer.strides" title="Py_buffer.strides"><code class="xref c c-member docutils literal notranslate"><span class="pre">strides</span></code></a> são <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<p>Se <a class="reference internal" href="#c.Py_buffer.strides" title="Py_buffer.strides"><code class="xref c c-member docutils literal notranslate"><span class="pre">strides</span></code></a> é <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, o vetor é interpretado como um vetor C n-dimensional padrão. Caso contrário, o consumidor deve acessar um vetor n-dimensional como a seguir:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">strides</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">indices</span><span class="p">[</span><span class="n">n</span><span class="mi">-1</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">strides</span><span class="p">[</span><span class="n">n</span><span class="mi">-1</span><span class="p">];</span><span class="w"></span>
<span class="n">item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="p">((</span><span class="n">typeof</span><span class="p">(</span><span class="n">item</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Como notado acima, <a class="reference internal" href="#c.Py_buffer.buf" title="Py_buffer.buf"><code class="xref c c-member docutils literal notranslate"><span class="pre">buf</span></code></a> pode apontar para qualquer localização dentro do bloco de memória em si. Um exportador pode verificar a validade de um buffer com essa função:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">verify_structure</span><span class="p">(</span><span class="n">memlen</span><span class="p">,</span> <span class="n">itemsize</span><span class="p">,</span> <span class="n">ndim</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">strides</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Verify that the parameters represent a valid array within</span>
<span class="sd">       the bounds of the allocated memory:</span>
<span class="sd">           char *mem: start of the physical memory block</span>
<span class="sd">           memlen: length of the physical memory block</span>
<span class="sd">           offset: (char *)buf - mem</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">offset</span> <span class="o">%</span> <span class="n">itemsize</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">offset</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">offset</span><span class="o">+</span><span class="n">itemsize</span> <span class="o">&gt;</span> <span class="n">memlen</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span> <span class="o">%</span> <span class="n">itemsize</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">strides</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="n">ndim</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">shape</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">strides</span>
    <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="n">imin</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">strides</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">)</span>
               <span class="k">if</span> <span class="n">strides</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">imax</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">strides</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">)</span>
               <span class="k">if</span> <span class="n">strides</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">offset</span><span class="o">+</span><span class="n">imin</span> <span class="ow">and</span> <span class="n">offset</span><span class="o">+</span><span class="n">imax</span><span class="o">+</span><span class="n">itemsize</span> <span class="o">&lt;=</span> <span class="n">memlen</span>
</pre></div>
</div>
</section>
<section id="pil-style-shape-strides-and-suboffsets">
<h3>Estilo-PIL: forma, avanços e suboffsets<a class="headerlink" href="#pil-style-shape-strides-and-suboffsets" title="Link permanente para este título">¶</a></h3>
<p>Além dos itens normais, uma matriz em estilo PIL pode conter ponteiros que devem ser seguidos para se obter o próximo elemento em uma dimensão. Por exemplo, a matriz tridimensional em C <code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">v[2][2][3]</span></code> também pode ser vista como um vetor de 2 ponteiros para duas matrizes bidimensionais: <code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">(*v[2])[2][3]</span></code>. Na representação por suboffsets, esses dois ponteiros podem ser embutidos no início de <a class="reference internal" href="#c.Py_buffer.buf" title="Py_buffer.buf"><code class="xref c c-member docutils literal notranslate"><span class="pre">buf</span></code></a>, apontando para duas matrizes <code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">x[2][3]</span></code> que podem estar localizadas em qualquer lugar na memória.</p>
<p>Here is a function that returns a pointer to the element in an N-D array
pointed to by an N-dimensional index when there are both non-<code class="docutils literal notranslate"><span class="pre">NULL</span></code> strides
and suboffsets:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">get_item_pointer</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">ndim</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">Py_ssize_t</span><span class="w"> </span><span class="o">*</span><span class="n">strides</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="n">Py_ssize_t</span><span class="w"> </span><span class="o">*</span><span class="n">suboffsets</span><span class="p">,</span><span class="w"> </span><span class="n">Py_ssize_t</span><span class="w"> </span><span class="o">*</span><span class="n">indices</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">pointer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">ndim</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">pointer</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">strides</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">suboffsets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;=</span><span class="mi">0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">pointer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="p">((</span><span class="kt">char</span><span class="o">**</span><span class="p">)</span><span class="n">pointer</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">suboffsets</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">pointer</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="buffer-related-functions">
<h2>Buffer-related functions<a class="headerlink" href="#buffer-related-functions" title="Link permanente para este título">¶</a></h2>
<dl class="c function">
<dt id="c.PyObject_CheckBuffer">
int <code class="sig-name descname">PyObject_CheckBuffer</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a> *<em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyObject_CheckBuffer" title="Link permanente para esta definição">¶</a><br /></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">1</span></code> if <em>obj</em> supports the buffer interface otherwise <code class="docutils literal notranslate"><span class="pre">0</span></code>.  When <code class="docutils literal notranslate"><span class="pre">1</span></code> is
returned, it doesn’t guarantee that <a class="reference internal" href="#c.PyObject_GetBuffer" title="PyObject_GetBuffer"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GetBuffer()</span></code></a> will
succeed.  This function always succeeds.</p>
</dd></dl>

<dl class="c function">
<dt id="c.PyObject_GetBuffer">
int <code class="sig-name descname">PyObject_GetBuffer</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a> *<em>exporter</em>, <a class="reference internal" href="#c.Py_buffer" title="Py_buffer">Py_buffer</a> *<em>view</em>, int <em>flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyObject_GetBuffer" title="Link permanente para esta definição">¶</a><br /></dt>
<dd><p>Send a request to <em>exporter</em> to fill in <em>view</em> as specified by  <em>flags</em>.
If the exporter cannot provide a buffer of the exact type, it MUST raise
<code class="xref c c-data docutils literal notranslate"><span class="pre">PyExc_BufferError</span></code>, set <code class="docutils literal notranslate"><span class="pre">view-&gt;obj</span></code> to <code class="docutils literal notranslate"><span class="pre">NULL</span></code> and
return <code class="docutils literal notranslate"><span class="pre">-1</span></code>.</p>
<p>On success, fill in <em>view</em>, set <code class="docutils literal notranslate"><span class="pre">view-&gt;obj</span></code> to a new reference
to <em>exporter</em> and return 0. In the case of chained buffer providers
that redirect requests to a single object, <code class="docutils literal notranslate"><span class="pre">view-&gt;obj</span></code> MAY
refer to this object instead of <em>exporter</em> (See <a class="reference internal" href="typeobj.html#buffer-structs"><span class="std std-ref">Buffer Object Structures</span></a>).</p>
<p>Successful calls to <a class="reference internal" href="#c.PyObject_GetBuffer" title="PyObject_GetBuffer"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GetBuffer()</span></code></a> must be paired with calls
to <a class="reference internal" href="#c.PyBuffer_Release" title="PyBuffer_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyBuffer_Release()</span></code></a>, similar to <code class="xref c c-func docutils literal notranslate"><span class="pre">malloc()</span></code> and <code class="xref c c-func docutils literal notranslate"><span class="pre">free()</span></code>.
Thus, after the consumer is done with the buffer, <a class="reference internal" href="#c.PyBuffer_Release" title="PyBuffer_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyBuffer_Release()</span></code></a>
must be called exactly once.</p>
</dd></dl>

<dl class="c function">
<dt id="c.PyBuffer_Release">
void <code class="sig-name descname">PyBuffer_Release</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_buffer" title="Py_buffer">Py_buffer</a> *<em>view</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyBuffer_Release" title="Link permanente para esta definição">¶</a><br /></dt>
<dd><p>Release the buffer <em>view</em> and decrement the reference count for
<code class="docutils literal notranslate"><span class="pre">view-&gt;obj</span></code>. This function MUST be called when the buffer
is no longer being used, otherwise reference leaks may occur.</p>
<p>It is an error to call this function on a buffer that was not obtained via
<a class="reference internal" href="#c.PyObject_GetBuffer" title="PyObject_GetBuffer"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GetBuffer()</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt id="c.PyBuffer_SizeFromFormat">
<a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t">Py_ssize_t</a> <code class="sig-name descname">PyBuffer_SizeFromFormat</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>format</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyBuffer_SizeFromFormat" title="Link permanente para esta definição">¶</a><br /></dt>
<dd><p>Return the implied <a class="reference internal" href="#c.Py_buffer.itemsize" title="Py_buffer.itemsize"><code class="xref c c-data docutils literal notranslate"><span class="pre">itemsize</span></code></a> from <a class="reference internal" href="#c.Py_buffer.format" title="Py_buffer.format"><code class="xref c c-data docutils literal notranslate"><span class="pre">format</span></code></a>.
On error, raise an exception and return -1.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.9.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt id="c.PyBuffer_IsContiguous">
int <code class="sig-name descname">PyBuffer_IsContiguous</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_buffer" title="Py_buffer">Py_buffer</a> *<em>view</em>, char <em>order</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyBuffer_IsContiguous" title="Link permanente para esta definição">¶</a><br /></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">1</span></code> if the memory defined by the <em>view</em> is C-style (<em>order</em> is
<code class="docutils literal notranslate"><span class="pre">'C'</span></code>) or Fortran-style (<em>order</em> is <code class="docutils literal notranslate"><span class="pre">'F'</span></code>) <a class="reference internal" href="../glossary.html#term-contiguous"><span class="xref std std-term">contiguous</span></a> or either one
(<em>order</em> is <code class="docutils literal notranslate"><span class="pre">'A'</span></code>).  Return <code class="docutils literal notranslate"><span class="pre">0</span></code> otherwise.  This function always succeeds.</p>
</dd></dl>

<dl class="c function">
<dt id="c.PyBuffer_GetPointer">
void *<code class="sig-name descname">PyBuffer_GetPointer</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_buffer" title="Py_buffer">Py_buffer</a> *<em>view</em>, <a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t">Py_ssize_t</a> *<em>indices</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyBuffer_GetPointer" title="Link permanente para esta definição">¶</a><br /></dt>
<dd><p>Get the memory area pointed to by the <em>indices</em> inside the given <em>view</em>.
<em>indices</em> must point to an array of <code class="docutils literal notranslate"><span class="pre">view-&gt;ndim</span></code> indices.</p>
</dd></dl>

<dl class="c function">
<dt id="c.PyBuffer_FromContiguous">
int <code class="sig-name descname">PyBuffer_FromContiguous</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_buffer" title="Py_buffer">Py_buffer</a> *<em>view</em>, void *<em>buf</em>, <a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t">Py_ssize_t</a> <em>len</em>, char <em>fort</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyBuffer_FromContiguous" title="Link permanente para esta definição">¶</a><br /></dt>
<dd><p>Copy contiguous <em>len</em> bytes from <em>buf</em> to <em>view</em>.
<em>fort</em> can be <code class="docutils literal notranslate"><span class="pre">'C'</span></code> or <code class="docutils literal notranslate"><span class="pre">'F'</span></code> (for C-style or Fortran-style ordering).
<code class="docutils literal notranslate"><span class="pre">0</span></code> is returned on success, <code class="docutils literal notranslate"><span class="pre">-1</span></code> on error.</p>
</dd></dl>

<dl class="c function">
<dt id="c.PyBuffer_ToContiguous">
int <code class="sig-name descname">PyBuffer_ToContiguous</code><span class="sig-paren">(</span>void *<em>buf</em>, <a class="reference internal" href="#c.Py_buffer" title="Py_buffer">Py_buffer</a> *<em>src</em>, <a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t">Py_ssize_t</a> <em>len</em>, char <em>order</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyBuffer_ToContiguous" title="Link permanente para esta definição">¶</a><br /></dt>
<dd><p>Copy <em>len</em> bytes from <em>src</em> to its contiguous representation in <em>buf</em>.
<em>order</em> can be <code class="docutils literal notranslate"><span class="pre">'C'</span></code> or <code class="docutils literal notranslate"><span class="pre">'F'</span></code> or <code class="docutils literal notranslate"><span class="pre">'A'</span></code> (for C-style or Fortran-style
ordering or either one). <code class="docutils literal notranslate"><span class="pre">0</span></code> is returned on success, <code class="docutils literal notranslate"><span class="pre">-1</span></code> on error.</p>
<p>This function fails if <em>len</em> != <em>src-&gt;len</em>.</p>
</dd></dl>

<dl class="c function">
<dt id="c.PyBuffer_FillContiguousStrides">
void <code class="sig-name descname">PyBuffer_FillContiguousStrides</code><span class="sig-paren">(</span>int <em>ndims</em>, <a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t">Py_ssize_t</a> *<em>shape</em>, <a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t">Py_ssize_t</a> *<em>strides</em>, int <em>itemsize</em>, char <em>order</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyBuffer_FillContiguousStrides" title="Link permanente para esta definição">¶</a><br /></dt>
<dd><p>Fill the <em>strides</em> array with byte-strides of a <a class="reference internal" href="../glossary.html#term-contiguous"><span class="xref std std-term">contiguous</span></a> (C-style if
<em>order</em> is <code class="docutils literal notranslate"><span class="pre">'C'</span></code> or Fortran-style if <em>order</em> is <code class="docutils literal notranslate"><span class="pre">'F'</span></code>) array of the
given shape with the given number of bytes per element.</p>
</dd></dl>

<dl class="c function">
<dt id="c.PyBuffer_FillInfo">
int <code class="sig-name descname">PyBuffer_FillInfo</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_buffer" title="Py_buffer">Py_buffer</a> *<em>view</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a> *<em>exporter</em>, void *<em>buf</em>, <a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t">Py_ssize_t</a> <em>len</em>, int <em>readonly</em>, int <em>flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyBuffer_FillInfo" title="Link permanente para esta definição">¶</a><br /></dt>
<dd><p>Handle buffer requests for an exporter that wants to expose <em>buf</em> of size <em>len</em>
with writability set according to <em>readonly</em>. <em>buf</em> is interpreted as a sequence
of unsigned bytes.</p>
<p>The <em>flags</em> argument indicates the request type. This function always fills in
<em>view</em> as specified by flags, unless <em>buf</em> has been designated as read-only
and <a class="reference internal" href="#c.PyBUF_WRITABLE" title="PyBUF_WRITABLE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyBUF_WRITABLE</span></code></a> is set in <em>flags</em>.</p>
<p>On success, set <code class="docutils literal notranslate"><span class="pre">view-&gt;obj</span></code> to a new reference to <em>exporter</em> and
return 0. Otherwise, raise <code class="xref c c-data docutils literal notranslate"><span class="pre">PyExc_BufferError</span></code>, set
<code class="docutils literal notranslate"><span class="pre">view-&gt;obj</span></code> to <code class="docutils literal notranslate"><span class="pre">NULL</span></code> and return <code class="docutils literal notranslate"><span class="pre">-1</span></code>;</p>
<p>If this function is used as part of a <a class="reference internal" href="typeobj.html#buffer-structs"><span class="std std-ref">getbufferproc</span></a>,
<em>exporter</em> MUST be set to the exporting object and <em>flags</em> must be passed
unmodified. Otherwise, <em>exporter</em> MUST be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
</dd></dl>

</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Tabela de Conteúdo</a></h3>
  <ul>
<li><a class="reference internal" href="#">Protocolo de Buffer</a><ul>
<li><a class="reference internal" href="#buffer-structure">Estrutura de Buffer</a></li>
<li><a class="reference internal" href="#buffer-request-types">Tipos de solicitação do buffer</a><ul>
<li><a class="reference internal" href="#request-independent-fields">campos independentes do pedido</a></li>
<li><a class="reference internal" href="#readonly-format">apenas em formato</a></li>
<li><a class="reference internal" href="#shape-strides-suboffsets">forma, avanços, suboffsets</a></li>
<li><a class="reference internal" href="#contiguity-requests">requisições contíguas</a></li>
<li><a class="reference internal" href="#compound-requests">requisições compostas</a></li>
</ul>
</li>
<li><a class="reference internal" href="#complex-arrays">Vetores Complexos</a><ul>
<li><a class="reference internal" href="#numpy-style-shape-and-strides">Estilo NumPy: forma e avanços</a></li>
<li><a class="reference internal" href="#pil-style-shape-strides-and-suboffsets">Estilo-PIL: forma, avanços e suboffsets</a></li>
</ul>
</li>
<li><a class="reference internal" href="#buffer-related-functions">Buffer-related functions</a></li>
</ul>
</li>
</ul>

  <h4>Tópico anterior</h4>
  <p class="topless"><a href="iter.html"
                        title="capítulo anterior">Protocolo Iterador</a></p>
  <h4>Próximo tópico</h4>
  <p class="topless"><a href="objbuffer.html"
                        title="próximo capítulo">Protocolo de Buffer Antigo</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Relatar um erro</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.10/Doc/c-api/buffer.rst"
            rel="nofollow">Exibir código-fonte
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegação</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice geral"
             >índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="objbuffer.html" title="Protocolo de Buffer Antigo"
             >próximo</a> |</li>
        <li class="right" >
          <a href="iter.html" title="Protocolo Iterador"
             >anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.10.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Manual de referência da API Python/C</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="abstract.html" >Camada de Objetos Abstratos</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Protocolo de Buffer</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Busca rápida" aria-label="Busca rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Direitos autorais</a> 2001-2022, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    Última atualização em jun. 04, 2022.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.4.3.
    </div>

  </body>
</html>