
<!DOCTYPE html>

<html lang="pt_BR">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17: http://docutils.sourceforge.net/" />

    <title>3. Modelo de dados &#8212; documentação Python 3.10.4</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pydoctheme.css?2022.1" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Pesquisar dentro de documentação Python 3.10.4"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="Sobre esses documentos" href="../about.html" />
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Buscar" href="../search.html" />
    <link rel="copyright" title="Direitos autorais" href="../copyright.html" />
    <link rel="next" title="4. Modelo de execução" href="executionmodel.html" />
    <link rel="prev" title="2. Análise léxica" href="lexical_analysis.html" />
    <link rel="canonical" href="https://docs.python.org/3/reference/datamodel.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <label for="menuToggler" class="toggler__label">
        <span></span>
    </label>
    <nav class="nav-content" role="navigation">
         <a href="https://www.python.org/" class="nav-logo">
             <img src="../_static/py.svg" alt="Logo"/>
         </a>
        <div class="version_switcher_placeholder"></div>
        <form role="search" class="search" action="../search.html" method="get">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                <path fill-rule="nonzero"
                        d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="#444"></path>
            </svg>
            <input type="text" name="q" aria-label="Busca rápida"/>
            <input type="submit" value="Ir"/>
        </form>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
  <h3><a href="../contents.html">Tabela de Conteúdo</a></h3>
  <ul>
<li><a class="reference internal" href="#">3. Modelo de dados</a><ul>
<li><a class="reference internal" href="#objects-values-and-types">3.1. Objetos, valores e tipos</a></li>
<li><a class="reference internal" href="#the-standard-type-hierarchy">3.2. A hierarquia de tipos padrão</a></li>
<li><a class="reference internal" href="#special-method-names">3.3. Nomes de métodos especiais</a><ul>
<li><a class="reference internal" href="#basic-customization">3.3.1. Personalização básica</a></li>
<li><a class="reference internal" href="#customizing-attribute-access">3.3.2. Personalizando o acesso aos atributos</a><ul>
<li><a class="reference internal" href="#customizing-module-attribute-access">3.3.2.1. Personalizando acesso a atributos de módulos</a></li>
<li><a class="reference internal" href="#implementing-descriptors">3.3.2.2. Implementando descritores</a></li>
<li><a class="reference internal" href="#invoking-descriptors">3.3.2.3. Invocando descritores</a></li>
<li><a class="reference internal" href="#slots">3.3.2.4. __slots__</a><ul>
<li><a class="reference internal" href="#notes-on-using-slots">3.3.2.4.1. Observações ao uso de <em>__slots__</em></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#customizing-class-creation">3.3.3. Personalizando a criação de classe</a><ul>
<li><a class="reference internal" href="#metaclasses">3.3.3.1. Metaclasses</a></li>
<li><a class="reference internal" href="#resolving-mro-entries">3.3.3.2. Resolvendo entradas de MRO</a></li>
<li><a class="reference internal" href="#determining-the-appropriate-metaclass">3.3.3.3. Determinando a metaclasse apropriada</a></li>
<li><a class="reference internal" href="#preparing-the-class-namespace">3.3.3.4. Preparando o espaço de nomes da classe</a></li>
<li><a class="reference internal" href="#executing-the-class-body">3.3.3.5. Executando o corpo da classe</a></li>
<li><a class="reference internal" href="#creating-the-class-object">3.3.3.6. Criando o objeto da classe</a></li>
<li><a class="reference internal" href="#uses-for-metaclasses">3.3.3.7. Usos para metaclasses</a></li>
</ul>
</li>
<li><a class="reference internal" href="#customizing-instance-and-subclass-checks">3.3.4. Personalizando verificações de instância e subclasse</a></li>
<li><a class="reference internal" href="#emulating-generic-types">3.3.5. Emulando tipos genéricos</a><ul>
<li><a class="reference internal" href="#the-purpose-of-class-getitem">3.3.5.1. The purpose of <em>__class_getitem__</em></a></li>
<li><a class="reference internal" href="#class-getitem-versus-getitem">3.3.5.2. <em>__class_getitem__</em> versus <em>__getitem__</em></a></li>
</ul>
</li>
<li><a class="reference internal" href="#emulating-callable-objects">3.3.6. Emulando objetos chamáveis</a></li>
<li><a class="reference internal" href="#emulating-container-types">3.3.7. Emulando de tipos contêineres</a></li>
<li><a class="reference internal" href="#emulating-numeric-types">3.3.8. Emulando tipos numéricos</a></li>
<li><a class="reference internal" href="#with-statement-context-managers">3.3.9. Com gerenciadores de contexto de instruções</a></li>
<li><a class="reference internal" href="#customizing-positional-arguments-in-class-pattern-matching">3.3.10. Customizando argumentos posicionais na classe correspondência de padrão</a></li>
<li><a class="reference internal" href="#special-method-lookup">3.3.11. Pesquisa de método especial</a></li>
</ul>
</li>
<li><a class="reference internal" href="#coroutines">3.4. Corrotinas</a><ul>
<li><a class="reference internal" href="#awaitable-objects">3.4.1. Objetos aguardáveis</a></li>
<li><a class="reference internal" href="#coroutine-objects">3.4.2. Objetos corrotina</a></li>
<li><a class="reference internal" href="#asynchronous-iterators">3.4.3. Iteradores assíncronos</a></li>
<li><a class="reference internal" href="#asynchronous-context-managers">3.4.4. Gerenciadores de contexto assíncronos</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Tópico anterior</h4>
  <p class="topless"><a href="lexical_analysis.html"
                        title="capítulo anterior"><span class="section-number">2. </span>Análise léxica</a></p>
  <h4>Próximo tópico</h4>
  <p class="topless"><a href="executionmodel.html"
                        title="próximo capítulo"><span class="section-number">4. </span>Modelo de execução</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Relatar um erro</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.10/Doc/reference/datamodel.rst"
            rel="nofollow">Exibir código-fonte
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegação</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice geral"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="executionmodel.html" title="4. Modelo de execução"
             accesskey="N">próximo</a> |</li>
        <li class="right" >
          <a href="lexical_analysis.html" title="2. Análise léxica"
             accesskey="P">anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.10.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">A Referência da Linguagem Python</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">3. </span>Modelo de dados</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Busca rápida" aria-label="Busca rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="data-model">
<span id="datamodel"></span><h1><span class="section-number">3. </span>Modelo de dados<a class="headerlink" href="#data-model" title="Link permanente para este título">¶</a></h1>
<section id="objects-values-and-types">
<span id="objects"></span><h2><span class="section-number">3.1. </span>Objetos, valores e tipos<a class="headerlink" href="#objects-values-and-types" title="Link permanente para este título">¶</a></h2>
<p id="index-0"><em class="dfn">Objetos</em> são abstrações do Python para dados. Todos dados em um programa Python são representados por objetos ou por relações entre objetos. (De certo modo, e em conformidade com o modelo de Von Neumann em “stored program computer”, código também é representado por objetos.)</p>
<span class="target" id="index-1"></span><p>Todo objeto tem uma identidade, um tipo e um valor. A <em>identidade</em> de um objeto nunca muda depois de criado; você pode pensar nisso como endereço de objetos em memória. O operador ‘<a class="reference internal" href="expressions.html#is"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span></code></a>’ compara as identidades de dois objetos; a função <a class="reference internal" href="../library/functions.html#id" title="id"><code class="xref py py-func docutils literal notranslate"><span class="pre">id()</span></code></a> retorna um inteiro representando sua identidade.</p>
<div class="impl-detail compound">
<p><strong>CPython implementation detail:</strong> Para CPython, <code class="docutils literal notranslate"><span class="pre">id(x)</span></code> é o endereço de memória em que <code class="docutils literal notranslate"><span class="pre">x</span></code> é armazenado.</p>
</div>
<p>O tipo de um objeto determina as operações que o objeto suporta (por exemplo, “ele tem um <em>length</em>?”) e também define os valores possíveis para objetos desse tipo. A função <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a> retorna o tipo de um objeto (que é o próprio objeto). Como sua identidade, o <em class="dfn">tipo</em> do objeto também é imutável. <a class="footnote-reference brackets" href="#id8" id="id1">1</a></p>
<p>O <em>valor</em> de alguns objetos pode mudar. Objetos cujos valores podem mudar são descritos como <em>mutáveis</em>, objetos cujo valor não pode ser mudado uma vez que foram criados são chamados <em>imutáveis</em>. (O valor de um objeto contêiner que contém uma referência a um objeto mutável pode mudar quando o valor deste último for mudado; no entanto o contêiner é ainda assim considerada imutável, pois a coleção de objetos que contém não pode ser mudada. Então a imutabilidade não é estritamente o mesmo do que não haver mudanças de valor, é mais sutil.) A mutabilidade de um objeto é determinada pelo seu tipo; por exemplo, números, strings e tuplas são imutáveis, enquanto dicionários e listas são mutáveis.</p>
<p id="index-2">Os objetos nunca são destruídos explicitamente; no entanto, quando eles se tornam inacessíveis, eles podem ser coletados como lixo. Uma implementação tem permissão para adiar a coleta de lixo ou omiti-la completamente – é uma questão de qualidade de implementação como a coleta de lixo é implementada, desde que nenhum objeto seja coletado que ainda esteja acessível.</p>
<div class="impl-detail compound">
<p><strong>CPython implementation detail:</strong> CPython atualmente usa um esquema de contagem de referências com detecção atrasada (opcional) de lixo ligado ciclicamente, que coleta a maioria dos objetos assim que eles se tornam inacessíveis, mas não é garantido que coletará lixo contendo referências circulares. Veja a documentação do módulo <a class="reference internal" href="../library/gc.html#module-gc" title="gc: Interface to the cycle-detecting garbage collector."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gc</span></code></a> para informações sobre como controlar a coleta de lixo cíclico. Outras implementações agem de forma diferente e o CPython pode mudar. Não dependa da finalização imediata dos objetos quando eles se tornarem inacessíveis (isto é, você deve sempre fechar os arquivos explicitamente).</p>
</div>
<p>Observe que o uso dos recursos de rastreamento ou depuração da implementação pode manter os objetos ativos que normalmente seriam coletáveis. Observe também que capturar uma exceção com uma instrução “<a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a>…<a class="reference internal" href="compound_stmts.html#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a>” pode manter os objetos vivos.</p>
<p>Alguns objetos contêm referências a recursos “externos”, como arquivos abertos ou janelas. Entende-se que esses recursos são liberados quando o objeto é coletado como lixo, mas como a coleta de lixo não é garantida, tais objetos também fornecem uma maneira explícita de liberar o recurso externo, geralmente um método <code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code>. Os programas são fortemente recomendados para fechar explicitamente esses objetos. A instrução “<a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a>…<a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a>” e a instrução “<a class="reference internal" href="compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>” fornecem maneiras convenientes de fazer isso.</p>
<p id="index-3">Alguns objetos contêm referências a outros objetos; eles são chamados de <em>contêineres</em>. Exemplos de contêineres são tuplas, listas e dicionários. As referências fazem parte do valor de um contêiner. Na maioria dos casos, quando falamos sobre o valor de um contêiner, nos referimos aos valores, não às identidades dos objetos contidos; entretanto, quando falamos sobre a mutabilidade de um contêiner, apenas as identidades dos objetos contidos imediatamente estão implícitas. Portanto, se um contêiner imutável (como uma tupla) contém uma referência a um objeto mutável, seu valor muda se esse objeto mutável for alterado.</p>
<p>Os tipos afetam quase todos os aspectos do comportamento do objeto. Até mesmo a importância da identidade do objeto é afetada em algum sentido: para tipos imutáveis, as operações que calculam novos valores podem realmente retornar uma referência a qualquer objeto existente com o mesmo tipo e valor, enquanto para objetos mutáveis isso não é permitido. Por exemplo, após <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">1;</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">a</span></code> e <code class="docutils literal notranslate"><span class="pre">b</span></code> podem ou não se referir ao mesmo objeto com o valor um, dependendo da implementação, mas após <code class="docutils literal notranslate"><span class="pre">c</span> <span class="pre">=</span> <span class="pre">[];</span> <span class="pre">d</span> <span class="pre">=</span> <span class="pre">[]</span></code>, <code class="docutils literal notranslate"><span class="pre">c</span></code> e <code class="docutils literal notranslate"><span class="pre">d</span></code> têm a garantia de referir-se a duas listas vazias diferentes e únicas. (Observe que <code class="docutils literal notranslate"><span class="pre">c</span> <span class="pre">=</span> <span class="pre">d</span> <span class="pre">=</span> <span class="pre">[]</span></code> atribui o mesmo objeto para <code class="docutils literal notranslate"><span class="pre">c</span></code> e <code class="docutils literal notranslate"><span class="pre">d</span></code>.)</p>
</section>
<section id="the-standard-type-hierarchy">
<span id="types"></span><h2><span class="section-number">3.2. </span>A hierarquia de tipos padrão<a class="headerlink" href="#the-standard-type-hierarchy" title="Link permanente para este título">¶</a></h2>
<p id="index-4">Abaixo está uma lista dos tipos que são embutidos no Python. Módulos de extensão (escritos em C, Java ou outras linguagens, dependendo da implementação) podem definir tipos adicionais. Versões futuras do Python podem adicionar tipos à hierarquia de tipo (por exemplo, números racionais, matrizes de inteiros armazenadas de forma eficiente, etc.), embora tais adições sejam frequentemente fornecidas por meio da biblioteca padrão.</p>
<p id="index-5">Algumas das descrições de tipo abaixo contêm um parágrafo listando “atributos especiais”. Esses são atributos que fornecem acesso à implementação e não se destinam ao uso geral. Sua definição pode mudar no futuro.</p>
<dl>
<dt>None</dt><dd><p id="index-6">Este tipo possui um único valor. Existe um único objeto com este valor. Este objeto é acessado através do nome embutido <code class="docutils literal notranslate"><span class="pre">None</span></code>. É usado para significar a ausência de um valor em muitas situações, por exemplo, ele é retornado de funções que não retornam nada explicitamente. Seu valor de verdade é falso.</p>
</dd>
<dt>NotImplemented</dt><dd><p id="index-7">Este tipo possui um único valor. Existe um único objeto com este valor. Este objeto é acessado através do nome embutido <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code>. Os métodos numéricos e métodos de comparação rica devem retornar esse valor se não implementarem a operação para os operandos fornecidos. (O interpretador tentará então a operação refletida ou alguma outra alternativa, dependendo do operador.) Não deve ser avaliado em um contexto booleano.</p>
<p>Veja a documentação <a class="reference internal" href="../library/numbers.html#implementing-the-arithmetic-operations"><span class="std std-ref">Implementando as operações aritméticas</span></a> para mais detalhes.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.9: </span>A avaliação de <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code> em um contexto booleano foi descontinuado. Embora atualmente seja avaliado como verdadeiro, ele emitirá um <a class="reference internal" href="../library/exceptions.html#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a>. Ele levantará uma <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> em uma versão futura do Python.</p>
</div>
</dd>
<dt>Ellipsis</dt><dd><p id="index-8">Este tipo possui um único valor. Existe um único objeto com este valor. Este objeto é acessado através do literal <code class="docutils literal notranslate"><span class="pre">...</span></code> ou do nome embutido <code class="docutils literal notranslate"><span class="pre">Ellipsis</span></code> (reticências). Seu valor de verdade é true.</p>
</dd>
<dt><a class="reference internal" href="../library/numbers.html#numbers.Number" title="numbers.Number"><code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Number</span></code></a></dt><dd><p id="index-9">Eles são criados por literais numéricos e retornados como resultados por operadores aritméticos e funções aritméticas integradas. Os objetos numéricos são imutáveis; uma vez criado, seu valor nunca muda. Os números do Python são, obviamente, fortemente relacionados aos números matemáticos, mas sujeitos às limitações da representação numérica em computadores.</p>
<p>The string representations of the numeric classes, computed by
<a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code></a> and <a class="reference internal" href="#object.__str__" title="object.__str__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__str__()</span></code></a>, have the following
properties:</p>
<ul class="simple">
<li><p>Elas são literais numéricos válidos que, quando passados para seu construtor de classe, produzem um objeto com o valor do numérico original.</p></li>
<li><p>A representação está na base 10, quando possível.</p></li>
<li><p>Os zeros à esquerda, possivelmente com exceção de um único zero antes de um ponto decimal, não são mostrados.</p></li>
<li><p>Os zeros à direita, possivelmente com exceção de um único zero após um ponto decimal, não são mostrados.</p></li>
<li><p>Um sinal é mostrado apenas quando o número é negativo.</p></li>
</ul>
<p>Python distingue entre inteiros, números de ponto flutuante e números complexos:</p>
<dl>
<dt><a class="reference internal" href="../library/numbers.html#numbers.Integral" title="numbers.Integral"><code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Integral</span></code></a></dt><dd><p id="index-10">Estes representam elementos do conjunto matemático de inteiros (positivos e negativos).</p>
<p>Existem dois tipos de inteiros:</p>
<dl>
<dt>Integers (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>)</dt><dd><p>Eles representam números em um intervalo ilimitado, sujeito apenas à memória (virtual) disponível. Para o propósito de operações de deslocamento e máscara, uma representação binária é assumida e os números negativos são representados em uma variante do complemento de 2 que dá a ilusão de uma string infinita de bits de sinal estendendo-se para a esquerda.</p>
</dd>
<dt>Booleanos (<a class="reference internal" href="../library/functions.html#bool" title="bool"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a>)</dt><dd><p id="index-11">Estes representam os valores da verdade Falsos e Verdadeiros. Os dois objetos que representam os valores <code class="docutils literal notranslate"><span class="pre">False</span></code> e <code class="docutils literal notranslate"><span class="pre">True</span></code> são os únicos objetos booleanos. O tipo booleano é um subtipo do tipo inteiro, e os valores booleanos se comportam como os valores 0 e 1, respectivamente, em quase todos os contextos, com exceção de que, quando convertidos em uma string, as strings <code class="docutils literal notranslate"><span class="pre">&quot;False&quot;</span></code> ou <code class="docutils literal notranslate"><span class="pre">&quot;True&quot;</span></code> são retornados, respectivamente.</p>
</dd>
</dl>
<p id="index-12">As regras para representação de inteiros têm como objetivo fornecer a interpretação mais significativa das operações de deslocamento e máscara envolvendo inteiros negativos.</p>
</dd>
<dt><a class="reference internal" href="../library/numbers.html#numbers.Real" title="numbers.Real"><code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Real</span></code></a> (<a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>)</dt><dd><p id="index-13">Eles representam números de ponto flutuante de precisão dupla no nível da máquina. Você está à mercê da arquitetura da máquina subjacente (e implementação C ou Java) para o intervalo aceito e tratamento de estouro. Python não oferece suporte a números de ponto flutuante de precisão única; a economia no uso do processador e da memória, que normalmente é o motivo de usá-los, é ofuscada pela sobrecarga do uso de objetos em Python, portanto, não há razão para complicar a linguagem com dois tipos de números de ponto flutuante.</p>
</dd>
<dt><a class="reference internal" href="../library/numbers.html#numbers.Complex" title="numbers.Complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Complex</span></code></a> (<a class="reference internal" href="../library/functions.html#complex" title="complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code></a>)</dt><dd><p id="index-14">Eles representam números complexos como um par de números de ponto flutuante de precisão dupla no nível da máquina. As mesmas advertências se aplicam aos números de ponto flutuante. As partes reais e imaginárias de um número complexo <code class="docutils literal notranslate"><span class="pre">z</span></code> podem ser obtidas através dos atributos somente leitura <code class="docutils literal notranslate"><span class="pre">z.real</span></code> e <code class="docutils literal notranslate"><span class="pre">z.imag</span></code>.</p>
</dd>
</dl>
</dd>
<dt>Sequências</dt><dd><p id="index-15">Eles representam conjuntos ordenados finitos indexados por números não negativos. A função embutida <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> retorna o número de itens de uma sequência. Quando o comprimento de uma sequência é <em>n</em>, o conjunto de índices contém os números 0, 1, …, <em>n</em>-1. O item <em>i</em> da sequência <em>a</em> é selecionado por <code class="docutils literal notranslate"><span class="pre">a[i]</span></code>.</p>
<p id="index-16">Sequências também suportam fatiamento: <code class="docutils literal notranslate"><span class="pre">a[i:j]</span></code> seleciona todos os itens com índice <em>k</em> de forma que <em>i</em> <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code> <em>k</em> <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> <em>j</em>. Quando usada como expressão, uma fatia é uma sequência do mesmo tipo. Isso implica que o conjunto de índices é renumerado para que comece em 0.</p>
<p>Algumas sequências também suportam “fatiamento estendido” com um terceiro parâmetro de “etapa”: <code class="docutils literal notranslate"><span class="pre">a[i:j:k]</span></code> seleciona todos os itens de <em>a</em> com índice <em>x</em> onde <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">i</span> <span class="pre">+</span> <span class="pre">n*k</span></code>, <em>n</em> <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code> <code class="docutils literal notranslate"><span class="pre">0</span></code> e <em>i</em> <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code> <em>x</em> <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> <em>j</em>.</p>
<p>As sequências são distinguidas de acordo com sua mutabilidade:</p>
<dl>
<dt>Sequências imutáveis</dt><dd><p id="index-17">Um objeto de um tipo de sequência imutável não pode ser alterado depois de criado. (Se o objeto contiver referências a outros objetos, esses outros objetos podem ser mutáveis e podem ser alterados; no entanto, a coleção de objetos diretamente referenciada por um objeto imutável não pode ser alterada.)</p>
<p>Os tipos a seguir são sequências imutáveis:</p>
<dl id="index-18">
<dt>Strings</dt><dd><p id="index-19">Uma string é uma sequência de valores que representam pontos de código Unicode. Todos os pontos de código no intervalo <code class="docutils literal notranslate"><span class="pre">U+0000</span> <span class="pre">-</span> <span class="pre">U+10FFFF</span></code> podem ser representados em uma string. Python não tem um tipo <span class="xref c c-texpr">char</span>; em vez disso, cada ponto de código na string é representado como um objeto string com comprimento <code class="docutils literal notranslate"><span class="pre">1</span></code>. A função embutida <a class="reference internal" href="../library/functions.html#ord" title="ord"><code class="xref py py-func docutils literal notranslate"><span class="pre">ord()</span></code></a> converte um ponto de código de sua forma de string para um inteiro no intervalo <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">-</span> <span class="pre">10FFFF</span></code>; <a class="reference internal" href="../library/functions.html#chr" title="chr"><code class="xref py py-func docutils literal notranslate"><span class="pre">chr()</span></code></a> converte um inteiro no intervalo <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">-</span> <span class="pre">10FFFF</span></code> para o objeto de string correspondente de comprimento <code class="docutils literal notranslate"><span class="pre">1</span></code>. <a class="reference internal" href="../library/stdtypes.html#str.encode" title="str.encode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.encode()</span></code></a> pode ser usado para converter uma <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> para <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> usando a codificação de texto fornecida, e <a class="reference internal" href="../library/stdtypes.html#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytes.decode()</span></code></a> pode ser usado para conseguir o oposto.</p>
</dd>
<dt>Tuplas</dt><dd><p id="index-20">Os itens de uma tupla são objetos Python arbitrários. Tuplas de dois ou mais itens são formadas por listas de expressões separadas por vírgulas. Uma tupla de um item (um “singleton”) pode ser formada afixando uma vírgula a uma expressão (uma expressão por si só não cria uma tupla, já que os parênteses devem ser usados para agrupamento de expressões). Uma tupla vazia pode ser formada por um par vazio de parênteses.</p>
</dd>
<dt>Bytes</dt><dd><p id="index-21">Um objeto bytes é um vetor imutável. Os itens são bytes de 8 bits, representados por inteiros no intervalo 0 &lt;= x &lt; 256. Literais de bytes (como <code class="docutils literal notranslate"><span class="pre">b'abc'</span></code>) e o construtor embutido <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-func docutils literal notranslate"><span class="pre">bytes()</span></code></a> podem ser usados para criar objetos bytes. Além disso, os objetos bytes podem ser decodificados em strings através do método <a class="reference internal" href="../library/stdtypes.html#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code></a>.</p>
</dd>
</dl>
</dd>
<dt>Sequências mutáveis</dt><dd><p id="index-22">As sequências mutáveis podem ser alteradas após serem criadas. As notações de assinatura e fatiamento podem ser usadas como o destino da atribuição e instruções <a class="reference internal" href="simple_stmts.html#del"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">del</span></code></a> (<em>delete</em>, exclusão).</p>
<p>Atualmente, existem dois tipos de sequência mutável intrínseca:</p>
<dl>
<dt>Listas</dt><dd><p id="index-23">Os itens de uma lista são objetos Python arbitrários. As listas são formadas colocando uma lista separada por vírgulas de expressões entre colchetes. (Observe que não há casos especiais necessários para formar listas de comprimento 0 ou 1.)</p>
</dd>
<dt>Vetores de bytes</dt><dd><p id="index-24">Um objeto bytearray é um vetor mutável. Eles são criados pelo construtor embutido <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-func docutils literal notranslate"><span class="pre">bytearray()</span></code></a>. Além de serem mutáveis (e, portanto, inalteráveis), os vetores de bytes fornecem a mesma interface e funcionalidade que os objetos imutáveis <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>.</p>
</dd>
</dl>
<p id="index-25">O módulo de extensão <a class="reference internal" href="../library/array.html#module-array" title="array: Space efficient arrays of uniformly typed numeric values."><code class="xref py py-mod docutils literal notranslate"><span class="pre">array</span></code></a> fornece um exemplo adicional de um tipo de sequência mutável, assim como o módulo <a class="reference internal" href="../library/collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a>.</p>
</dd>
</dl>
</dd>
<dt>Tipos conjuntos</dt><dd><p id="index-26">Eles representam conjuntos finitos e não ordenados de objetos únicos e imutáveis. Como tal, eles não podem ser indexados por nenhum subscrito. No entanto, eles podem ser iterados, e a função embutida <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> retorna o número de itens em um conjunto. Os usos comuns para conjuntos são testes rápidos de associação, remoção de duplicatas de uma sequência e computação de operações matemáticas como interseção, união, diferença e diferença simétrica.</p>
<p>Para elementos de conjunto, as mesmas regras de imutabilidade se aplicam às chaves de dicionário. Observe que os tipos numéricos obedecem às regras normais para comparação numérica: se dois números forem iguais (por exemplo, <code class="docutils literal notranslate"><span class="pre">1</span></code> e <code class="docutils literal notranslate"><span class="pre">1.0</span></code>), apenas um deles pode estar contido em um conjunto.</p>
<p>Atualmente, existem dois tipos de conjuntos intrínsecos:</p>
<dl>
<dt>Conjuntos</dt><dd><p id="index-27">Eles representam um conjunto mutável. Eles são criados pelo construtor embutido <a class="reference internal" href="../library/stdtypes.html#set" title="set"><code class="xref py py-func docutils literal notranslate"><span class="pre">set()</span></code></a> e podem ser modificados posteriormente por vários métodos, como <code class="xref py py-meth docutils literal notranslate"><span class="pre">add()</span></code>.</p>
</dd>
<dt>Frozen sets</dt><dd><p id="index-28">Eles representam um conjunto imutável. Eles são criados pelo construtor embutido <a class="reference internal" href="../library/stdtypes.html#frozenset" title="frozenset"><code class="xref py py-func docutils literal notranslate"><span class="pre">frozenset()</span></code></a>. Como um frozenset é imutável e <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hasheável</span></a>, ele pode ser usado novamente como um elemento de outro conjunto, ou como uma chave de dicionário.</p>
</dd>
</dl>
</dd>
<dt>Mapeamentos</dt><dd><p id="index-29">Eles representam conjuntos finitos de objetos indexados por conjuntos de índices arbitrários. A notação subscrito <code class="docutils literal notranslate"><span class="pre">a[k]</span></code> seleciona o item indexado por <code class="docutils literal notranslate"><span class="pre">k</span></code> do mapeamento <code class="docutils literal notranslate"><span class="pre">a</span></code>; isso pode ser usado em expressões e como alvo de atribuições ou instruções <a class="reference internal" href="simple_stmts.html#del"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">del</span></code></a>. A função embutida <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> retorna o número de itens em um mapeamento.</p>
<p>Atualmente, há um único tipo de mapeamento intrínseco:</p>
<dl>
<dt>Dicionários</dt><dd><p id="index-30">Eles representam conjuntos finitos de objetos indexados por valores quase arbitrários. Os únicos tipos de valores não aceitáveis como chaves são os valores que contêm listas ou dicionários ou outros tipos mutáveis que são comparados por valor em vez de por identidade de objeto, o motivo é que a implementação eficiente de dicionários requer que o valor de hash de uma chave permaneça constante. Os tipos numéricos usados para chaves obedecem às regras normais para comparação numérica: se dois números forem iguais (por exemplo, <code class="docutils literal notranslate"><span class="pre">1</span></code> e <code class="docutils literal notranslate"><span class="pre">1.0</span></code>), eles podem ser usados alternadamente para indexar a mesma entrada do dicionário.</p>
<p>Dicionários preservam a ordem de inserção, o que significa que as chaves serão produzidas na mesma ordem em que foram adicionadas sequencialmente no dicionário. Substituir uma chave existente não altera a ordem, no entanto, remover uma chave e inseri-la novamente irá adicioná-la ao final em vez de manter seu lugar anterior.</p>
<p>Os dicionários são mutáveis; eles podem ser criados pela notação <code class="docutils literal notranslate"><span class="pre">{...}</span></code> (veja a seção <a class="reference internal" href="expressions.html#dict"><span class="std std-ref">Dictionary displays</span></a>).</p>
<p id="index-31">Os módulos de extensão <a class="reference internal" href="../library/dbm.html#module-dbm.ndbm" title="dbm.ndbm: The standard &quot;database&quot; interface, based on ndbm. (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dbm.ndbm</span></code></a> e <a class="reference internal" href="../library/dbm.html#module-dbm.gnu" title="dbm.gnu: GNU's reinterpretation of dbm. (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dbm.gnu</span></code></a> fornecem exemplos adicionais de tipos de mapeamento, assim como o módulo <a class="reference internal" href="../library/collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.7: </span>Dicionários não preservavam a ordem de inserção nas versões do Python anteriores à 3.6. No CPython 3.6, a ordem de inserção foi preservada, mas foi considerada um detalhe de implementação naquela época, em vez de uma garantia de linguagem.</p>
</div>
</dd>
</dl>
</dd>
<dt>Tipos chamáveis</dt><dd><p id="index-32">Estes são os tipos aos quais a operação de chamada de função (veja a seção <a class="reference internal" href="expressions.html#calls"><span class="std std-ref">Calls</span></a>) pode ser aplicada:</p>
<dl>
<dt>Funções definidas pelo usuário</dt><dd><p id="index-33">Um objeto função definido pelo usuário será criado pela definição de função (veja a seção <a class="reference internal" href="compound_stmts.html#function"><span class="std std-ref">Definições de função</span></a>). A mesma deverá ser invocada com uma lista de argumentos contendo o mesmo número de itens que a lista de parâmetros formais da função.</p>
<p>Atributos especiais:</p>
<table class="docutils align-default" id="index-34">
<colgroup>
<col style="width: 37%" />
<col style="width: 46%" />
<col style="width: 16%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Atributo</p></th>
<th class="head"><p>Significado</p></th>
<th class="head"></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code></p></td>
<td><p>A string de documentação da função, ou <code class="docutils literal notranslate"><span class="pre">None</span></code> se indisponível; não herdado por subclasses.</p></td>
<td><p>Gravável</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="../library/stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a></p></td>
<td><p>O nome da função.</p></td>
<td><p>Gravável</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="../library/stdtypes.html#definition.__qualname__" title="definition.__qualname__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__qualname__</span></code></a></p></td>
<td><p>O <a class="reference internal" href="../glossary.html#term-qualified-name"><span class="xref std std-term">nome qualificado</span></a> da função.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.3.</span></p>
</div>
</td>
<td><p>Gravável</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">__module__</span></code></p></td>
<td><p>O nome do módulo em que a função foi definida ou <code class="docutils literal notranslate"><span class="pre">None</span></code> se indisponível.</p></td>
<td><p>Gravável</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">__defaults__</span></code></p></td>
<td><p>Uma tupla contendo valores de argumento padrão para aqueles argumentos que possuem padrões, ou <code class="docutils literal notranslate"><span class="pre">None</span></code> se nenhum argumento tiver um valor padrão.</p></td>
<td><p>Gravável</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">__code__</span></code></p></td>
<td><p>O objeto código que representa o corpo da função compilada.</p></td>
<td><p>Gravável</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">__globals__</span></code></p></td>
<td><p>Uma referência ao dicionário que contém as variáveis globais da função — o espaço de nomes global do módulo no qual a função foi definida.</p></td>
<td><p>Somente Leitura</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a></p></td>
<td><p>O espaço de nomes que oferece suporte a atributos de função arbitrários.</p></td>
<td><p>Gravável</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">__closure__</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">None</span></code> ou uma tupla de células que contêm ligações para as variáveis livres da função. Veja abaixo as informações sobre o atributo <code class="docutils literal notranslate"><span class="pre">cell_contents</span></code>.</p></td>
<td><p>Somente Leitura</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code></p></td>
<td><p>Um dicionário contendo anotação de parâmetros. As chaves do dicionário são nomes de parâmetros, e <code class="docutils literal notranslate"><span class="pre">'return'</span></code> para retornar a anotação, se fornecido. Para mais informação sobre como trabalhar com esse atributo, veja <a class="reference internal" href="../howto/annotations.html#annotations-howto"><span class="std std-ref">Annotations Best Practices</span></a>.</p></td>
<td><p>Gravável</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">__kwdefaults__</span></code></p></td>
<td><p>Um dicionário contendo padrões para parâmetros somente-nomeados.</p></td>
<td><p>Gravável</p></td>
</tr>
</tbody>
</table>
<p>A maioria dos atributos rotulados como “Gravável” verifica o tipo do valor atribuído.</p>
<p>Os objetos função também suportam a obtenção e configuração de atributos arbitrários, que podem ser usados, por exemplo, para anexar metadados a funções. A notação de ponto de atributo regular é usada para obter e definir esses atributos. <em>Observe que a implementação atual só oferece suporte a atributos de função em funções definidas pelo usuário. Atributos de função embutidas podem ser suportados no futuro.</em></p>
<p>Um objeto de célula tem o atributo <code class="docutils literal notranslate"><span class="pre">cell_contents</span></code>. Isso pode ser usado para obter o valor da célula, bem como definir o valor.</p>
<p>Informações adicionais sobre a definição de uma função podem ser recuperadas de seu objeto de código; veja a descrição dos tipos internos abaixo. O tipo <a class="reference internal" href="../library/types.html#types.CellType" title="types.CellType"><code class="xref py py-data docutils literal notranslate"><span class="pre">cell</span></code></a> pode ser acessado no módulo <a class="reference internal" href="../library/types.html#module-types" title="types: Names for built-in types."><code class="xref py py-mod docutils literal notranslate"><span class="pre">types</span></code></a>.</p>
</dd>
<dt>Instância de métodos</dt><dd><p id="index-35">Um objeto método de instância combina uma classe, uma instância de classe e qualquer objeto chamável (normalmente uma função definida pelo usuário).</p>
<p id="index-36">Atributos especiais somente leitura: <code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> é o objeto de instância da classe, <code class="xref py py-attr docutils literal notranslate"><span class="pre">__func__</span></code> é o objeto função; <code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code> é a documentação do método (mesmo que <code class="docutils literal notranslate"><span class="pre">__func__.__doc__</span></code>); <code class="xref py py-attr docutils literal notranslate"><span class="pre">__</span> <span class="pre">name__</span></code> é o nome do método (mesmo que <code class="docutils literal notranslate"><span class="pre">__func__.__name__</span></code>); <code class="xref py py-attr docutils literal notranslate"><span class="pre">__module__</span></code> é o nome do módulo no qual o método foi definido, ou <code class="docutils literal notranslate"><span class="pre">None</span></code> se indisponível.</p>
<p>Os métodos também suportam o acesso (mas não a configuração) dos atributos arbitrários da função no objeto função subjacente.</p>
<p>Os objetos método definidos pelo usuário podem ser criados ao se obter um atributo de uma classe (talvez por meio de uma instância dessa classe), se esse atributo for um objeto função definido pelo usuário ou um objeto método de classe.</p>
<p>Quando um objeto método de instância é criado recuperando um objeto  função definido pelo usuário de uma classe por meio de uma de suas instâncias, seu atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> é a instância, e o objeto método é considerado vinculado. O atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">__func__</span></code> do novo método é o objeto da função original.</p>
<p>Quando um objeto método de instância é criado recuperando um objeto  método de classe de uma classe ou instância, seu atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> é a própria classe, e seu atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">__func__</span></code> é o objeto função subjacente ao método de classe.</p>
<p>Quando um objeto método de instância é chamado, a função subjacente (<code class="xref py py-attr docutils literal notranslate"><span class="pre">__func__</span></code>) é chamada, inserindo a instância de classe (<code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code>) na frente da lista de argumentos. Por exemplo, quando <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code> é uma classe que contém uma definição para uma função <code class="xref py py-meth docutils literal notranslate"><span class="pre">f()</span></code>, e <code class="docutils literal notranslate"><span class="pre">x</span></code> é uma instância de <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code>, chamando <code class="docutils literal notranslate"><span class="pre">x.f(1)</span></code> é equivalente a chamar <code class="docutils literal notranslate"><span class="pre">C.f(x,</span> <span class="pre">1)</span></code>.</p>
<p>Quando um objeto método de instância é derivado de um objeto método de classe, a “instância de classe” armazenada em <code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> será na verdade a própria classe, de modo que chamar <code class="docutils literal notranslate"><span class="pre">x.f(1)</span></code> ou <code class="docutils literal notranslate"><span class="pre">C.f(1)</span></code> é equivalente a chamar <code class="docutils literal notranslate"><span class="pre">f(C,1)</span></code> sendo <code class="docutils literal notranslate"><span class="pre">f</span></code> a função subjacente.</p>
<p>Observe que a transformação de objeto função em objeto método de instância ocorre sempre que o atributo é recuperado da instância. Em alguns casos, uma otimização frutífera é atribuir o atributo a uma variável local e chamar essa variável local. Observe também que essa transformação ocorre apenas para funções definidas pelo usuário; outros objetos chamáveis (e todos os objetos não chamáveis) são recuperados sem transformação. Também é importante observar que as funções definidas pelo usuário que são atributos de uma instância de classe não são convertidas em métodos vinculados; isso <em>apenas</em> acontece quando a função é um atributo da classe.</p>
</dd>
<dt>Funções geradoras</dt><dd><p id="index-37">A function or method which uses the <a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> statement (see section
<a class="reference internal" href="simple_stmts.html#yield"><span class="std std-ref">The yield statement</span></a>) is called a <em class="dfn">generator function</em>.  Such a function, when
called, always returns an <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a> object which can be used to
execute the body of the function:  calling the iterator’s
<a class="reference internal" href="../library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iterator.__next__()</span></code></a> method will cause the function to execute until
it provides a value using the <code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> statement.  When the
function executes a <a class="reference internal" href="simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> statement or falls off the end, a
<a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> exception is raised and the iterator will have
reached the end of the set of values to be returned.</p>
</dd>
<dt>Funções de corrotina</dt><dd><p id="index-38">Uma função ou um método que é definida(o) usando <a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> é chamado de <em class="dfn">função de corrotina</em>. Tal função, quando chamada, retorna um objeto de <a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">corrotina</span></a>. Ele pode conter expressões <a class="reference internal" href="expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a>, bem como instruções <a class="reference internal" href="compound_stmts.html#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a> e <a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a>. Veja também a seção <a class="reference internal" href="#coroutine-objects"><span class="std std-ref">Objetos corrotina</span></a>.</p>
</dd>
<dt>Funções geradoras assíncronas</dt><dd><p id="index-39">A function or method which is defined using <a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> and
which uses the <a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> statement is called a
<em class="dfn">asynchronous generator function</em>.  Such a function, when called,
returns an <a class="reference internal" href="../glossary.html#term-asynchronous-iterator"><span class="xref std std-term">asynchronous iterator</span></a> object which can be used in an
<a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> statement to execute the body of the function.</p>
<p>Calling the asynchronous iterator’s
<a class="reference internal" href="#object.__anext__" title="object.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aiterator.__anext__</span></code></a> method
will return an <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a> which when awaited
will execute until it provides a value using the <a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a>
expression.  When the function executes an empty <a class="reference internal" href="simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a>
statement or falls off the end, a <a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a> exception
is raised and the asynchronous iterator will have reached the end of
the set of values to be yielded.</p>
</dd>
<dt>Funções embutidas</dt><dd><p id="index-40">Um objeto função embutida é um wrapper em torno de uma função C. Exemplos de funções embutidas são <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> e <a class="reference internal" href="../library/math.html#math.sin" title="math.sin"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.sin()</span></code></a> (<a class="reference internal" href="../library/math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code></a> é um módulo embutido padrão). O número e o tipo dos argumentos são determinados pela função C. Atributos especiais de somente leitura: <code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code> é a string de documentação da função, ou <code class="docutils literal notranslate"><span class="pre">None</span></code> se indisponível; <a class="reference internal" href="../library/stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a> é o nome da função; <code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> é definido como <code class="docutils literal notranslate"><span class="pre">None</span></code> (mas veja o próximo item); <code class="xref py py-attr docutils literal notranslate"><span class="pre">__module__</span></code> é o nome do módulo no qual a função foi definida ou <code class="docutils literal notranslate"><span class="pre">None</span></code> se indisponível.</p>
</dd>
<dt>Métodos embutidos</dt><dd><p id="index-41">Este é realmente um disfarce diferente de uma função embutida, desta vez contendo um objeto passado para a função C como um argumento extra implícito. Um exemplo de método embutido é <code class="docutils literal notranslate"><span class="pre">alist.append()</span></code>, presumindo que <em>alist</em> é um objeto de lista. Nesse caso, o atributo especial de somente leitura <code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> é definido como o objeto denotado por <em>alist</em>.</p>
</dd>
<dt>Classes</dt><dd><p>Classes are callable.  These objects normally act as factories for new
instances of themselves, but variations are possible for class types that
override <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a>.  The arguments of the call are passed to
<code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code> and, in the typical case, to <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> to
initialize the new instance.</p>
</dd>
<dt>Instâncias de classes</dt><dd><p>Instances of arbitrary classes can be made callable by defining a
<a class="reference internal" href="#object.__call__" title="object.__call__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__call__()</span></code></a> method in their class.</p>
</dd>
</dl>
</dd>
<dt>Módulos</dt><dd><p id="index-42">Módulos são uma unidade organizacional básica do código Python, e são criados pelo <a class="reference internal" href="import.html#importsystem"><span class="std std-ref">sistema de importação</span></a> como invocado pela instrução <a class="reference internal" href="simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a>, ou chamando funções como <a class="reference internal" href="../library/importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a> e a embutida <a class="reference internal" href="../library/functions.html#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a>. Um objeto de módulo tem um espaço de nomes implementado por um objeto de dicionário (este é o dicionário referenciado pelo atributo <code class="docutils literal notranslate"><span class="pre">__globals__</span></code> de funções definidas no módulo). As referências de atributos são traduzidas para pesquisas neste dicionário, por exemplo, <code class="docutils literal notranslate"><span class="pre">m.x</span></code> é equivalente a <code class="docutils literal notranslate"><span class="pre">m.__dict__[&quot;x&quot;]</span></code>. Um objeto de módulo não contém o objeto código usado para inicializar o módulo (uma vez que não é necessário depois que a inicialização é concluída).</p>
<p>A atribuição de atributo atualiza o dicionário de espaço de nomes do módulo, por exemplo, <code class="docutils literal notranslate"><span class="pre">m.x</span> <span class="pre">=</span> <span class="pre">1</span></code> é equivalente a <code class="docutils literal notranslate"><span class="pre">m.__dict__[&quot;x&quot;]</span> <span class="pre">=</span> <span class="pre">1</span></code>.</p>
<p id="index-43">Atributos predefinidos graváveis:</p>
<blockquote>
<div><dl class="simple">
<dt><a class="reference internal" href="import.html#name__" title="__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a></dt><dd><p>O nome do módulo</p>
</dd>
<dt><code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code></dt><dd><p>A string de documentação do método, ou <code class="docutils literal notranslate"><span class="pre">None</span></code> se indisponível.</p>
</dd>
<dt><a class="reference internal" href="import.html#file__" title="__file__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__file__</span></code></a></dt><dd><p>O endereço do caminho do arquivo que o módulo foi carregado, se ele foi carregado a partir de um arquivo. O atributo <a class="reference internal" href="import.html#file__" title="__file__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__file__</span></code></a>  pode estar ausente para certos tipos de módulos, como os módulos C que são estaticamente vinculados ao interpretador. Para extensões de módulos carregadas dinamicamente de uma biblioteca compartilhada, é o endereço do caminho do arquivo da biblioteca compartilhada.</p>
</dd>
<dt><code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code></dt><dd><p>Um dicionário contendo <a class="reference internal" href="../glossary.html#term-variable-annotation"><span class="xref std std-term">anotação de variável</span></a>  coletado durante a execução do corpo do módulo. Para as melhores práticas sobre como trabalhar com <code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code>, por favor veja <a class="reference internal" href="../howto/annotations.html#annotations-howto"><span class="std std-ref">Annotations Best Practices</span></a>.</p>
</dd>
</dl>
</div></blockquote>
<p id="index-44">Atributo especial somente leitura: <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> é o espaço de nomes do módulo como um objeto de dicionário.</p>
<div class="impl-detail compound">
<p><strong>CPython implementation detail:</strong> Por causa da maneira como o CPython limpa os dicionários do módulo, o dicionário do módulo será limpo quando o módulo sair do escopo, mesmo se o dicionário ainda tiver referências ativas. Para evitar isso, copie o dicionário ou mantenha o módulo por perto enquanto usa seu dicionário diretamente.</p>
</div>
</dd>
<dt>Classes personalizadas</dt><dd><p>Tipos de classe personalizados são tipicamente criados por definições de classe (veja a seção <a class="reference internal" href="compound_stmts.html#class"><span class="std std-ref">Definições de classe</span></a>). Uma classe possui um espaço de nomes implementado por um objeto de dicionário. As referências de atributos de classe são traduzidas para pesquisas neste dicionário, por exemplo, <code class="docutils literal notranslate"><span class="pre">Cx</span></code> é traduzido para <code class="docutils literal notranslate"><span class="pre">C.__dict__[&quot;x&quot;]</span></code> (embora haja uma série de ganchos que permitem outros meios de localizar atributos) . Quando o nome do atributo não é encontrado lá, a pesquisa do atributo continua nas classes base. Essa pesquisa das classes base usa a ordem de resolução de métodos C3, que se comporta corretamente mesmo na presença de estruturas de herança “diamante”, onde há vários caminhos de herança que levam de volta a um ancestral comum. Detalhes adicionais sobre o C3 MRO usado pelo Python podem ser encontrados na documentação que acompanha a versão 2.3 em <a class="reference external" href="https://www.python.org/download/releases/2.3/mro/">https://www.python.org/download/releases/2.3/mro/</a>.</p>
<p id="index-45">Quando uma referência de atributo de classe (para uma classe <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code>, digamos) produziria um objeto método de classe, ele é transformado em um objeto método de instância cujo atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> é <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code>. Quando produziria um objeto método estático, ele é transformado no objeto encapsulado pelo objeto método estático. Veja a seção <a class="reference internal" href="#descriptors"><span class="std std-ref">Implementando descritores</span></a> para outra maneira em que os atributos recuperados de uma classe podem diferir daqueles realmente contidos em seu <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a>.</p>
<p id="index-46">As atribuições de atributos de classe atualizam o dicionário da classe, nunca o dicionário de uma classe base.</p>
<p id="index-47">Um objeto de classe pode ser chamado (veja acima) para produzir uma instância de classe (veja abaixo).</p>
<p id="index-48">Atributos especiais:</p>
<blockquote>
<div><dl class="simple">
<dt><a class="reference internal" href="../library/stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a></dt><dd><p>O nome da classe</p>
</dd>
<dt><code class="xref py py-attr docutils literal notranslate"><span class="pre">__module__</span></code></dt><dd><p>O nome do módulo no qual a classe foi definida</p>
</dd>
<dt><a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a></dt><dd><p>O dicionário contendo o espaço de nomes da classe</p>
</dd>
<dt><a class="reference internal" href="../library/stdtypes.html#class.__bases__" title="class.__bases__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__bases__</span></code></a></dt><dd><p>Uma tupla contendo a classe base, na ordem de suas ocorrências na lista da classe base.</p>
</dd>
<dt><code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code></dt><dd><p>A string de documentação da classe, ou <code class="docutils literal notranslate"><span class="pre">None</span></code> se não definida.</p>
</dd>
<dt><code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code></dt><dd><p>Um dicionário contendo <a class="reference internal" href="../glossary.html#term-variable-annotation"><span class="xref std std-term">anotação de variável</span></a> colecionado durante a execução do corpo da classe. Para melhores práticas sobre como trabalhar com <code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code>, por favor veja <a class="reference internal" href="../howto/annotations.html#annotations-howto"><span class="std std-ref">Annotations Best Practices</span></a>.</p>
</dd>
</dl>
</div></blockquote>
</dd>
<dt>Instâncias de classe</dt><dd><p id="index-49">A class instance is created by calling a class object (see above).  A class
instance has a namespace implemented as a dictionary which is the first place
in which attribute references are searched.  When an attribute is not found
there, and the instance’s class has an attribute by that name, the search
continues with the class attributes.  If a class attribute is found that is a
user-defined function object, it is transformed into an instance method
object whose <code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> attribute is the instance.  Static method and
class method objects are also transformed; see above under “Classes”.  See
section <a class="reference internal" href="#descriptors"><span class="std std-ref">Implementando descritores</span></a> for another way in which attributes of a class
retrieved via its instances may differ from the objects actually stored in
the class’s <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a>.  If no class attribute is found, and the
object’s class has a <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> method, that is called to satisfy
the lookup.</p>
<p id="index-50">Attribute assignments and deletions update the instance’s dictionary, never a
class’s dictionary.  If the class has a <a class="reference internal" href="#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a> or
<a class="reference internal" href="#object.__delattr__" title="object.__delattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delattr__()</span></code></a> method, this is called instead of updating the instance
dictionary directly.</p>
<p id="index-51">As instâncias de classe podem fingir ser números, sequências ou mapeamentos se tiverem métodos com certos nomes especiais. Veja a seção <a class="reference internal" href="#specialnames"><span class="std std-ref">Nomes de métodos especiais</span></a>.</p>
<p id="index-52">Atributos especiais: <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> é o dicionário de atributos; <a class="reference internal" href="../library/stdtypes.html#instance.__class__" title="instance.__class__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__class__</span></code></a> é a classe da instância.</p>
</dd>
<dt>Objetos de E/S (também conhecidos como objetos arquivo)</dt><dd><p id="index-53">O <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">objeto arquivo</span></a> representa um arquivo aberto. Vários atalhos estão disponíveis para criar objetos arquivos: a função embutida <a class="reference internal" href="../library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a>, e também <a class="reference internal" href="../library/os.html#os.popen" title="os.popen"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.popen()</span></code></a>, <a class="reference internal" href="../library/os.html#os.fdopen" title="os.fdopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fdopen()</span></code></a> e o método <a class="reference internal" href="../library/socket.html#socket.socket.makefile" title="socket.socket.makefile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">makefile()</span></code></a> de objetos soquete (e talvez por outras funções ou métodos fornecidos por módulos de extensão).</p>
<p>Os objetos <code class="docutils literal notranslate"><span class="pre">sys.stdin</span></code>, <code class="docutils literal notranslate"><span class="pre">sys.stdout</span></code> e <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code> são inicializados para objetos arquivo que correspondem aos fluxos de entrada, saída e erro padrão do interpretador; eles são todos abertos em modo texto e, portanto, seguem a interface definida pela classe abstrata <a class="reference internal" href="../library/io.html#io.TextIOBase" title="io.TextIOBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.TextIOBase</span></code></a>.</p>
</dd>
<dt>Tipos internos</dt><dd><p id="index-54">Alguns tipos usados internamente pelo interpretador são expostos ao usuário. Suas definições podem mudar com versões futuras do interpretador, mas são mencionadas aqui para fins de integridade.</p>
<dl id="index-55">
<dt>Objetos código</dt><dd><p>Objetos código representam código Python executável <em>compilados em bytes</em> ou <a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">bytecode</span></a>. A diferença entre um objeto código e um objeto função é que o objeto função contém uma referência explícita aos globais da função (o módulo no qual foi definida), enquanto um objeto código não contém nenhum contexto; também os valores de argumento padrão são armazenados no objeto função, não no objeto código (porque eles representam os valores calculados em tempo de execução). Ao contrário dos objetos função, os objetos código são imutáveis e não contêm referências (direta ou indiretamente) a objetos mutáveis.</p>
<p id="index-56">Atributos especiais de somente leitura: <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_name</span></code> fornece o nome da função; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_argcount</span></code> é o número total de argumentos posicionais (incluindo argumentos apenas posicionais e argumentos com valores padrão); <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_posonlyargcount</span></code> é o número de argumentos somente-posicionais (incluindo argumentos com valores padrão); <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_kwonlyargcount</span></code> é o número de argumentos somente-nomeados (incluindo argumentos com valores padrão); <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_nlocals</span></code> é o número de variáveis ​​locais usadas pela função (incluindo argumentos); <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_varnames</span></code> é uma tupla contendo os nomes das variáveis ​​locais (começando com os nomes dos argumentos); <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_cellvars</span></code> é uma tupla contendo os nomes das variáveis ​​locais que são referenciadas por funções aninhadas; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_freevars</span></code> é uma tupla contendo os nomes das variáveis ​​livres; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_code</span></code> é uma string que representa a sequência de instruções de bytecode; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_consts</span></code> é uma tupla contendo os literais usados ​​pelo bytecode; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_names</span></code> é uma tupla contendo os nomes usados ​​pelo bytecode; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_filename</span></code> é o nome do arquivo a partir do qual o código foi compilado; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_firstlineno</span></code> é o número da primeira linha da função; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_lnotab</span></code> é uma string que codifica o mapeamento de deslocamentos de bytecode para números de linha (para detalhes, veja o código-fonte do interpretador); <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_stacksize</span></code> é o tamanho de pilha necessário; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_flags</span></code> é um inteiro que codifica uma série de sinalizadores para o interpretador.</p>
<p id="index-57">Os seguintes bits de sinalizador são definidos para <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_flags</span></code>: o bit <code class="docutils literal notranslate"><span class="pre">0x04</span></code> é definido se a função usa a sintaxe <code class="docutils literal notranslate"><span class="pre">*arguments</span></code> para aceitar um número arbitrário de argumentos posicionais; o bit <code class="docutils literal notranslate"><span class="pre">0x08</span></code> é definido se a função usa a sintaxe <code class="docutils literal notranslate"><span class="pre">**keywords</span></code> para aceitar argumentos nomeados arbitrários; o bit <code class="docutils literal notranslate"><span class="pre">0x20</span></code> é definido se a função for um gerador.</p>
<p>Declarações de recursos futuros (<code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">division</span></code>) também usam bits em <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_flags</span></code> para indicar se um objeto código foi compilado com um recurso específico habilitado: o bit <code class="docutils literal notranslate"><span class="pre">0x2000</span></code> é definido se a função foi compilada com divisão futura habilitada; os bits <code class="docutils literal notranslate"><span class="pre">0x10</span></code> e <code class="docutils literal notranslate"><span class="pre">0x1000</span></code> foram usados em versões anteriores do Python.</p>
<p>Outros bits em <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_flags</span></code> são reservados para uso interno.</p>
<p id="index-58">Se um objeto código representa uma função, o primeiro item em <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_consts</span></code> é a string de documentação da função, ou <code class="docutils literal notranslate"><span class="pre">None</span></code> se indefinido.</p>
</dd>
</dl>
<dl id="frame-objects">
<dt>Objetos quadro</dt><dd><p id="index-59">Objetos quadro representam quadros de execução. Eles podem ocorrer em objetos traceback (veja abaixo) e também são passados para funções de rastreamento registradas.</p>
<p id="index-60">Atributos especiais de somente leitura: <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_back</span></code> é para o quadro de pilha anterior (para o chamador), ou <code class="docutils literal notranslate"><span class="pre">None</span></code> se este é o quadro de pilha inferior; <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_code</span></code> é o objeto código sendo executado neste quadro; <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_locals</span></code> é o dicionário usado para procurar variáveis locais; <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_globals</span></code> é usado para variáveis globais; <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_builtins</span></code> é usado para nomes embutidos (intrínsecos); <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_lasti</span></code> dá a instrução precisa (este é um índice para a string bytecode do objeto código).</p>
<p>Acessar <code class="docutils literal notranslate"><span class="pre">f_code</span></code> levanta um <a class="reference internal" href="../library/sys.html#auditing"><span class="std std-ref">evento de auditoria</span></a> <code class="docutils literal notranslate"><span class="pre">object.__getattr__</span></code> com argumentos <code class="docutils literal notranslate"><span class="pre">obj</span></code> e <code class="docutils literal notranslate"><span class="pre">&quot;f_code&quot;</span></code>.</p>
<p id="index-61">Atributos especiais de escrita: <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_trace</span></code>, se não <code class="docutils literal notranslate"><span class="pre">None</span></code>, é uma função chamada para vários eventos durante a execução do código (isso é usado pelo depurador). Normalmente, um evento é disparado para cada nova linha de origem – isso pode ser desabilitado configurando <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_trace_lines</span></code> para <a class="reference internal" href="../library/constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>.</p>
<p>As implementações <em>podem</em> permitir que eventos por opcode sejam solicitados definindo <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_trace_opcodes</span></code> para <a class="reference internal" href="../library/constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>. Observe que isso pode levar a um comportamento indefinido do interpretador se as exceções levantadas pela função trace escaparem à função que está sendo rastreada.</p>
<p><code class="xref py py-attr docutils literal notranslate"><span class="pre">f_lineno</span></code> é o número da linha atual do quadro – escrever nele a partir de uma função de rastreamento salta para a linha fornecida (apenas para o quadro mais abaixo). Um depurador pode implementar um comando Jump (também conhecido como Set Next Statement) escrevendo para f_lineno.</p>
<p>Objetos quadro têm suporte a um método:</p>
<dl class="py method">
<dt id="frame.clear">
<code class="sig-prename descclassname">frame.</code><code class="sig-name descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#frame.clear" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Este método limpa todas as referências a variáveis locais mantidas pelo quadro. Além disso, se o quadro pertencer a um gerador, o gerador é finalizado. Isso ajuda a quebrar os ciclos de referência que envolvem objetos quadro (por exemplo, ao capturar uma exceção e armazenar seu traceback para uso posterior).</p>
<p><a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> é levantada se o quadro estiver em execução.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.4.</span></p>
</div>
</dd></dl>

</dd>
</dl>
<dl id="traceback-objects">
<dt>Objetos traceback</dt><dd><p id="index-62">Objetos traceback representam um stack trace (situação da pilha de execução) de uma exceção. Um objeto traceback é criado implicitamente quando ocorre uma exceção e também pode ser criado explicitamente chamando <a class="reference internal" href="../library/types.html#types.TracebackType" title="types.TracebackType"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.TracebackType</span></code></a>.</p>
<p>Para tracebacks criados implicitamente, quando a busca por um manipulador de exceção desenrola a pilha de execução, em cada nível desenrolado um objeto traceback é inserido na frente do traceback atual. Quando um manipulador de exceção é inserido, o stack trace é disponibilizado para o programa. (Veja a seção <a class="reference internal" href="compound_stmts.html#try"><span class="std std-ref">The try statement</span></a>.) É acessível como o terceiro item da tupla retornada por <code class="docutils literal notranslate"><span class="pre">sys.exc_info()</span></code>, e como o atributo <code class="docutils literal notranslate"><span class="pre">__traceback__</span></code> da exceção capturada.</p>
<p>Quando o programa não contém um manipulador adequado, o stack trace é escrito (formatado de maneira adequada) no fluxo de erro padrão; se o interpretador for interativo, ele também é disponibilizado ao usuário como <code class="docutils literal notranslate"><span class="pre">sys.last_traceback</span></code>.</p>
<p>Para tracebacks criados explicitamente, cabe ao criador do traceback determinar como os atributos <code class="docutils literal notranslate"><span class="pre">tb_next</span></code> devem ser vinculados para formar um stack trace completo.</p>
<p id="index-63">Atributos especiais de somente leitura: <code class="xref py py-attr docutils literal notranslate"><span class="pre">tb_frame</span></code> aponta para o quadro de execução do nível atual; <code class="xref py py-attr docutils literal notranslate"><span class="pre">tb_lineno</span></code> fornece o número da linha onde ocorreu a exceção; <code class="xref py py-attr docutils literal notranslate"><span class="pre">tb_lasti</span></code> indica a instrução precisa. O número da linha e a última instrução no traceback podem diferir do número da linha de seu objeto quadro se a exceção ocorreu em uma instrução <a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> sem cláusula except correspondente ou com uma cláusula finally.</p>
<p>Acessar <code class="docutils literal notranslate"><span class="pre">tb_frame</span></code> levanta um <a class="reference internal" href="../library/sys.html#auditing"><span class="std std-ref">evento de auditoria</span></a> <code class="docutils literal notranslate"><span class="pre">object.__getattr__</span></code> com argumentos <code class="docutils literal notranslate"><span class="pre">obj</span></code> e <code class="docutils literal notranslate"><span class="pre">&quot;tb_frame&quot;</span></code>.</p>
<p id="index-64">Atributo especial de escrita: <code class="xref py py-attr docutils literal notranslate"><span class="pre">tb_next</span></code> é o próximo nível no stack trace (em direção ao quadro onde a exceção ocorreu), ou <code class="docutils literal notranslate"><span class="pre">None</span></code> se não houver próximo nível.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.7: </span>Os objetos traceback agora podem ser explicitamente instanciados a partir do código Python, e o atributo <code class="docutils literal notranslate"><span class="pre">tb_next</span></code> das instâncias existentes pode ser atualizado.</p>
</div>
</dd>
<dt>Objetos slice</dt><dd><p id="index-65">Slice objects are used to represent slices for
<a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>
methods.  They are also created by the built-in <a class="reference internal" href="../library/functions.html#slice" title="slice"><code class="xref py py-func docutils literal notranslate"><span class="pre">slice()</span></code></a> function.</p>
<p id="index-66">Atributos especiais de somente leitura: <code class="xref py py-attr docutils literal notranslate"><span class="pre">start</span></code> é o limite inferior; <code class="xref py py-attr docutils literal notranslate"><span class="pre">stop</span></code> é o limite superior; <code class="xref py py-attr docutils literal notranslate"><span class="pre">step</span></code> é o valor intermediário; cada um é <code class="docutils literal notranslate"><span class="pre">None</span></code> se omitido. Esses atributos podem ter qualquer tipo.</p>
<p>Objetos slice têm suporte a um método:</p>
<dl class="py method">
<dt id="slice.indices">
<code class="sig-prename descclassname">slice.</code><code class="sig-name descname">indices</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">length</span></em><span class="sig-paren">)</span><a class="headerlink" href="#slice.indices" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Este método usa um único argumento inteiro <em>length</em> e calcula informações sobre a fatia que o objeto slice descreveria se aplicado a uma sequência de itens de <em>length</em>. Ele retorna uma tupla de três inteiros; respectivamente, estes são os índices <em>start</em> e <em>stop</em> e o <em>step</em> ou comprimento de avanços da fatia. Índices ausentes ou fora dos limites são tratados de maneira consistente com fatias regulares.</p>
</dd></dl>

</dd>
<dt>Objetos método estáticos</dt><dd><p>Objetos métodos estáticos fornecem uma forma de transformar objetos função em objetos métodos descritos acima. Um objeto método estático é um invólucro em torno de qualquer outro objeto, comumente um objeto método definido pelo usuário. Quando um objeto método estático é recuperado de uma classe ou de uma instância de classe, o objeto retornado é o objeto encapsulado, do qual não está sujeito a nenhuma transformação adicional. Objetos métodos estáticos também são chamáveis. Objetos métodos estáticos são criados pelo construtor embutido <a class="reference internal" href="../library/functions.html#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">staticmethod()</span></code></a>.</p>
</dd>
<dt>Objetos métodos de classe</dt><dd><p>Um objeto método de classe, como um objeto método estático, é um invólucro em torno de outro objeto que altera a maneira como esse objeto é recuperado de classes e instâncias de classe. O comportamento dos objetos método de classe após tal recuperação é descrito acima, em “Métodos definidos pelo usuário”. Objetos método de classe são criados pelo construtor embutido <a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod()</span></code></a>.</p>
</dd>
</dl>
</dd>
</dl>
</section>
<section id="special-method-names">
<span id="specialnames"></span><h2><span class="section-number">3.3. </span>Nomes de métodos especiais<a class="headerlink" href="#special-method-names" title="Link permanente para este título">¶</a></h2>
<p id="index-67">A class can implement certain operations that are invoked by special syntax
(such as arithmetic operations or subscripting and slicing) by defining methods
with special names. This is Python’s approach to <em class="dfn">operator overloading</em>,
allowing classes to define their own behavior with respect to language
operators.  For instance, if a class defines a method named
<a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>,
and <code class="docutils literal notranslate"><span class="pre">x</span></code> is an instance of this class, then <code class="docutils literal notranslate"><span class="pre">x[i]</span></code> is roughly equivalent
to <code class="docutils literal notranslate"><span class="pre">type(x).__getitem__(x,</span> <span class="pre">i)</span></code>.  Except where mentioned, attempts to execute an
operation raise an exception when no appropriate method is defined (typically
<a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> or <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>).</p>
<p>Setting a special method to <code class="docutils literal notranslate"><span class="pre">None</span></code> indicates that the corresponding
operation is not available.  For example, if a class sets
<a class="reference internal" href="#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the class is not iterable, so calling
<a class="reference internal" href="../library/functions.html#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a> on its instances will raise a <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> (without
falling back to <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>). <a class="footnote-reference brackets" href="#id9" id="id2">2</a></p>
<p>Ao implementar uma classe que emula qualquer tipo embutido, é importante que a emulação seja implementada apenas na medida em que faça sentido para o objeto que está sendo modelado. Por exemplo, algumas sequências podem funcionar bem com a recuperação de elementos individuais, mas extrair uma fatia pode não fazer sentido. (Um exemplo disso é a interface <code class="xref py py-class docutils literal notranslate"><span class="pre">NodeList</span></code> no Document Object Model do W3C.)</p>
<section id="basic-customization">
<span id="customization"></span><h3><span class="section-number">3.3.1. </span>Personalização básica<a class="headerlink" href="#basic-customization" title="Link permanente para este título">¶</a></h3>
<dl class="py method">
<dt id="object.__new__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__new__</code><span class="sig-paren">(</span><em class="sig-param">cls</em><span class="optional">[</span>, <em class="sig-param">...</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__new__" title="Link permanente para esta definição">¶</a></dt>
<dd><p id="index-68">Chamado para criar uma nova instância da classe <em>cls</em>. <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> é um método estático (é um caso especial, então você não precisa declará-lo como tal) que recebe a classe da qual uma instância foi solicitada como seu primeiro argumento. Os argumentos restantes são aqueles passados para a expressão do construtor do objeto (a chamada para a classe). O valor de retorno de <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> deve ser a nova instância do objeto (geralmente uma instância de <em>cls</em>).</p>
<p>Implementações típicas criam uma nova instância da classe invocando o método <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> da superclasse usando <code class="docutils literal notranslate"><span class="pre">super().__new__(cls[,</span> <span class="pre">...])</span></code> com os argumentos apropriados e, em seguida, modificando a instância recém-criada conforme necessário antes de retorná-la.</p>
<p>If <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> is invoked during object construction and it returns an
instance of <em>cls</em>, then the new instance’s <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> method
will be invoked like <code class="docutils literal notranslate"><span class="pre">__init__(self[,</span> <span class="pre">...])</span></code>, where <em>self</em> is the new instance
and the remaining arguments are the same as were passed to the object constructor.</p>
<p>Se <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> não retornar uma instância de <em>cls</em>, então o método <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> da nova instância não será invocado.</p>
<p><a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> destina-se principalmente a permitir que subclasses de tipos imutáveis (como int, str ou tupla) personalizem a criação de instâncias. Também é comumente substituído em metaclasses personalizadas para personalizar a criação de classes.</p>
</dd></dl>

<dl class="py method">
<dt id="object.__init__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="optional">[</span>, <em class="sig-param">...</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__init__" title="Link permanente para esta definição">¶</a></dt>
<dd><p id="index-69">Chamado após a instância ter sido criada (por <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a>), mas antes de ser retornada ao chamador. Os argumentos são aqueles passados para a expressão do construtor da classe. Se uma classe base tem um método <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a>, o método <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> da classe derivada, se houver, deve chamá-lo explicitamente para garantir a inicialização apropriada da parte da classe base da instância; por exemplo: <code class="docutils literal notranslate"><span class="pre">super().__init__([args...])</span></code>.</p>
<p>Porque <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> e <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> trabalham juntos na construção de objetos (<a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> para criá-lo e <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> para personalizá-lo), nenhum valor diferente de <code class="docutils literal notranslate"><span class="pre">None</span></code> pode ser retornado por <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a>; fazer isso fará com que uma <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> seja levantada em tempo de execução.</p>
</dd></dl>

<dl class="py method">
<dt id="object.__del__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__del__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__del__" title="Link permanente para esta definição">¶</a></dt>
<dd><p id="index-70">Chamado quando a instância está prestes a ser destruída. Também é chamada de finalizador ou (incorretamente) de destruidor. Se uma classe base tem um método <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a>, o método <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> da classe derivada, se houver, deve chamá-lo explicitamente para garantir a exclusão adequada da parte da classe base da instância.</p>
<p>É possível (embora não recomendado!) para o método <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> adiar a destruição da instância criando uma nova referência a ela. Isso é chamado de <em>ressurreição</em> de objeto. Depende da implementação se <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> é chamado uma segunda vez quando um objeto ressuscitado está prestes a ser destruído; a implementação atual do <a class="reference internal" href="../glossary.html#term-CPython"><span class="xref std std-term">CPython</span></a> apenas o chama uma vez.</p>
<p>Não é garantido que os métodos <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> sejam chamados para objetos que ainda existam quando o interpretador sai.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p><code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">x</span></code> não chama diretamente <code class="docutils literal notranslate"><span class="pre">x.__del__()</span></code> – o primeiro diminui a contagem de referências para <code class="docutils literal notranslate"><span class="pre">x</span></code> em um, e o segundo só é chamado quando a contagem de referências de <code class="docutils literal notranslate"><span class="pre">x</span></code> atinge zero.</p>
</div>
<div class="impl-detail compound">
<p class="compound-first"><strong>CPython implementation detail:</strong> It is possible for a reference cycle to prevent the reference count
of an object from going to zero.  In this case, the cycle will be
later detected and deleted by the <a class="reference internal" href="../glossary.html#term-garbage-collection"><span class="xref std std-term">cyclic garbage collector</span></a>.  A common cause of reference cycles is when
an exception has been caught in a local variable.  The frame’s
locals then reference the exception, which references its own
traceback, which references the locals of all frames caught in the
traceback.</p>
<div class="compound-last admonition seealso">
<p class="admonition-title">Ver também</p>
<p>Documentação do módulo <a class="reference internal" href="../library/gc.html#module-gc" title="gc: Interface to the cycle-detecting garbage collector."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gc</span></code></a>.</p>
</div>
</div>
<div class="admonition warning">
<p class="admonition-title">Aviso</p>
<p>Devido às circunstâncias precárias sob as quais os métodos <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> são invocados, as exceções que ocorrem durante sua execução são ignoradas e um aviso é impresso em <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code> em seu lugar. Em particular:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> pode ser chamado quando um código arbitrário está sendo executado, incluindo de qualquer thread arbitrário. Se <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> precisar bloquear ou invocar qualquer outro recurso de bloqueio, pode ocorrer um deadlock, pois o recurso já pode ter sido levado pelo código que é interrompido para executar <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a>.</p></li>
<li><p><a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> pode ser executado durante o desligamento do interpretador. Como consequência, as variáveis globais que ele precisa acessar (incluindo outros módulos) podem já ter sido excluídas ou definidas como <code class="docutils literal notranslate"><span class="pre">None</span></code>. O Python garante que os globais cujo nome comece com um único sublinhado sejam excluídos de seu módulo antes que outros globais sejam excluídos; se nenhuma outra referência a tais globais existir, isso pode ajudar a garantir que os módulos importados ainda estejam disponíveis no momento em que o método <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> for chamado.</p></li>
</ul>
</div>
<span class="target" id="index-71"></span></dd></dl>

<dl class="py method">
<dt id="object.__repr__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__repr__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__repr__" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Chamado pela função embutida <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> para calcular a representação da string “oficial” de um objeto. Se possível, isso deve parecer uma expressão Python válida que pode ser usada para recriar um objeto com o mesmo valor (dado um ambiente apropriado). Se isso não for possível, uma string no formato <code class="docutils literal notranslate"><span class="pre">&lt;...alguma</span> <span class="pre">descrição</span> <span class="pre">útil...&gt;</span></code> deve ser retornada. O valor de retorno deve ser um objeto string. Se uma classe define <a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code></a>, mas não <a class="reference internal" href="#object.__str__" title="object.__str__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__str__()</span></code></a>, então <a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code></a> também é usado quando uma representação de string “informal” de instâncias daquela classe é necessária.</p>
<p>Isso é normalmente usado para depuração, portanto, é importante que a representação seja rica em informações e inequívoca.</p>
<span class="target" id="index-72"></span></dd></dl>

<dl class="py method">
<dt id="object.__str__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__str__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__str__" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Chamado por <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str(object)</span></code></a> e as funções embutidas <a class="reference internal" href="../library/functions.html#format" title="format"><code class="xref py py-func docutils literal notranslate"><span class="pre">format()</span></code></a> e <a class="reference internal" href="../library/functions.html#print" title="print"><code class="xref py py-func docutils literal notranslate"><span class="pre">print()</span></code></a> para calcular a representação da string “informal” ou agradável para exibição de um objeto. O valor de retorno deve ser um objeto <a class="reference internal" href="../library/stdtypes.html#textseq"><span class="std std-ref">string</span></a>.</p>
<p>Este método difere de <a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">object.__repr__()</span></code></a> por não haver expectativa de que <a class="reference internal" href="#object.__str__" title="object.__str__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__str__()</span></code></a> retorne uma expressão Python válida: uma representação mais conveniente ou concisa pode ser usada.</p>
<p>A implementação padrão definida pelo tipo embutido <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> chama <a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">object.__repr__()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="object.__bytes__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__bytes__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__bytes__" title="Link permanente para esta definição">¶</a></dt>
<dd><p id="index-73">Chamado por <a class="reference internal" href="../library/functions.html#func-bytes"><span class="std std-ref">bytes</span></a> para calcular uma representação de string de bytes de um objeto. Isso deve retornar um objeto <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>.</p>
<span class="target" id="index-74"></span></dd></dl>

<dl class="py method">
<dt id="object.__format__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__format__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">format_spec</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__format__" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Chamado pela função embutida <a class="reference internal" href="../library/functions.html#format" title="format"><code class="xref py py-func docutils literal notranslate"><span class="pre">format()</span></code></a> e, por extensão, avaliação de <a class="reference internal" href="lexical_analysis.html#f-strings"><span class="std std-ref">literais de string formatadas</span></a> e o método <a class="reference internal" href="../library/stdtypes.html#str.format" title="str.format"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.format()</span></code></a>, para produzir uma representação de string “formatada” de um objeto. O argumento <em>format_spec</em> é uma string que contém uma descrição das opções de formatação desejadas. A interpretação do argumento <em>format_spec</em> depende do tipo que implementa <a class="reference internal" href="#object.__format__" title="object.__format__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__format__()</span></code></a>, entretanto a maioria das classes delegará a formatação a um dos tipos embutidos ou usará uma sintaxe de opção de formatação semelhante.</p>
<p>Consulte <a class="reference internal" href="../library/string.html#formatspec"><span class="std std-ref">Minilinguagem de especificação de formato</span></a> para uma descrição da sintaxe de formatação padrão.</p>
<p>O valor de retorno deve ser um objeto string.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.4: </span>O método __format__ do próprio <code class="docutils literal notranslate"><span class="pre">object</span></code> levanta uma <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> se passada qualquer string não vazia.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.7: </span><code class="docutils literal notranslate"><span class="pre">object.__format__(x,</span> <span class="pre">'')</span></code> é agora equivalente a <code class="docutils literal notranslate"><span class="pre">str(x)</span></code> em vez de <code class="docutils literal notranslate"><span class="pre">format(str(x),</span> <span class="pre">'')</span></code>.</p>
</div>
</dd></dl>

<span class="target" id="richcmpfuncs"></span><dl class="py method">
<dt id="object.__lt__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__lt__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__lt__" title="Link permanente para esta definição">¶</a></dt>
<dt id="object.__le__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__le__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__le__" title="Link permanente para esta definição">¶</a></dt>
<dt id="object.__eq__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__eq__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__eq__" title="Link permanente para esta definição">¶</a></dt>
<dt id="object.__ne__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__ne__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ne__" title="Link permanente para esta definição">¶</a></dt>
<dt id="object.__gt__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__gt__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__gt__" title="Link permanente para esta definição">¶</a></dt>
<dt id="object.__ge__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__ge__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ge__" title="Link permanente para esta definição">¶</a></dt>
<dd><p id="index-75">Esses são os chamados métodos de “comparação rica”. A correspondência entre os símbolos do operador e os nomes dos métodos é a seguinte: <code class="docutils literal notranslate"><span class="pre">x&lt;y</span></code> chama <code class="docutils literal notranslate"><span class="pre">x.__lt__(y)</span></code>, <code class="docutils literal notranslate"><span class="pre">x&lt;=y</span></code> chama <code class="docutils literal notranslate"><span class="pre">x.__le__(y)</span></code>, <code class="docutils literal notranslate"><span class="pre">x==y</span></code> chama <code class="docutils literal notranslate"><span class="pre">x.__eq__(y)</span></code>, <code class="docutils literal notranslate"><span class="pre">x!=y</span></code> chama <code class="docutils literal notranslate"><span class="pre">x.__ne__(y)</span></code>, <code class="docutils literal notranslate"><span class="pre">x&gt;y</span></code> chama <code class="docutils literal notranslate"><span class="pre">x.__gt__(y)</span></code> e <code class="docutils literal notranslate"><span class="pre">x&gt;=y</span></code> chama <code class="docutils literal notranslate"><span class="pre">x.__ge__(y)</span></code>.</p>
<p>Um método de comparação rico pode retornar o singleton <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code> se não implementar a operação para um determinado par de argumentos. Por convenção, <code class="docutils literal notranslate"><span class="pre">False</span></code> e <code class="docutils literal notranslate"><span class="pre">True</span></code> são retornados para uma comparação bem-sucedida. No entanto, esses métodos podem retornar qualquer valor, portanto, se o operador de comparação for usado em um contexto booleano (por exemplo, na condição de uma instrução <code class="docutils literal notranslate"><span class="pre">if</span></code>), Python irá chamar <a class="reference internal" href="../library/functions.html#bool" title="bool"><code class="xref py py-func docutils literal notranslate"><span class="pre">bool()</span></code></a> no valor para determinar se o resultado for verdadeiro ou falso.</p>
<p>Por padrão, <code class="docutils literal notranslate"><span class="pre">object</span></code> implementa <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> usando <code class="docutils literal notranslate"><span class="pre">is</span></code>, retornando <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code> no caso de uma comparação falsa: <code class="docutils literal notranslate"><span class="pre">True</span> <span class="pre">if</span> <span class="pre">x</span> <span class="pre">is</span> <span class="pre">y</span> <span class="pre">else</span> <span class="pre">NotImplemented</span></code>. Para <a class="reference internal" href="#object.__ne__" title="object.__ne__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__ne__()</span></code></a>, por padrão ele delega para <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> e inverte o resultado a menos que seja <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code>. Não há outras relações implícitas entre os operadores de comparação ou implementações padrão; por exemplo, a verdade de <code class="docutils literal notranslate"><span class="pre">(x&lt;y</span> <span class="pre">or</span> <span class="pre">x==y)</span></code> não implica <code class="docutils literal notranslate"><span class="pre">x&lt;=y</span></code>. Para gerar operações de ordenação automaticamente a partir de uma única operação raiz, consulte <a class="reference internal" href="../library/functools.html#functools.total_ordering" title="functools.total_ordering"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.total_ordering()</span></code></a>.</p>
<p>Veja o parágrafo sobre <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> para algumas notas importantes sobre a criação de objetos <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hasheáveis</span></a> que suportam operações de comparação personalizadas e são utilizáveis como chaves de dicionário.</p>
<p>Não há versões de argumentos trocados desses métodos (a serem usados quando o argumento esquerdo não tem suporta à operação, mas o argumento direito sim); em vez disso, <a class="reference internal" href="#object.__lt__" title="object.__lt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__lt__()</span></code></a> e <a class="reference internal" href="#object.__gt__" title="object.__gt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__gt__()</span></code></a> são o reflexo um do outro, <a class="reference internal" href="#object.__le__" title="object.__le__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__le__()</span></code></a> e <a class="reference internal" href="#object.__ge__" title="object.__ge__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__ge__()</span></code></a> são o reflexo um do outro, e <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> e <a class="reference internal" href="#object.__ne__" title="object.__ne__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__ne__()</span></code></a> são seu próprio reflexo. Se os operandos são de tipos diferentes e o tipo do operando direito é uma subclasse direta ou indireta do tipo do operando esquerdo, o método refletido do operando direito tem prioridade, caso contrário, o método do operando esquerdo tem prioridade. A subclasse virtual não é considerada.</p>
</dd></dl>

<dl class="py method">
<dt id="object.__hash__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__hash__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__hash__" title="Link permanente para esta definição">¶</a></dt>
<dd><p id="index-76">Called by built-in function <a class="reference internal" href="../library/functions.html#hash" title="hash"><code class="xref py py-func docutils literal notranslate"><span class="pre">hash()</span></code></a> and for operations on members of
hashed collections including <a class="reference internal" href="../library/stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a>, and
<a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>.  The <code class="docutils literal notranslate"><span class="pre">__hash__()</span></code> method should return an integer. The only required
property is that objects which compare equal have the same hash value; it is
advised to mix together the hash values of the components of the object that
also play a part in comparison of objects by packing them into a tuple and
hashing the tuple. Example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nick</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">color</span><span class="p">))</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p><a class="reference internal" href="../library/functions.html#hash" title="hash"><code class="xref py py-func docutils literal notranslate"><span class="pre">hash()</span></code></a> trunca o valor retornado do método <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> personalizado de um objeto para o tamanho de um <a class="reference internal" href="../c-api/intro.html#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a>. Isso é normalmente 8 bytes em compilações de 64 bits e 4 bytes em compilações de 32 bits. Se o <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> de um objeto deve interoperar em compilações de tamanhos de bits diferentes, certifique-se de verificar a largura em todas as compilações suportadas. Uma maneira fácil de fazer isso é com <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">-c</span> <span class="pre">&quot;import</span> <span class="pre">sys;</span> <span class="pre">print(sys.hash_info.width)&quot;</span></code>.</p>
</div>
<p>Se uma classe não define um método <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a>, ela também não deve definir uma operação <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a>; se define <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> mas não <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a>, suas instâncias não serão utilizáveis como itens em coleções hasheáveis. Se uma classe define objetos mutáveis e implementa um método <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a>, ela não deve implementar <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a>, uma vez que a implementação de coleções hasheáveis requer que o valor hash de uma chave seja imutável (se o valor hash do objeto mudar, estará no balde de hash errado).</p>
<p>As classes definidas pelo usuário têm os métodos <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> e <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> por padrão; com eles, todos os objetos se comparam desiguais (exceto com eles mesmos) e <code class="docutils literal notranslate"><span class="pre">x.__hash__()</span></code> retorna um valor apropriado tal que <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code> implica que <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">y</span></code> e <code class="docutils literal notranslate"><span class="pre">hash(x)</span> <span class="pre">==</span> <span class="pre">hash(y)</span></code>.</p>
<p>Uma classe que sobrescreve <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> e não define <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> terá seu <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> implicitamente definido como <code class="docutils literal notranslate"><span class="pre">None</span></code>. Quando o método <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> de uma classe é <code class="docutils literal notranslate"><span class="pre">None</span></code>, as instâncias da classe levantam uma <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> apropriada quando um programa tenta recuperar seu valor hash, e também será identificado corretamente como inalterável ao verificar <code class="docutils literal notranslate"><span class="pre">isinstance(obj,</span> <span class="pre">collections.abc.Hashable)</span></code>.</p>
<p>Se uma classe que sobrescreve <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> precisa manter a implementação de <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> de uma classe pai, o interpretador deve ser informado disso explicitamente pela configuração <code class="docutils literal notranslate"><span class="pre">__hash__</span> <span class="pre">=</span> <span class="pre">&lt;ClassePai&gt;.__hash__</span></code>.</p>
<p>Se uma classe que não substitui <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> deseja suprimir o suporte a hash, deve incluir <code class="docutils literal notranslate"><span class="pre">__hash__</span> <span class="pre">=</span> <span class="pre">None</span></code> na definição de classe. Uma classe que define seu próprio <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> que levanta explicitamente uma <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> seria incorretamente identificada como hasheável por uma chamada <code class="docutils literal notranslate"><span class="pre">isinstance(obj,</span> <span class="pre">collections.abc.Hashable)</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Por padrão, os valores <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> dos objetos str e bytes são “salgados” com um valor aleatório imprevisível. Embora permaneçam constantes em um processo individual do Python, eles não são previsíveis entre invocações repetidas do Python.</p>
<p>This is intended to provide protection against a denial-of-service caused
by carefully-chosen inputs that exploit the worst case performance of a
dict insertion, O(n<sup>2</sup>) complexity.  See
<a class="reference external" href="http://www.ocert.org/advisories/ocert-2011-003.html">http://www.ocert.org/advisories/ocert-2011-003.html</a> for details.</p>
<p>Alterar os valores de hash afeta a ordem de iteração dos conjuntos. Python nunca deu garantias sobre essa ordem (e normalmente varia entre compilações de 32 e 64 bits).</p>
<p>Consulte também <span class="target" id="index-117"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONHASHSEED"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONHASHSEED</span></code></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.3: </span>Aleatorização de hash está habilitada por padrão.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="object.__bool__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__bool__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__bool__" title="Link permanente para esta definição">¶</a></dt>
<dd><p id="index-78">Chamado para implementar o teste de valor de verdade e a operação embutida <code class="docutils literal notranslate"><span class="pre">bool()</span></code>; deve retornar <code class="docutils literal notranslate"><span class="pre">False</span></code> ou <code class="docutils literal notranslate"><span class="pre">True</span></code>. Quando este método não é definido, <a class="reference internal" href="#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code></a> é chamado, se estiver definido, e o objeto é considerado verdadeiro se seu resultado for diferente de zero. Se uma classe não define <a class="reference internal" href="#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code></a> nem <a class="reference internal" href="#object.__bool__" title="object.__bool__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__bool__()</span></code></a>, todas as suas instâncias são consideradas verdadeiras.</p>
</dd></dl>

</section>
<section id="customizing-attribute-access">
<span id="attribute-access"></span><h3><span class="section-number">3.3.2. </span>Personalizando o acesso aos atributos<a class="headerlink" href="#customizing-attribute-access" title="Link permanente para este título">¶</a></h3>
<p>Os seguintes métodos podem ser definidos para personalizar o significado do acesso aos atributos (uso, atribuição ou exclusão de <code class="docutils literal notranslate"><span class="pre">x.name</span></code>) para instâncias de classe.</p>
<dl class="py method">
<dt id="object.__getattr__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__getattr__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__getattr__" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Chamado quando o acesso padrão ao atributos falha com um <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> (ou <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> levanta uma <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> porque <em>name</em> não é um atributo de instância ou um atributo na árvore de classes para <code class="docutils literal notranslate"><span class="pre">self</span></code>; ou <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a> de uma propriedade <em>name</em> levanta <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>). Este método deve retornar o valor do atributo (calculado) ou levantar uma exceção <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>.</p>
<p>Observe que se o atributo for encontrado através do mecanismo normal, <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> não é chamado. (Esta é uma assimetria intencional entre <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> e <a class="reference internal" href="#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a>.) Isso é feito tanto por razões de eficiência quanto porque <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> não teria como acessar outros atributos da instância. Observe que pelo menos para variáveis de instâncias, você pode fingir controle total não inserindo nenhum valor no dicionário de atributos de instância (mas, em vez disso, inserindo-os em outro objeto). Veja o método <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> abaixo para uma maneira de realmente obter controle total sobre o acesso ao atributo.</p>
</dd></dl>

<dl class="py method">
<dt id="object.__getattribute__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__getattribute__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__getattribute__" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Chamado incondicionalmente para implementar acessos a atributo para instâncias da classe. Se a classe também define <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a>, o último não será chamado a menos que <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> o chame explicitamente ou levante um <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>. Este método deve retornar o valor do atributo (calculado) ou levantar uma exceção <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>. Para evitar recursão infinita neste método, sua implementação deve sempre chamar o método da classe base com o mesmo nome para acessar quaisquer atributos de que necessita, por exemplo, <code class="docutils literal notranslate"><span class="pre">object.__getattribute__(self,</span> <span class="pre">name)</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Este método ainda pode ser ignorado ao procurar métodos especiais como resultado de invocação implícita por meio da sintaxe da linguagem ou funções embutidas. Consulte <a class="reference internal" href="#special-lookup"><span class="std std-ref">Pesquisa de método especial</span></a>.</p>
</div>
<p class="audit-hook">Levanta um <a class="reference internal" href="../library/sys.html#auditing"><span class="std std-ref">evento de auditoria</span></a> <code class="docutils literal notranslate"><span class="pre">object.__getattr__</span></code> com argumentos <code class="docutils literal notranslate"><span class="pre">obj</span></code>, <code class="docutils literal notranslate"><span class="pre">name</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="object.__setattr__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__setattr__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">value</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__setattr__" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Chamado quando uma atribuição de atributo é tentada. Isso é chamado em vez do mecanismo normal (ou seja, armazena o valor no dicionário da instância). <em>name</em> é o nome do atributo, <em>value</em> é o valor a ser atribuído a ele.</p>
<p>Se <a class="reference internal" href="#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a> deseja atribuir a um atributo de instância, ele deve chamar o método da classe base com o mesmo nome, por exemplo, <code class="docutils literal notranslate"><span class="pre">object.__setattr__(self,</span> <span class="pre">name,</span> <span class="pre">value)</span></code>.</p>
<p class="audit-hook">Levanta um <a class="reference internal" href="../library/sys.html#auditing"><span class="std std-ref">evento de auditoria</span></a> <code class="docutils literal notranslate"><span class="pre">object.__setattr__</span></code> com argumentos <code class="docutils literal notranslate"><span class="pre">obj</span></code>, <code class="docutils literal notranslate"><span class="pre">name</span></code>, <code class="docutils literal notranslate"><span class="pre">value</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="object.__delattr__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__delattr__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__delattr__" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Como <a class="reference internal" href="#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a>, mas para exclusão de atributo em vez de atribuição. Isso só deve ser implementado se <code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">obj.name</span></code> for significativo para o objeto.</p>
<p class="audit-hook">Levanta um <a class="reference internal" href="../library/sys.html#auditing"><span class="std std-ref">evento de auditoria</span></a> <code class="docutils literal notranslate"><span class="pre">object.__delattr__</span></code> com argumentos <code class="docutils literal notranslate"><span class="pre">obj</span></code>, <code class="docutils literal notranslate"><span class="pre">name</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="object.__dir__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__dir__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__dir__" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Chamado quando <a class="reference internal" href="../library/functions.html#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a> é chamado no objeto. Uma sequência deve ser retornada. <a class="reference internal" href="../library/functions.html#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a> converte a sequência retornada em uma lista e a ordena.</p>
</dd></dl>

<section id="customizing-module-attribute-access">
<h4><span class="section-number">3.3.2.1. </span>Personalizando acesso a atributos de módulos<a class="headerlink" href="#customizing-module-attribute-access" title="Link permanente para este título">¶</a></h4>
<p id="index-79">Os nomes especiais <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> e <code class="docutils literal notranslate"><span class="pre">__dir__</span></code> também podem ser usados para personalizar o acesso aos atributos dos módulos. A função <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> no nível do módulo deve aceitar um argumento que é o nome de um atributo e retornar o valor calculado ou levantar um <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>. Se um atributo não for encontrado em um objeto de módulo por meio da pesquisa normal, por exemplo <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">object.__getattribute__()</span></code></a>, então <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> é pesquisado no módulo <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> antes de levantar um <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> . Se encontrado, ele é chamado com o nome do atributo e o resultado é retornado.</p>
<p>A função <code class="docutils literal notranslate"><span class="pre">__dir__</span></code> não deve aceitar nenhum argumento e retornar uma sequência de strings que representa os nomes acessíveis no módulo. Se presente, esta função substitui a pesquisa padrão <a class="reference internal" href="../library/functions.html#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a> em um módulo.</p>
<p>Para uma personalização mais refinada do comportamento do módulo (definição de atributos, propriedades etc.), pode-se definir o atributo <code class="docutils literal notranslate"><span class="pre">__class__</span></code> de um objeto de módulo para uma subclasse de <a class="reference internal" href="../library/types.html#types.ModuleType" title="types.ModuleType"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.ModuleType</span></code></a>. Por exemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">types</span> <span class="kn">import</span> <span class="n">ModuleType</span>

<span class="k">class</span> <span class="nc">VerboseModule</span><span class="p">(</span><span class="n">ModuleType</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;Verbose </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">&#39;</span>

    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Setting </span><span class="si">{</span><span class="n">attr</span><span class="si">}</span><span class="s1">...&#39;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

<span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="vm">__name__</span><span class="p">]</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">=</span> <span class="n">VerboseModule</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Definir o módulo <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> e configurar o módulo <code class="docutils literal notranslate"><span class="pre">__class__</span></code> só afeta as pesquisas feitas usando a sintaxe de acesso ao atributo – acessar diretamente os globais do módulo (seja por código dentro do módulo, ou por meio de uma referência ao dicionário global do módulo) é não afetado.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.5: </span>O atributo de módulo <code class="docutils literal notranslate"><span class="pre">__class__</span></code> pode agora ser escrito.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.7: </span>Atributos de módulo <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> e <code class="docutils literal notranslate"><span class="pre">__dir__</span></code>.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver também</p>
<dl class="simple">
<dt><span class="target" id="index-118"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0562"><strong>PEP 562</strong></a> - __getattr__ e __dir__ de módulo</dt><dd><p>Descreve as funções <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> e <code class="docutils literal notranslate"><span class="pre">__dir__</span></code> nos módulos.</p>
</dd>
</dl>
</div>
</section>
<section id="implementing-descriptors">
<span id="descriptors"></span><h4><span class="section-number">3.3.2.2. </span>Implementando descritores<a class="headerlink" href="#implementing-descriptors" title="Link permanente para este título">¶</a></h4>
<p>Os métodos a seguir se aplicam apenas quando uma instância da classe que contém o método (uma classe chamada <em>descritora</em>) aparece em uma classe proprietária <em>owner</em> (o descritor deve estar no dicionário de classe do proprietário ou no dicionário de classe para um dos seus pais). Nos exemplos abaixo, “o atributo” refere-se ao atributo cujo nome é a chave da propriedade no <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> da classe proprietária.</p>
<dl class="py method">
<dt id="object.__get__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__get__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">instance</span></em>, <em class="sig-param"><span class="n">owner</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__get__" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Chamado para obter o atributo da classe proprietária (acesso ao atributo da classe) ou de uma instância dessa classe (acesso ao atributo da instância). O argumento opcional <em>owner</em> é a classe proprietária, enquanto <em>instance</em> é a instância pela qual o atributo foi acessado, ou <code class="docutils literal notranslate"><span class="pre">None</span></code> quando o atributo é acessado por meio de <em>owner</em>.</p>
<p>Este método deve retornar o valor do atributo calculado ou levantar uma exceção <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>.</p>
<p><span class="target" id="index-119"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0252"><strong>PEP 252</strong></a> especifica que <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a> é um chamável com um ou dois argumentos. Os próprios descritores embutidos do Python suportam esta especificação; no entanto, é provável que algumas ferramentas de terceiros tenham descritores que requerem ambos os argumentos. A implementação de <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> do próprio Python sempre passa em ambos os argumentos sejam eles requeridos ou não.</p>
</dd></dl>

<dl class="py method">
<dt id="object.__set__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__set__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">instance</span></em>, <em class="sig-param"><span class="n">value</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__set__" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Chamado para definir o atributo em uma instância <em>instance</em> da classe proprietária para um novo valor, <em>value</em>.</p>
<p>Observe que adicionar <a class="reference internal" href="#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code></a> ou <a class="reference internal" href="#object.__delete__" title="object.__delete__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delete__()</span></code></a> altera o tipo de descritor para um “descritor de dados”. Consulte <a class="reference internal" href="#descriptor-invocation"><span class="std std-ref">Invocando descritores</span></a> para mais detalhes.</p>
</dd></dl>

<dl class="py method">
<dt id="object.__delete__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__delete__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">instance</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__delete__" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Chamado para excluir o atributo em uma instância <em>instance</em> da classe proprietária.</p>
</dd></dl>

<p>O atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">__objclass__</span></code> é interpretado pelo módulo <a class="reference internal" href="../library/inspect.html#module-inspect" title="inspect: Extract information and source code from live objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">inspect</span></code></a> como especificando a classe onde este objeto foi definido (configurar isso apropriadamente pode ajudar na introspecção em tempo de execução dos atributos dinâmicos da classe). Para chamáveis, pode indicar que uma instância do tipo fornecido (ou uma subclasse) é esperada ou necessária como o primeiro argumento posicional (por exemplo, CPython define este atributo para métodos não acoplados que são implementados em C).</p>
</section>
<section id="invoking-descriptors">
<span id="descriptor-invocation"></span><h4><span class="section-number">3.3.2.3. </span>Invocando descritores<a class="headerlink" href="#invoking-descriptors" title="Link permanente para este título">¶</a></h4>
<p>In general, a descriptor is an object attribute with “binding behavior”, one
whose attribute access has been overridden by methods in the descriptor
protocol:  <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a>, <a class="reference internal" href="#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code></a>, and
<a class="reference internal" href="#object.__delete__" title="object.__delete__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delete__()</span></code></a>. If any of
those methods are defined for an object, it is said to be a descriptor.</p>
<p>O comportamento padrão para acesso ao atributo é obter, definir ou excluir o atributo do dicionário de um objeto. Por exemplo, <code class="docutils literal notranslate"><span class="pre">a.x</span></code> tem uma cadeia de pesquisa começando com <code class="docutils literal notranslate"><span class="pre">a.__dict__['x']</span></code>, então <code class="docutils literal notranslate"><span class="pre">type(a).__dict__['x']</span></code>, e contando pelas classes base de <code class="docutils literal notranslate"><span class="pre">type(a)</span></code> excluindo metaclasses.</p>
<p>No entanto, se o valor pesquisado for um objeto que define um dos métodos do descritor, o Python pode substituir o comportamento padrão e invocar o método do descritor. Onde isso ocorre na cadeia de precedência depende de quais métodos descritores foram definidos e como eles foram chamados.</p>
<p>O ponto de partida para a invocação do descritor é uma ligação, <code class="docutils literal notranslate"><span class="pre">a.x</span></code>. Como os argumentos são montados depende de <code class="docutils literal notranslate"><span class="pre">a</span></code>:</p>
<dl class="simple">
<dt>Chamada direta</dt><dd><p>A chamada mais simples e menos comum é quando o código do usuário invoca diretamente um método descritor: <code class="docutils literal notranslate"><span class="pre">x.__get__(a)</span></code>.</p>
</dd>
<dt>Ligação de instâncias</dt><dd><p>Se estiver ligando a uma instância de objeto, <code class="docutils literal notranslate"><span class="pre">a.x</span></code> é transformado na chamada: <code class="docutils literal notranslate"><span class="pre">type(a).__dict__['x'].__get__(a,</span> <span class="pre">type(a))</span></code>.</p>
</dd>
<dt>Ligação de classes</dt><dd><p>Se estiver ligando a uma classe, <code class="docutils literal notranslate"><span class="pre">A.x</span></code> é transformado na chamada: <code class="docutils literal notranslate"><span class="pre">A.__dict__['x'].__get__(None,</span> <span class="pre">A)</span></code>.</p>
</dd>
<dt>Ligação de super</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">a</span></code> is an instance of <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-class docutils literal notranslate"><span class="pre">super</span></code></a>, then the binding <code class="docutils literal notranslate"><span class="pre">super(B,</span> <span class="pre">obj).m()</span></code>
searches <code class="docutils literal notranslate"><span class="pre">obj.__class__.__mro__</span></code> for the base class <code class="docutils literal notranslate"><span class="pre">A</span></code>
immediately following <code class="docutils literal notranslate"><span class="pre">B</span></code> and then invokes the descriptor with the call:
<code class="docutils literal notranslate"><span class="pre">A.__dict__['m'].__get__(obj,</span> <span class="pre">obj.__class__)</span></code>.</p>
</dd>
</dl>
<p>For instance bindings, the precedence of descriptor invocation depends on
which descriptor methods are defined.  A descriptor can define any combination
of <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a>, <a class="reference internal" href="#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code></a> and
<a class="reference internal" href="#object.__delete__" title="object.__delete__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delete__()</span></code></a>.  If it does not
define <code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code>, then accessing the attribute will return the descriptor
object itself unless there is a value in the object’s instance dictionary.  If
the descriptor defines <code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code> and/or <code class="xref py py-meth docutils literal notranslate"><span class="pre">__delete__()</span></code>, it is a data
descriptor; if it defines neither, it is a non-data descriptor.  Normally, data
descriptors define both <code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code>, while non-data
descriptors have just the <code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code> method.  Data descriptors with
<code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code> (and/or <code class="xref py py-meth docutils literal notranslate"><span class="pre">__delete__()</span></code>) defined always override a redefinition in an
instance dictionary.  In contrast, non-data descriptors can be overridden by
instances.</p>
<p>Python methods (including those decorated with
<a class="reference internal" href="../library/functions.html#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;staticmethod</span></code></a> and <a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;classmethod</span></code></a>) are
implemented as non-data descriptors.  Accordingly, instances can redefine and
override methods.  This allows individual instances to acquire behaviors that
differ from other instances of the same class.</p>
<p>A função <a class="reference internal" href="../library/functions.html#property" title="property"><code class="xref py py-func docutils literal notranslate"><span class="pre">property()</span></code></a> é implementada como um descritor de dados. Da mesma forma, as instâncias não podem substituir o comportamento de uma propriedade.</p>
</section>
<section id="slots">
<span id="id3"></span><h4><span class="section-number">3.3.2.4. </span>__slots__<a class="headerlink" href="#slots" title="Link permanente para este título">¶</a></h4>
<p><em>__slots__</em> allow us to explicitly declare data members (like
properties) and deny the creation of <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> and <em>__weakref__</em>
(unless explicitly declared in <em>__slots__</em> or available in a parent.)</p>
<p>The space saved over using <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> can be significant.
Attribute lookup speed can be significantly improved as well.</p>
<dl class="py data">
<dt id="object.__slots__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__slots__</code><a class="headerlink" href="#object.__slots__" title="Link permanente para esta definição">¶</a></dt>
<dd><p>This class variable can be assigned a string, iterable, or sequence of
strings with variable names used by instances.  <em>__slots__</em> reserves space
for the declared variables and prevents the automatic creation of
<a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a>
and <em>__weakref__</em> for each instance.</p>
</dd></dl>

<section id="notes-on-using-slots">
<h5><span class="section-number">3.3.2.4.1. </span>Observações ao uso de <em>__slots__</em><a class="headerlink" href="#notes-on-using-slots" title="Link permanente para este título">¶</a></h5>
<ul class="simple">
<li><p>When inheriting from a class without <em>__slots__</em>, the
<a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> and
<em>__weakref__</em> attribute of the instances will always be accessible.</p></li>
<li><p>Without a <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> variable, instances cannot be assigned new
variables not
listed in the <em>__slots__</em> definition.  Attempts to assign to an unlisted
variable name raises <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>. If dynamic assignment of new
variables is desired, then add <code class="docutils literal notranslate"><span class="pre">'__dict__'</span></code> to the sequence of strings in
the <em>__slots__</em> declaration.</p></li>
<li><p>Without a <em>__weakref__</em> variable for each instance, classes defining
<em>__slots__</em> do not support <a class="reference internal" href="../library/weakref.html#module-weakref" title="weakref: Support for weak references and weak dictionaries."><code class="xref py py-mod docutils literal notranslate"><span class="pre">weak</span> <span class="pre">references</span></code></a> to its instances.
If weak reference
support is needed, then add <code class="docutils literal notranslate"><span class="pre">'__weakref__'</span></code> to the sequence of strings in the
<em>__slots__</em> declaration.</p></li>
<li><p><em>__slots__</em> are implemented at the class level by creating <a class="reference internal" href="#descriptors"><span class="std std-ref">descriptors</span></a>
for each variable name.  As a result, class attributes
cannot be used to set default values for instance variables defined by
<em>__slots__</em>; otherwise, the class attribute would overwrite the descriptor
assignment.</p></li>
<li><p>The action of a <em>__slots__</em> declaration is not limited to the class
where it is defined.  <em>__slots__</em> declared in parents are available in
child classes. However, child subclasses will get a <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> and
<em>__weakref__</em> unless they also define <em>__slots__</em> (which should only
contain names of any <em>additional</em> slots).</p></li>
<li><p>Se uma classe define um slot também definido em uma classe base, a variável de instância definida pelo slot da classe base fica inacessível (exceto por recuperar seu descritor diretamente da classe base). Isso torna o significado do programa indefinido. No futuro, uma verificação pode ser adicionada para evitar isso.</p></li>
<li><p>Não vazio <em>__slots__</em> não funciona para classes derivadas de tipos embutidos de “comprimento variável”, como <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> e <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>.</p></li>
<li><p>Any non-string <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">iterable</span></a> may be assigned to <em>__slots__</em>.</p></li>
<li><p>If a <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dictionary</span></code></a> is used to assign <em>__slots__</em>, the dictionary
keys will be used as the slot names. The values of the dictionary can be used
to provide per-attribute docstrings that will be recognised by
<a class="reference internal" href="../library/inspect.html#inspect.getdoc" title="inspect.getdoc"><code class="xref py py-func docutils literal notranslate"><span class="pre">inspect.getdoc()</span></code></a> and displayed in the output of <a class="reference internal" href="../library/functions.html#help" title="help"><code class="xref py py-func docutils literal notranslate"><span class="pre">help()</span></code></a>.</p></li>
<li><p><a class="reference internal" href="../library/stdtypes.html#instance.__class__" title="instance.__class__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__class__</span></code></a> assignment works only if both classes have the
same <em>__slots__</em>.</p></li>
<li><p><a class="reference internal" href="../tutorial/classes.html#tut-multiple"><span class="std std-ref">Multiple inheritance</span></a> with multiple slotted parent
classes can be used,
but only one parent is allowed to have attributes created by slots
(the other bases must have empty slot layouts) - violations raise
<a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>.</p></li>
<li><p>If an <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a> is used for <em>__slots__</em> then a <a class="reference internal" href="../glossary.html#term-descriptor"><span class="xref std std-term">descriptor</span></a> is
created for each
of the iterator’s values. However, the <em>__slots__</em> attribute will be an empty
iterator.</p></li>
</ul>
</section>
</section>
</section>
<section id="customizing-class-creation">
<span id="class-customization"></span><h3><span class="section-number">3.3.3. </span>Personalizando a criação de classe<a class="headerlink" href="#customizing-class-creation" title="Link permanente para este título">¶</a></h3>
<p>Whenever a class inherits from another class, <a class="reference internal" href="#object.__init_subclass__" title="object.__init_subclass__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init_subclass__()</span></code></a> is
called on the parent class. This way, it is possible to write classes which
change the behavior of subclasses. This is closely related to class
decorators, but where class decorators only affect the specific class they’re
applied to, <code class="docutils literal notranslate"><span class="pre">__init_subclass__</span></code> solely applies to future subclasses of the
class defining the method.</p>
<dl class="py method">
<dt id="object.__init_subclass__">
<em class="property">classmethod </em><code class="sig-prename descclassname">object.</code><code class="sig-name descname">__init_subclass__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cls</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__init_subclass__" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Este método é chamado sempre que a classe que contém é uma subclasse. <em>cls</em> é então a nova subclasse. Se definido como um método de instância normal, esse método é convertido implicitamente em um método de classe.</p>
<p>Argumentos nomeados dados a uma nova classe são passados para a classe pai <code class="docutils literal notranslate"><span class="pre">__init_subclass__</span></code>. Para compatibilidade com outras classes usando <code class="docutils literal notranslate"><span class="pre">__init_subclass__</span></code>, deve-se retirar os argumentos nomeados necessários e passar os outros para a classe base, como em:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Philosopher</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init_subclass__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">default_name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init_subclass__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">default_name</span> <span class="o">=</span> <span class="n">default_name</span>

<span class="k">class</span> <span class="nc">AustralianPhilosopher</span><span class="p">(</span><span class="n">Philosopher</span><span class="p">,</span> <span class="n">default_name</span><span class="o">=</span><span class="s2">&quot;Bruce&quot;</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>A implementação padrão <code class="docutils literal notranslate"><span class="pre">object.__init_subclass__</span></code> não faz nada, mas levanta um erro se for chamada com quaisquer argumentos.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>A dica da metaclasse <code class="docutils literal notranslate"><span class="pre">metaclass</span></code> é consumida pelo resto da maquinaria de tipo, e nunca é passada para implementações <code class="docutils literal notranslate"><span class="pre">__init_subclass__</span></code>. A metaclasse real (em vez da dica explícita) pode ser acessada como <code class="docutils literal notranslate"><span class="pre">type(cls)</span></code>.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.6.</span></p>
</div>
</dd></dl>

<p>When a class is created, <code class="xref py py-meth docutils literal notranslate"><span class="pre">type.__new__()</span></code> scans the class variables
and makes callbacks to those with a <a class="reference internal" href="#object.__set_name__" title="object.__set_name__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set_name__()</span></code></a> hook.</p>
<dl class="py method">
<dt id="object.__set_name__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__set_name__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">owner</span></em>, <em class="sig-param"><span class="n">name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__set_name__" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Automatically called at the time the owning class <em>owner</em> is
created. The object has been assigned to <em>name</em> in that class:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>  <span class="c1"># Automatically calls: x.__set_name__(A, &#39;x&#39;)</span>
</pre></div>
</div>
<p>If the class variable is assigned after the class is created,
<a class="reference internal" href="#object.__set_name__" title="object.__set_name__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set_name__()</span></code></a> will not be called automatically.
If needed, <a class="reference internal" href="#object.__set_name__" title="object.__set_name__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set_name__()</span></code></a> can be called directly:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
   <span class="k">pass</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="n">A</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">c</span>                  <span class="c1"># The hook is not called</span>
<span class="n">c</span><span class="o">.</span><span class="n">__set_name__</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span>   <span class="c1"># Manually invoke the hook</span>
</pre></div>
</div>
<p>Consulte <a class="reference internal" href="#class-object-creation"><span class="std std-ref">Criando o objeto da classe</span></a> para mais detalhes.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.6.</span></p>
</div>
</dd></dl>

<section id="metaclasses">
<span id="id4"></span><h4><span class="section-number">3.3.3.1. </span>Metaclasses<a class="headerlink" href="#metaclasses" title="Link permanente para este título">¶</a></h4>
<p id="index-82">Por padrão, as classes são construídas usando <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a>. O corpo da classe é executado em um novo espaço de nomes e o nome da classe é vinculado localmente ao resultado de <code class="docutils literal notranslate"><span class="pre">type(name,</span> <span class="pre">bases,</span> <span class="pre">namespace)</span></code>.</p>
<p>O processo de criação da classe pode ser personalizado passando o argumento nomeado <code class="docutils literal notranslate"><span class="pre">metaclass</span></code> na linha de definição da classe, ou herdando de uma classe existente que incluiu tal argumento. No exemplo a seguir, <code class="docutils literal notranslate"><span class="pre">MyClass</span></code> e <code class="docutils literal notranslate"><span class="pre">MySubclass</span></code> são instâncias de <code class="docutils literal notranslate"><span class="pre">Meta</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Meta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">MyClass</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">Meta</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">MySubclass</span><span class="p">(</span><span class="n">MyClass</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>Quaisquer outros argumentos nomeados especificados na definição de classe são transmitidos para todas as operações de metaclasse descritas abaixo.</p>
<p>Quando uma definição de classe é executada, as seguintes etapas ocorrem:</p>
<ul class="simple">
<li><p>Entradas de MRO são resolvidas;</p></li>
<li><p>a metaclasse apropriada é determinada;</p></li>
<li><p>o espaço de nomes da classe é preparada;</p></li>
<li><p>o corpo da classe é executado;</p></li>
<li><p>o objeto da classe é criado.</p></li>
</ul>
</section>
<section id="resolving-mro-entries">
<h4><span class="section-number">3.3.3.2. </span>Resolvendo entradas de MRO<a class="headerlink" href="#resolving-mro-entries" title="Link permanente para este título">¶</a></h4>
<p>Se uma base que aparece na definição de classe não é uma instância de <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a>, então um método <code class="docutils literal notranslate"><span class="pre">__mro_entries__</span></code> é pesquisado nela. Se encontrado, ele é chamado com a tupla de base original. Este método deve retornar uma tupla de classes que serão usadas no lugar desta base. A tupla pode estar vazia, neste caso a base original é ignorada.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver também</p>
<p><span class="target" id="index-120"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0560"><strong>PEP 560</strong></a> - Suporte básico para inserir módulo e tipos genéricos</p>
</div>
</section>
<section id="determining-the-appropriate-metaclass">
<h4><span class="section-number">3.3.3.3. </span>Determinando a metaclasse apropriada<a class="headerlink" href="#determining-the-appropriate-metaclass" title="Link permanente para este título">¶</a></h4>
<p id="index-84">A metaclasse apropriada para uma definição de classe é determinada da seguinte forma:</p>
<ul class="simple">
<li><p>se nenhuma base e nenhuma metaclasse explícita forem fornecidas, então <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a> é usada;</p></li>
<li><p>se uma metaclasse explícita é fornecida e <em>não</em> é uma instância de <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a>, então ela é usada diretamente como a metaclasse;</p></li>
<li><p>se uma instância de <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a> é fornecida como a metaclasse explícita, ou bases são definidas, então a metaclasse mais derivada é usada.</p></li>
</ul>
<p>A metaclasse mais derivada é selecionada a partir da metaclasse explicitamente especificada (se houver) e das metaclasses (ou seja, <code class="docutils literal notranslate"><span class="pre">type(cls)</span></code>) de todas as classes básicas especificadas. A metaclasse mais derivada é aquela que é um subtipo de <em>todas</em> essas metaclasses candidatas. Se nenhuma das metaclasses candidatas atender a esse critério, a definição de classe falhará com <code class="docutils literal notranslate"><span class="pre">TypeError</span></code>.</p>
</section>
<section id="preparing-the-class-namespace">
<span id="prepare"></span><h4><span class="section-number">3.3.3.4. </span>Preparando o espaço de nomes da classe<a class="headerlink" href="#preparing-the-class-namespace" title="Link permanente para este título">¶</a></h4>
<p id="index-85">Once the appropriate metaclass has been identified, then the class namespace
is prepared. If the metaclass has a <code class="docutils literal notranslate"><span class="pre">__prepare__</span></code> attribute, it is called
as <code class="docutils literal notranslate"><span class="pre">namespace</span> <span class="pre">=</span> <span class="pre">metaclass.__prepare__(name,</span> <span class="pre">bases,</span> <span class="pre">**kwds)</span></code> (where the
additional keyword arguments, if any, come from the class definition). The
<code class="docutils literal notranslate"><span class="pre">__prepare__</span></code> method should be implemented as a
<a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod</span></code></a>. The
namespace returned by <code class="docutils literal notranslate"><span class="pre">__prepare__</span></code> is passed in to <code class="docutils literal notranslate"><span class="pre">__new__</span></code>, but when
the final class object is created the namespace is copied into a new <code class="docutils literal notranslate"><span class="pre">dict</span></code>.</p>
<p>Se a metaclasse não tiver o atributo <code class="docutils literal notranslate"><span class="pre">__prepare__</span></code>, então o espaço de nomes da classe é inicializado como um mapeamento ordenado vazio.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver também</p>
<dl class="simple">
<dt><span class="target" id="index-121"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3115"><strong>PEP 3115</strong></a> - Metaclasses no Python 3000</dt><dd><p>Introduzido o gancho de espaço de nomes <code class="docutils literal notranslate"><span class="pre">__prepare__</span></code></p>
</dd>
</dl>
</div>
</section>
<section id="executing-the-class-body">
<h4><span class="section-number">3.3.3.5. </span>Executando o corpo da classe<a class="headerlink" href="#executing-the-class-body" title="Link permanente para este título">¶</a></h4>
<p id="index-87">O corpo da classe é executado (aproximadamente) como <code class="docutils literal notranslate"><span class="pre">exec(body,</span> <span class="pre">globals(),</span> <span class="pre">namespace)</span></code>. A principal diferença de uma chamada normal para <a class="reference internal" href="../library/functions.html#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> é que o escopo léxico permite que o corpo da classe (incluindo quaisquer métodos) faça referência a nomes dos escopos atual e externo quando a definição de classe ocorre dentro de uma função.</p>
<p>No entanto, mesmo quando a definição de classe ocorre dentro da função, os métodos definidos dentro da classe ainda não podem ver os nomes definidos no escopo da classe. Variáveis de classe devem ser acessadas através do primeiro parâmetro de instância ou métodos de classe, ou através da referência implícita com escopo léxico <code class="docutils literal notranslate"><span class="pre">__class__</span></code> descrita na próxima seção.</p>
</section>
<section id="creating-the-class-object">
<span id="class-object-creation"></span><h4><span class="section-number">3.3.3.6. </span>Criando o objeto da classe<a class="headerlink" href="#creating-the-class-object" title="Link permanente para este título">¶</a></h4>
<p id="index-88">Uma vez que o espaço de nomes da classe tenha sido preenchido executando o corpo da classe, o objeto da classe é criado chamando <code class="docutils literal notranslate"><span class="pre">metaclass(name,</span> <span class="pre">bases,</span> <span class="pre">namespace,</span> <span class="pre">**kwds)</span></code> (os argumentos adicionais passados aqui são os mesmos passados para <code class="docutils literal notranslate"><span class="pre">__prepare__</span></code>).</p>
<p>Este objeto classe é aquele que será referenciado pela forma de argumento zero de <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a>. <code class="docutils literal notranslate"><span class="pre">__class__</span></code> é uma referência implícita de fechamento criada pelo compilador se qualquer método em um corpo de classe se referir a <code class="docutils literal notranslate"><span class="pre">__class__</span></code> ou <code class="docutils literal notranslate"><span class="pre">super</span></code>. Isso permite que a forma de argumento zero de <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> identifique corretamente a classe sendo definida com base no escopo léxico, enquanto a classe ou instância que foi usada para fazer a chamada atual é identificada com base no primeiro argumento passado para o método.</p>
<div class="impl-detail compound">
<p><strong>CPython implementation detail:</strong> No CPython 3.6 e posterior, a célula <code class="docutils literal notranslate"><span class="pre">__class__</span></code> é passada para a metaclasse como uma entrada de <code class="docutils literal notranslate"><span class="pre">__classcell__</span></code> no espaço de nomes da classe. Se estiver presente, deve ser propagado até a chamada <code class="docutils literal notranslate"><span class="pre">type.__new__</span></code> para que a classe seja inicializada corretamente. Não fazer isso resultará em um <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> no Python 3.8.</p>
</div>
<p>When using the default metaclass <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a>, or any metaclass that ultimately
calls <code class="docutils literal notranslate"><span class="pre">type.__new__</span></code>, the following additional customization steps are
invoked after creating the class object:</p>
<ol class="arabic simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">type.__new__</span></code> method collects all of the attributes in the class
namespace that define a <a class="reference internal" href="#object.__set_name__" title="object.__set_name__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set_name__()</span></code></a> method;</p></li>
<li><p>Those <code class="docutils literal notranslate"><span class="pre">__set_name__</span></code> methods are called with the class
being defined and the assigned name of that particular attribute;</p></li>
<li><p>The <a class="reference internal" href="#object.__init_subclass__" title="object.__init_subclass__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init_subclass__()</span></code></a> hook is called on the
immediate parent of the new class in its method resolution order.</p></li>
</ol>
<p>Depois que o objeto classe é criado, ele é passado para os decoradores de classe incluídos na definição de classe (se houver) e o objeto resultante é vinculado ao espaço de nomes local como a classe definida.</p>
<p>Quando uma nova classe é criada por <code class="docutils literal notranslate"><span class="pre">type.__new__</span></code>, o objeto fornecido como o parâmetro do espaço de nomes é copiado para um novo mapeamento ordenado e o objeto original é descartado. A nova cópia é envolta em um proxy de somente leitura, que se torna o atributo <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> do objeto classe.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver também</p>
<dl class="simple">
<dt><span class="target" id="index-122"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3135"><strong>PEP 3135</strong></a> - Novo super</dt><dd><p>Descreve a referência implícita de fechamento de  <code class="docutils literal notranslate"><span class="pre">__class__</span></code></p>
</dd>
</dl>
</div>
</section>
<section id="uses-for-metaclasses">
<h4><span class="section-number">3.3.3.7. </span>Usos para metaclasses<a class="headerlink" href="#uses-for-metaclasses" title="Link permanente para este título">¶</a></h4>
<p>Os usos potenciais para metaclasses são ilimitados. Algumas ideias que foram exploradas incluem enum, criação de log, verificação de interface, delegação automática, criação automática de propriedade, proxies, estruturas e bloqueio/sincronização automático/a de recursos.</p>
</section>
</section>
<section id="customizing-instance-and-subclass-checks">
<h3><span class="section-number">3.3.4. </span>Personalizando verificações de instância e subclasse<a class="headerlink" href="#customizing-instance-and-subclass-checks" title="Link permanente para este título">¶</a></h3>
<p>Os seguintes métodos são usados para substituir o comportamento padrão das funções embutidas <a class="reference internal" href="../library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> e <a class="reference internal" href="../library/functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a>.</p>
<p>Em particular, a metaclasse <a class="reference internal" href="../library/abc.html#abc.ABCMeta" title="abc.ABCMeta"><code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABCMeta</span></code></a> implementa esses métodos a fim de permitir a adição de classes base abstratas (ABCs) como “classes base virtuais” para qualquer classe ou tipo (incluindo tipos embutidos), incluindo outras ABCs.</p>
<dl class="py method">
<dt id="class.__instancecheck__">
<code class="sig-prename descclassname">class.</code><code class="sig-name descname">__instancecheck__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">instance</span></em><span class="sig-paren">)</span><a class="headerlink" href="#class.__instancecheck__" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna verdadeiro se <em>instance</em> deve ser considerada uma instância (direta ou indireta) da classe <em>class</em>. Se definido, chamado para implementar <code class="docutils literal notranslate"><span class="pre">isinstance(instance,</span> <span class="pre">class)</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="class.__subclasscheck__">
<code class="sig-prename descclassname">class.</code><code class="sig-name descname">__subclasscheck__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">subclass</span></em><span class="sig-paren">)</span><a class="headerlink" href="#class.__subclasscheck__" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna verdadeiro se <em>subclass</em> deve ser considerada uma subclasse (direta ou indireta) da classe <em>class</em>. Se definido, chamado para implementar <code class="docutils literal notranslate"><span class="pre">issubclass(subclass,</span> <span class="pre">class)</span></code>.</p>
</dd></dl>

<p>Observe que esses métodos são pesquisados no tipo (metaclasse) de uma classe. Eles não podem ser definidos como métodos de classe na classe real. Isso é consistente com a pesquisa de métodos especiais que são chamados em instâncias, apenas neste caso a própria instância é uma classe.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver também</p>
<dl class="simple">
<dt><span class="target" id="index-123"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3119"><strong>PEP 3119</strong></a> - Introduzindo classes base abstratas</dt><dd><p>Inclui a especificação para personalizar o comportamento de <a class="reference internal" href="../library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> e <a class="reference internal" href="../library/functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a> através de <a class="reference internal" href="#class.__instancecheck__" title="class.__instancecheck__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__instancecheck__()</span></code></a> e <a class="reference internal" href="#class.__subclasscheck__" title="class.__subclasscheck__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__subclasscheck__()</span></code></a>, com motivação para esta funcionalidade no contexto da adição de classes base abstratas (veja o módulo <a class="reference internal" href="../library/abc.html#module-abc" title="abc: Abstract base classes according to :pep:`3119`."><code class="xref py py-mod docutils literal notranslate"><span class="pre">abc</span></code></a>) para a linguagem.</p>
</dd>
</dl>
</div>
</section>
<section id="emulating-generic-types">
<h3><span class="section-number">3.3.5. </span>Emulando tipos genéricos<a class="headerlink" href="#emulating-generic-types" title="Link permanente para este título">¶</a></h3>
<p>When using <a class="reference internal" href="../glossary.html#term-annotation"><span class="xref std std-term">type annotations</span></a>, it is often useful to
<em>parameterize</em> a <a class="reference internal" href="../glossary.html#term-generic-type"><span class="xref std std-term">generic type</span></a> using Python’s square-brackets notation.
For example, the annotation <code class="docutils literal notranslate"><span class="pre">list[int]</span></code> might be used to signify a
<a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> in which all the elements are of type <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver também</p>
<dl class="simple">
<dt><span class="target" id="index-91"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a> - Type Hints</dt><dd><p>Introducing Python’s framework for type annotations</p>
</dd>
<dt><a class="reference internal" href="../library/stdtypes.html#types-genericalias"><span class="std std-ref">Generic Alias Types</span></a></dt><dd><p>Documentation for objects representing parameterized generic classes</p>
</dd>
<dt><a class="reference internal" href="../library/typing.html#generics"><span class="std std-ref">Generics</span></a>, <a class="reference internal" href="../library/typing.html#user-defined-generics"><span class="std std-ref">user-defined generics</span></a> and <a class="reference internal" href="../library/typing.html#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Generic</span></code></a></dt><dd><p>Documentation on how to implement generic classes that can be
parameterized at runtime and understood by static type-checkers.</p>
</dd>
</dl>
</div>
<p>A class can <em>generally</em> only be parameterized if it defines the special
class method <code class="docutils literal notranslate"><span class="pre">__class_getitem__()</span></code>.</p>
<dl class="py method">
<dt id="object.__class_getitem__">
<em class="property">classmethod </em><code class="sig-prename descclassname">object.</code><code class="sig-name descname">__class_getitem__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cls</span></em>, <em class="sig-param"><span class="n">key</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__class_getitem__" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna um objeto que representa a especialização de uma classe genérica por argumentos de tipo encontrados em <em>key</em>.</p>
<p>When defined on a class, <code class="docutils literal notranslate"><span class="pre">__class_getitem__()</span></code> is automatically a class
method. As such, there is no need for it to be decorated with
<a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;classmethod</span></code></a> when it is defined.</p>
</dd></dl>

<section id="the-purpose-of-class-getitem">
<h4><span class="section-number">3.3.5.1. </span>The purpose of <em>__class_getitem__</em><a class="headerlink" href="#the-purpose-of-class-getitem" title="Link permanente para este título">¶</a></h4>
<p>The purpose of <a class="reference internal" href="#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a> is to allow runtime
parameterization of standard-library generic classes in order to more easily
apply <a class="reference internal" href="../glossary.html#term-type-hint"><span class="xref std std-term">type hints</span></a> to these classes.</p>
<p>To implement custom generic classes that can be parameterized at runtime and
understood by static type-checkers, users should either inherit from a standard
library class that already implements <a class="reference internal" href="#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a>, or
inherit from <a class="reference internal" href="../library/typing.html#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Generic</span></code></a>, which has its own implementation of
<code class="docutils literal notranslate"><span class="pre">__class_getitem__()</span></code>.</p>
<p>Custom implementations of <a class="reference internal" href="#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a> on classes defined
outside of the standard library may not be understood by third-party
type-checkers such as mypy. Using <code class="docutils literal notranslate"><span class="pre">__class_getitem__()</span></code> on any class for
purposes other than type hinting is discouraged.</p>
</section>
<section id="class-getitem-versus-getitem">
<span id="classgetitem-versus-getitem"></span><h4><span class="section-number">3.3.5.2. </span><em>__class_getitem__</em> versus <em>__getitem__</em><a class="headerlink" href="#class-getitem-versus-getitem" title="Link permanente para este título">¶</a></h4>
<p>Usually, the <a class="reference internal" href="expressions.html#subscriptions"><span class="std std-ref">subscription</span></a> of an object using square
brackets will call the <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> instance method defined on
the object’s class. However, if the object being subscribed is itself a class,
the class method <a class="reference internal" href="#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a> may be called instead.
<code class="docutils literal notranslate"><span class="pre">__class_getitem__()</span></code> should return a <a class="reference internal" href="../library/stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias</span></a>
object if it is properly defined.</p>
<p>Presented with the <a class="reference internal" href="../glossary.html#term-expression"><span class="xref std std-term">expression</span></a> <code class="docutils literal notranslate"><span class="pre">obj[x]</span></code>, the Python interpreter
follows something like the following process to decide whether
<a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> or <a class="reference internal" href="#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a> should be
called:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">isclass</span>

<span class="k">def</span> <span class="nf">subscribe</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the result of the expression `obj[x]`&quot;&quot;&quot;</span>

    <span class="n">class_of_obj</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

    <span class="c1"># If the class of obj defines __getitem__,</span>
    <span class="c1"># call class_of_obj.__getitem__(obj, x)</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">class_of_obj</span><span class="p">,</span> <span class="s1">&#39;__getitem__&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">class_of_obj</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

    <span class="c1"># Else, if obj is a class and defines __class_getitem__,</span>
    <span class="c1"># call obj.__class_getitem__(x)</span>
    <span class="k">elif</span> <span class="n">isclass</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;__class_getitem__&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">__class_getitem__</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="c1"># Else, raise an exception</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">class_of_obj</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&#39; object is not subscriptable&quot;</span>
        <span class="p">)</span>
</pre></div>
</div>
<p>In Python, all classes are themselves instances of other classes. The class of
a class is known as that class’s <a class="reference internal" href="../glossary.html#term-metaclass"><span class="xref std std-term">metaclass</span></a>, and most classes have the
<a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a> class as their metaclass. <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a> does not define
<a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>, meaning that expressions such as <code class="docutils literal notranslate"><span class="pre">list[int]</span></code>,
<code class="docutils literal notranslate"><span class="pre">dict[str,</span> <span class="pre">float]</span></code> and <code class="docutils literal notranslate"><span class="pre">tuple[str,</span> <span class="pre">bytes]</span></code> all result in
<a class="reference internal" href="#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a> being called:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># list has class &quot;type&quot; as its metaclass, like most classes:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
<span class="go">&lt;class &#39;type&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="nb">tuple</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="nb">bytes</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># &quot;list[int]&quot; calls &quot;list.__class_getitem__(int)&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
<span class="go">list[int]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># list.__class_getitem__ returns a GenericAlias object:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span>
<span class="go">&lt;class &#39;types.GenericAlias&#39;&gt;</span>
</pre></div>
</div>
<p>However, if a class has a custom metaclass that defines
<a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>, subscribing the class may result in different
behaviour. An example of this can be found in the <a class="reference internal" href="../library/enum.html#module-enum" title="enum: Implementation of an enumeration class."><code class="xref py py-mod docutils literal notranslate"><span class="pre">enum</span></code></a> module:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">Enum</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Menu</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
<span class="gp">... </span>    <span class="sd">&quot;&quot;&quot;A breakfast menu&quot;&quot;&quot;</span>
<span class="gp">... </span>    <span class="n">SPAM</span> <span class="o">=</span> <span class="s1">&#39;spam&#39;</span>
<span class="gp">... </span>    <span class="n">BACON</span> <span class="o">=</span> <span class="s1">&#39;bacon&#39;</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Enum classes have a custom metaclass:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">Menu</span><span class="p">)</span>
<span class="go">&lt;class &#39;enum.EnumMeta&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># EnumMeta defines __getitem__,</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># so __class_getitem__ is not called,</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># and the result is not a GenericAlias object:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Menu</span><span class="p">[</span><span class="s1">&#39;SPAM&#39;</span><span class="p">]</span>
<span class="go">&lt;Menu.SPAM: &#39;spam&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">Menu</span><span class="p">[</span><span class="s1">&#39;SPAM&#39;</span><span class="p">])</span>
<span class="go">&lt;enum &#39;Menu&#39;&gt;</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver também</p>
<dl class="simple">
<dt><span class="target" id="index-92"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0560"><strong>PEP 560</strong></a> - Core Support for typing module and generic types</dt><dd><p>Introducing <a class="reference internal" href="#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a>, and outlining when a
<a class="reference internal" href="expressions.html#subscriptions"><span class="std std-ref">subscription</span></a> results in <code class="docutils literal notranslate"><span class="pre">__class_getitem__()</span></code>
being called instead of <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a></p>
</dd>
</dl>
</div>
</section>
</section>
<section id="emulating-callable-objects">
<span id="callable-types"></span><h3><span class="section-number">3.3.6. </span>Emulando objetos chamáveis<a class="headerlink" href="#emulating-callable-objects" title="Link permanente para este título">¶</a></h3>
<dl class="py method">
<dt id="object.__call__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__call__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="optional">[</span>, <em class="sig-param">args...</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__call__" title="Link permanente para esta definição">¶</a></dt>
<dd><p id="index-93">Chamado quando a instância é “chamada” como uma função; se este método for definido, <code class="docutils literal notranslate"><span class="pre">x(arg1,</span> <span class="pre">arg2,</span> <span class="pre">...)</span></code> basicamente traduz para <code class="docutils literal notranslate"><span class="pre">type(x).__call__(x,</span> <span class="pre">arg1,</span> <span class="pre">...)</span></code>.</p>
</dd></dl>

</section>
<section id="emulating-container-types">
<span id="sequence-types"></span><h3><span class="section-number">3.3.7. </span>Emulando de tipos contêineres<a class="headerlink" href="#emulating-container-types" title="Link permanente para este título">¶</a></h3>
<p>The following methods can be defined to implement container objects.  Containers
usually are <a class="reference internal" href="../glossary.html#term-sequence"><span class="xref std std-term">sequences</span></a> (such as <a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">lists</span></code></a> or
<a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuples</span></code></a>) or <a class="reference internal" href="../glossary.html#term-mapping"><span class="xref std std-term">mappings</span></a> (like
<a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dictionaries</span></code></a>),
but can represent other containers as well.  The first set of methods is used
either to emulate a sequence or to emulate a mapping; the difference is that for
a sequence, the allowable keys should be the integers <em>k</em> for which <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">k</span> <span class="pre">&lt;</span>
<span class="pre">N</span></code> where <em>N</em> is the length of the sequence, or <a class="reference internal" href="../library/functions.html#slice" title="slice"><code class="xref py py-class docutils literal notranslate"><span class="pre">slice</span></code></a> objects, which define a
range of items.  It is also recommended that mappings provide the methods
<code class="xref py py-meth docutils literal notranslate"><span class="pre">keys()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">values()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">items()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">clear()</span></code>,
<code class="xref py py-meth docutils literal notranslate"><span class="pre">setdefault()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">pop()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">popitem()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">copy()</span></code>, and
<code class="xref py py-meth docutils literal notranslate"><span class="pre">update()</span></code> behaving similar to those for Python’s standard <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dictionary</span></code></a>
objects.  The <a class="reference internal" href="../library/collections.abc.html#module-collections.abc" title="collections.abc: Abstract base classes for containers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a> module provides a
<a class="reference internal" href="../library/collections.abc.html#collections.abc.MutableMapping" title="collections.abc.MutableMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">MutableMapping</span></code></a>
<a class="reference internal" href="../glossary.html#term-abstract-base-class"><span class="xref std std-term">abstract base class</span></a> to help create those methods from a base set of
<a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>, <a class="reference internal" href="#object.__setitem__" title="object.__setitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setitem__()</span></code></a>, <a class="reference internal" href="#object.__delitem__" title="object.__delitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delitem__()</span></code></a>, and <code class="xref py py-meth docutils literal notranslate"><span class="pre">keys()</span></code>.
Mutable sequences should provide methods <code class="xref py py-meth docutils literal notranslate"><span class="pre">append()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">count()</span></code>,
<code class="xref py py-meth docutils literal notranslate"><span class="pre">index()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">extend()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">insert()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">pop()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">remove()</span></code>,
<code class="xref py py-meth docutils literal notranslate"><span class="pre">reverse()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">sort()</span></code>, like Python standard <a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>
objects. Finally,
sequence types should implement addition (meaning concatenation) and
multiplication (meaning repetition) by defining the methods
<a class="reference internal" href="#object.__add__" title="object.__add__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__add__()</span></code></a>, <a class="reference internal" href="#object.__radd__" title="object.__radd__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__radd__()</span></code></a>, <a class="reference internal" href="#object.__iadd__" title="object.__iadd__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iadd__()</span></code></a>,
<a class="reference internal" href="#object.__mul__" title="object.__mul__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__mul__()</span></code></a>, <a class="reference internal" href="#object.__rmul__" title="object.__rmul__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__rmul__()</span></code></a> and <a class="reference internal" href="#object.__imul__" title="object.__imul__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__imul__()</span></code></a>
described below; they should not define other numerical
operators.  It is recommended that both mappings and sequences implement the
<a class="reference internal" href="#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code></a> method to allow efficient use of the <code class="docutils literal notranslate"><span class="pre">in</span></code>
operator; for
mappings, <code class="docutils literal notranslate"><span class="pre">in</span></code> should search the mapping’s keys; for sequences, it should
search through the values.  It is further recommended that both mappings and
sequences implement the <a class="reference internal" href="#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> method to allow efficient iteration
through the container; for mappings, <code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code> should iterate
through the object’s keys; for sequences, it should iterate through the values.</p>
<dl class="py method">
<dt id="object.__len__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__len__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__len__" title="Link permanente para esta definição">¶</a></dt>
<dd><p id="index-94">Chamado para implementar a função embutida <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a>. Deve retornar o comprimento do objeto, um inteiro <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code> 0. Além disso, um objeto que não define um método <a class="reference internal" href="#object.__bool__" title="object.__bool__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__bool__()</span></code></a> e cujo método <a class="reference internal" href="#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code></a> retorna zero é considerado como falso em um contexto booleano.</p>
<div class="impl-detail compound">
<p><strong>CPython implementation detail:</strong> No CPython, o comprimento deve ser no máximo <a class="reference internal" href="../library/sys.html#sys.maxsize" title="sys.maxsize"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.maxsize</span></code></a>. Se o comprimento for maior que <code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.maxsize</span></code>, alguns recursos (como <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a>) podem levantar <a class="reference internal" href="../library/exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code></a>. Para evitar levantar <code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code> pelo teste de valor de verdade, um objeto deve definir um método <a class="reference internal" href="#object.__bool__" title="object.__bool__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__bool__()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="object.__length_hint__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__length_hint__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__length_hint__" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Chamado para implementar <a class="reference internal" href="../library/operator.html#operator.length_hint" title="operator.length_hint"><code class="xref py py-func docutils literal notranslate"><span class="pre">operator.length_hint()</span></code></a>. Deve retornar um comprimento estimado para o objeto (que pode ser maior ou menor que o comprimento real). O comprimento deve ser um inteiro <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code> 0. O valor de retorno também pode ser <a class="reference internal" href="../library/constants.html#NotImplemented" title="NotImplemented"><code class="xref py py-const docutils literal notranslate"><span class="pre">NotImplemented</span></code></a>, que é tratado da mesma forma como se o método <code class="docutils literal notranslate"><span class="pre">__length_hint__</span></code> não existisse. Este método é puramente uma otimização e nunca é necessário para a correção.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.4.</span></p>
</div>
</dd></dl>

<div class="admonition note" id="index-95">
<p class="admonition-title">Nota</p>
<p>O fatiamento é feito exclusivamente com os três métodos a seguir. Uma chamada como</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span>
</pre></div>
</div>
<p>é traduzida com</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span> <span class="o">=</span> <span class="n">b</span>
</pre></div>
</div>
<p>e assim por diante. Os itens de fatia ausentes são sempre preenchidos com <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</div>
<dl class="py method">
<dt id="object.__getitem__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__getitem__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">key</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__getitem__" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Called to implement evaluation of <code class="docutils literal notranslate"><span class="pre">self[key]</span></code>. For <a class="reference internal" href="../glossary.html#term-sequence"><span class="xref std std-term">sequence</span></a> types,
the accepted keys should be integers and slice objects.  Note that the
special interpretation of negative indexes (if the class wishes to emulate a
<a class="reference internal" href="../glossary.html#term-sequence"><span class="xref std std-term">sequence</span></a> type) is up to the <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> method. If <em>key</em> is
of an inappropriate type, <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> may be raised; if of a value
outside the set of indexes for the sequence (after any special
interpretation of negative values), <a class="reference internal" href="../library/exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a> should be raised. For
<a class="reference internal" href="../glossary.html#term-mapping"><span class="xref std std-term">mapping</span></a> types, if <em>key</em> is missing (not in the container),
<a class="reference internal" href="../library/exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a> should be raised.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Os loops <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> esperam que uma <a class="reference internal" href="../library/exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a> seja levantada para índices ilegais para permitir a detecção apropriada do fim da sequência.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>When <a class="reference internal" href="expressions.html#subscriptions"><span class="std std-ref">subscripting</span></a> a <em>class</em>, the special
class method <a class="reference internal" href="#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a> may be called instead of
<code class="docutils literal notranslate"><span class="pre">__getitem__()</span></code>. See <a class="reference internal" href="#classgetitem-versus-getitem"><span class="std std-ref">__class_getitem__ versus __getitem__</span></a> for more
details.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="object.__setitem__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__setitem__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">key</span></em>, <em class="sig-param"><span class="n">value</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__setitem__" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Chamado para implementar a atribuição de <code class="docutils literal notranslate"><span class="pre">self[key]</span></code>. Mesma nota que para <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>. Isso só deve ser implementado para mapeamentos se os objetos suportarem alterações nos valores das chaves, ou se novas chaves puderem ser adicionadas, ou para sequências se os elementos puderem ser substituídos. As mesmas exceções devem ser levantadas para valores <em>key</em> impróprios do método <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="object.__delitem__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__delitem__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">key</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__delitem__" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Chamado para implementar a exclusão de <code class="docutils literal notranslate"><span class="pre">self[key]</span></code>. Mesma nota que para <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>. Isso só deve ser implementado para mapeamentos se os objetos suportarem remoções de chaves, ou para sequências se os elementos puderem ser removidos da sequência. As mesmas exceções devem ser levantadas para valores <em>key</em> impróprios do método <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="object.__missing__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__missing__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">key</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__missing__" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Chamado por <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>.<a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> para implementar <code class="docutils literal notranslate"><span class="pre">self[key]</span></code> para subclasses de dicionário quando a chave não estiver no dicionário.</p>
</dd></dl>

<dl class="py method">
<dt id="object.__iter__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__iter__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__iter__" title="Link permanente para esta definição">¶</a></dt>
<dd><p>This method is called when an <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a> is required for a container.
This method should return a new iterator object that can iterate over all the
objects in the container.  For mappings, it should iterate over the keys of
the container.</p>
</dd></dl>

<dl class="py method">
<dt id="object.__reversed__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__reversed__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__reversed__" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Chamado (se presente) pelo <a class="reference internal" href="../library/functions.html#reversed" title="reversed"><code class="xref py py-func docutils literal notranslate"><span class="pre">reversed()</span></code></a> embutido para implementar a iteração reversa. Ele deve retornar um novo objeto iterador que itera sobre todos os objetos no contêiner na ordem reversa.</p>
<p>Se o método <a class="reference internal" href="#object.__reversed__" title="object.__reversed__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reversed__()</span></code></a> não for fornecido, o <a class="reference internal" href="../library/functions.html#reversed" title="reversed"><code class="xref py py-func docutils literal notranslate"><span class="pre">reversed()</span></code></a> embutido voltará a usar o protocolo de sequência (<a class="reference internal" href="#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code></a> e <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>). Objetos que suportam o protocolo de sequência só devem fornecer <a class="reference internal" href="#object.__reversed__" title="object.__reversed__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reversed__()</span></code></a> se eles puderem fornecer uma implementação que seja mais eficiente do que aquela fornecida por <a class="reference internal" href="../library/functions.html#reversed" title="reversed"><code class="xref py py-func docutils literal notranslate"><span class="pre">reversed()</span></code></a>.</p>
</dd></dl>

<p>Os operadores de teste de associação (<a class="reference internal" href="expressions.html#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> e <a class="reference internal" href="expressions.html#not-in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span> <span class="pre">in</span></code></a>) são normalmente implementados como uma iteração através de um contêiner. No entanto, os objetos contêiner podem fornecer o seguinte método especial com uma implementação mais eficiente, que também não requer que o objeto seja iterável.</p>
<dl class="py method">
<dt id="object.__contains__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__contains__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">item</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__contains__" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Chamado para implementar operadores de teste de associação. Deve retornar verdadeiro se <em>item</em> estiver em <em>self</em>, falso caso contrário. Para objetos de mapeamento, isso deve considerar as chaves do mapeamento em vez dos valores ou pares de itens-chave.</p>
<p>Para objetos que não definem <a class="reference internal" href="#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code></a>, o teste de associação primeiro tenta a iteração via <a class="reference internal" href="#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a>, depois o protocolo de iteração de sequência antigo via <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>, consulte <a class="reference internal" href="expressions.html#membership-test-details"><span class="std std-ref">esta seção em a referência da linguagem</span></a>.</p>
</dd></dl>

</section>
<section id="emulating-numeric-types">
<span id="numeric-types"></span><h3><span class="section-number">3.3.8. </span>Emulando tipos numéricos<a class="headerlink" href="#emulating-numeric-types" title="Link permanente para este título">¶</a></h3>
<p>Os métodos a seguir podem ser definidos para emular objetos numéricos. Métodos correspondentes a operações que não são suportadas pelo tipo particular de número implementado (por exemplo, operações bit a bit para números não inteiros) devem ser deixados indefinidos.</p>
<dl class="py method">
<dt id="object.__add__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__add__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__add__" title="Link permanente para esta definição">¶</a></dt>
<dt id="object.__sub__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__sub__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__sub__" title="Link permanente para esta definição">¶</a></dt>
<dt id="object.__mul__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__mul__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__mul__" title="Link permanente para esta definição">¶</a></dt>
<dt id="object.__matmul__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__matmul__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__matmul__" title="Link permanente para esta definição">¶</a></dt>
<dt id="object.__truediv__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__truediv__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__truediv__" title="Link permanente para esta definição">¶</a></dt>
<dt id="object.__floordiv__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__floordiv__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__floordiv__" title="Link permanente para esta definição">¶</a></dt>
<dt id="object.__mod__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__mod__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__mod__" title="Link permanente para esta definição">¶</a></dt>
<dt id="object.__divmod__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__divmod__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__divmod__" title="Link permanente para esta definição">¶</a></dt>
<dt id="object.__pow__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__pow__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="optional">[</span>, <em class="sig-param">modulo</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__pow__" title="Link permanente para esta definição">¶</a></dt>
<dt id="object.__lshift__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__lshift__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__lshift__" title="Link permanente para esta definição">¶</a></dt>
<dt id="object.__rshift__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__rshift__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rshift__" title="Link permanente para esta definição">¶</a></dt>
<dt id="object.__and__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__and__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__and__" title="Link permanente para esta definição">¶</a></dt>
<dt id="object.__xor__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__xor__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__xor__" title="Link permanente para esta definição">¶</a></dt>
<dt id="object.__or__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__or__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__or__" title="Link permanente para esta definição">¶</a></dt>
<dd><p id="index-96">Esses métodos são chamados para implementar as operações aritméticas binárias (<code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;</span></code>, <code class="docutils literal notranslate"><span class="pre">/</span></code>, <code class="docutils literal notranslate"><span class="pre">//</span></code>, <code class="docutils literal notranslate"><span class="pre">%</span></code>, <a class="reference internal" href="../library/functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a>, <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a>, <code class="docutils literal notranslate"><span class="pre">**</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>, <code class="docutils literal notranslate"><span class="pre">^</span></code>, <code class="docutils literal notranslate"><span class="pre">|</span></code>). Por exemplo, para avaliar a expressão <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></code>, onde <em>x</em> é uma instância de uma classe que tem um método <a class="reference internal" href="#object.__add__" title="object.__add__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__add__()</span></code></a>, <code class="docutils literal notranslate"><span class="pre">x.__add__(y)</span></code> é chamado. O método <a class="reference internal" href="#object.__divmod__" title="object.__divmod__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__divmod__()</span></code></a> deve ser equivalente a usar <a class="reference internal" href="#object.__floordiv__" title="object.__floordiv__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__floordiv__()</span></code></a> e <a class="reference internal" href="#object.__mod__" title="object.__mod__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__mod__()</span></code></a>; não deve estar relacionado a <a class="reference internal" href="#object.__truediv__" title="object.__truediv__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__truediv__()</span></code></a>. Note que <a class="reference internal" href="#object.__pow__" title="object.__pow__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__pow__()</span></code></a> deve ser definido para aceitar um terceiro argumento opcional se a versão ternária da função interna <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a> for suportada.</p>
<p>Se um desses métodos não suporta a operação com os argumentos fornecidos, ele deve retornar <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="object.__radd__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__radd__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__radd__" title="Link permanente para esta definição">¶</a></dt>
<dt id="object.__rsub__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__rsub__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rsub__" title="Link permanente para esta definição">¶</a></dt>
<dt id="object.__rmul__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__rmul__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rmul__" title="Link permanente para esta definição">¶</a></dt>
<dt id="object.__rmatmul__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__rmatmul__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rmatmul__" title="Link permanente para esta definição">¶</a></dt>
<dt id="object.__rtruediv__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__rtruediv__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rtruediv__" title="Link permanente para esta definição">¶</a></dt>
<dt id="object.__rfloordiv__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__rfloordiv__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rfloordiv__" title="Link permanente para esta definição">¶</a></dt>
<dt id="object.__rmod__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__rmod__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rmod__" title="Link permanente para esta definição">¶</a></dt>
<dt id="object.__rdivmod__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__rdivmod__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rdivmod__" title="Link permanente para esta definição">¶</a></dt>
<dt id="object.__rpow__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__rpow__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="optional">[</span>, <em class="sig-param">modulo</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__rpow__" title="Link permanente para esta definição">¶</a></dt>
<dt id="object.__rlshift__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__rlshift__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rlshift__" title="Link permanente para esta definição">¶</a></dt>
<dt id="object.__rrshift__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__rrshift__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rrshift__" title="Link permanente para esta definição">¶</a></dt>
<dt id="object.__rand__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__rand__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rand__" title="Link permanente para esta definição">¶</a></dt>
<dt id="object.__rxor__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__rxor__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rxor__" title="Link permanente para esta definição">¶</a></dt>
<dt id="object.__ror__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__ror__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ror__" title="Link permanente para esta definição">¶</a></dt>
<dd><p id="index-97">Esses métodos são chamados para implementar as operações aritméticas binárias (<code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;</span></code>, <code class="docutils literal notranslate"><span class="pre">/</span></code>, <code class="docutils literal notranslate"><span class="pre">//</span></code>, <code class="docutils literal notranslate"><span class="pre">%</span></code>, <a class="reference internal" href="../library/functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a>, <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a>, <code class="docutils literal notranslate"><span class="pre">**</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>, <code class="docutils literal notranslate"><span class="pre">^</span></code>, <code class="docutils literal notranslate"><span class="pre">|</span></code>) com operandos refletidos (trocados). Essas funções são chamadas apenas se o operando esquerdo não suportar a operação correspondente <a class="footnote-reference brackets" href="#id10" id="id5">3</a> e os operandos forem de tipos diferentes. <a class="footnote-reference brackets" href="#id11" id="id6">4</a> Por exemplo, para avaliar a expressão <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">-</span> <span class="pre">y</span></code>, onde <em>y</em> é uma instância de uma classe que tem um método <a class="reference internal" href="#object.__rsub__" title="object.__rsub__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__rsub__()</span></code></a>, <code class="docutils literal notranslate"><span class="pre">y.__rsub__(x)</span></code> é chamado se <code class="docutils literal notranslate"><span class="pre">x.__sub__(y)</span></code> retorna <em>NotImplemented</em>.</p>
<p id="index-98">Note que ternário <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a> não tentará chamar <a class="reference internal" href="#object.__rpow__" title="object.__rpow__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__rpow__()</span></code></a> (as regras de coerção se tornariam muito complicadas).</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Se o tipo do operando direito for uma subclasse do tipo do operando esquerdo e essa subclasse fornecer uma implementação diferente do método refletido para a operação, este método será chamado antes do método não refletido do operando esquerdo. Esse comportamento permite que as subclasses substituam as operações de seus ancestrais.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="object.__iadd__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__iadd__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__iadd__" title="Link permanente para esta definição">¶</a></dt>
<dt id="object.__isub__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__isub__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__isub__" title="Link permanente para esta definição">¶</a></dt>
<dt id="object.__imul__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__imul__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__imul__" title="Link permanente para esta definição">¶</a></dt>
<dt id="object.__imatmul__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__imatmul__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__imatmul__" title="Link permanente para esta definição">¶</a></dt>
<dt id="object.__itruediv__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__itruediv__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__itruediv__" title="Link permanente para esta definição">¶</a></dt>
<dt id="object.__ifloordiv__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__ifloordiv__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ifloordiv__" title="Link permanente para esta definição">¶</a></dt>
<dt id="object.__imod__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__imod__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__imod__" title="Link permanente para esta definição">¶</a></dt>
<dt id="object.__ipow__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__ipow__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="optional">[</span>, <em class="sig-param">modulo</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__ipow__" title="Link permanente para esta definição">¶</a></dt>
<dt id="object.__ilshift__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__ilshift__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ilshift__" title="Link permanente para esta definição">¶</a></dt>
<dt id="object.__irshift__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__irshift__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__irshift__" title="Link permanente para esta definição">¶</a></dt>
<dt id="object.__iand__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__iand__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__iand__" title="Link permanente para esta definição">¶</a></dt>
<dt id="object.__ixor__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__ixor__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ixor__" title="Link permanente para esta definição">¶</a></dt>
<dt id="object.__ior__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__ior__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ior__" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Esses métodos são chamados para implementar as atribuições aritméticas aumentadas (<code class="docutils literal notranslate"><span class="pre">+=</span></code>, <code class="docutils literal notranslate"><span class="pre">-=</span></code>, <code class="docutils literal notranslate"><span class="pre">*=</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;=</span></code>, <code class="docutils literal notranslate"><span class="pre">/=</span></code>, <code class="docutils literal notranslate"><span class="pre">//=</span></code>, <code class="docutils literal notranslate"><span class="pre">%=</span></code>, <code class="docutils literal notranslate"><span class="pre">**=</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;=</span></code>, <code class="docutils literal notranslate"><span class="pre">^=</span></code>, <code class="docutils literal notranslate"><span class="pre">|=</span></code>). Esses métodos devem tentar fazer a operação no local (modificando <em>self</em>) e retornar o resultado (que poderia ser, mas não precisa ser, <em>self</em>). Se um método específico não for definido, a atribuição aumentada volta aos métodos normais. Por exemplo, se <em>x</em> é uma instância de uma classe com um método <a class="reference internal" href="#object.__iadd__" title="object.__iadd__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iadd__()</span></code></a>, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+=</span> <span class="pre">y</span></code> é equivalente a <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">x.__iadd__(y)</span></code>. Caso contrário, <code class="docutils literal notranslate"><span class="pre">x.__add__(y)</span></code> e <code class="docutils literal notranslate"><span class="pre">y.__radd__(x)</span></code> são considerados, como com a avaliação de <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></code>. Em certas situações, a atribuição aumentada pode resultar em erros inesperados (ver <a class="reference internal" href="../faq/programming.html#faq-augmented-assignment-tuple-error"><span class="std std-ref">Porque a_tuple[i] += [‘item’] levanta uma exceção quando a adição funciona?</span></a>), mas este comportamento é na verdade parte do modelo de dados.</p>
</dd></dl>

<dl class="py method">
<dt id="object.__neg__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__neg__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__neg__" title="Link permanente para esta definição">¶</a></dt>
<dt id="object.__pos__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__pos__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__pos__" title="Link permanente para esta definição">¶</a></dt>
<dt id="object.__abs__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__abs__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__abs__" title="Link permanente para esta definição">¶</a></dt>
<dt id="object.__invert__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__invert__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__invert__" title="Link permanente para esta definição">¶</a></dt>
<dd><p id="index-99">Chamado para implementar as operações aritméticas unárias (<code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">+</span></code>, <a class="reference internal" href="../library/functions.html#abs" title="abs"><code class="xref py py-func docutils literal notranslate"><span class="pre">abs()</span></code></a> e <code class="docutils literal notranslate"><span class="pre">~</span></code>).</p>
</dd></dl>

<dl class="py method">
<dt id="object.__complex__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__complex__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__complex__" title="Link permanente para esta definição">¶</a></dt>
<dt id="object.__int__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__int__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__int__" title="Link permanente para esta definição">¶</a></dt>
<dt id="object.__float__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__float__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__float__" title="Link permanente para esta definição">¶</a></dt>
<dd><p id="index-100">Chamado para implementar as funções embutidas <a class="reference internal" href="../library/functions.html#complex" title="complex"><code class="xref py py-func docutils literal notranslate"><span class="pre">complex()</span></code></a>, <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a> e <a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-func docutils literal notranslate"><span class="pre">float()</span></code></a>. Deve retornar um valor do tipo apropriado.</p>
</dd></dl>

<dl class="py method">
<dt id="object.__index__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__index__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__index__" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Chamado para implementar <a class="reference internal" href="../library/operator.html#operator.index" title="operator.index"><code class="xref py py-func docutils literal notranslate"><span class="pre">operator.index()</span></code></a>, e sempre que o Python precisar converter sem perdas o objeto numérico em um objeto inteiro (como no fatiamento ou nas funções embutidas <a class="reference internal" href="../library/functions.html#bin" title="bin"><code class="xref py py-func docutils literal notranslate"><span class="pre">bin()</span></code></a>, <a class="reference internal" href="../library/functions.html#hex" title="hex"><code class="xref py py-func docutils literal notranslate"><span class="pre">hex()</span></code></a> e <a class="reference internal" href="../library/functions.html#oct" title="oct"><code class="xref py py-func docutils literal notranslate"><span class="pre">oct()</span></code></a>). A presença deste método indica que o objeto numérico é do tipo inteiro. Deve retornar um número inteiro.</p>
<p>Se <a class="reference internal" href="#object.__int__" title="object.__int__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__int__()</span></code></a>, <a class="reference internal" href="#object.__float__" title="object.__float__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__float__()</span></code></a> e <a class="reference internal" href="#object.__complex__" title="object.__complex__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__complex__()</span></code></a> não estiverem definidos, funções embutidas correspondentes <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a>, <a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-func docutils literal notranslate"><span class="pre">float()</span></code></a> e <a class="reference internal" href="../library/functions.html#complex" title="complex"><code class="xref py py-func docutils literal notranslate"><span class="pre">complex()</span></code></a> recorre a <a class="reference internal" href="#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="object.__round__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__round__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="optional">[</span>, <em class="sig-param">ndigits</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__round__" title="Link permanente para esta definição">¶</a></dt>
<dt id="object.__trunc__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__trunc__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__trunc__" title="Link permanente para esta definição">¶</a></dt>
<dt id="object.__floor__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__floor__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__floor__" title="Link permanente para esta definição">¶</a></dt>
<dt id="object.__ceil__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__ceil__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ceil__" title="Link permanente para esta definição">¶</a></dt>
<dd><p id="index-101">Chamado para implementar as funções embutidas <a class="reference internal" href="../library/functions.html#round" title="round"><code class="xref py py-func docutils literal notranslate"><span class="pre">round()</span></code></a> e <a class="reference internal" href="../library/math.html#math.trunc" title="math.trunc"><code class="xref py py-func docutils literal notranslate"><span class="pre">trunc()</span></code></a>, <a class="reference internal" href="../library/math.html#math.floor" title="math.floor"><code class="xref py py-func docutils literal notranslate"><span class="pre">floor()</span></code></a> e <a class="reference internal" href="../library/math.html#math.ceil" title="math.ceil"><code class="xref py py-func docutils literal notranslate"><span class="pre">ceil()</span></code></a> de <a class="reference internal" href="../library/math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code></a>. A menos que <em>ndigits</em> sejam passados para <code class="xref py py-meth docutils literal notranslate"><span class="pre">__round__()</span></code> todos estes métodos devem retornar o valor do objeto truncado para um <a class="reference internal" href="../library/numbers.html#numbers.Integral" title="numbers.Integral"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integral</span></code></a> (tipicamente um <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>).</p>
<p>The built-in function <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a> falls back to <a class="reference internal" href="#object.__trunc__" title="object.__trunc__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__trunc__()</span></code></a> if neither
<a class="reference internal" href="#object.__int__" title="object.__int__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__int__()</span></code></a> nor <a class="reference internal" href="#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code></a> is defined.</p>
</dd></dl>

</section>
<section id="with-statement-context-managers">
<span id="context-managers"></span><h3><span class="section-number">3.3.9. </span>Com gerenciadores de contexto de instruções<a class="headerlink" href="#with-statement-context-managers" title="Link permanente para este título">¶</a></h3>
<p>Um <em class="dfn">gerenciador de contexto</em> é um objeto que define o contexto de tempo de execução a ser estabelecido ao executar uma instrução <a class="reference internal" href="compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>. O gerenciador de contexto lida com a entrada e a saída do contexto de tempo de execução desejado para a execução do bloco de código. Os gerenciadores de contexto são normalmente invocados usando a instrução <code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code> (descrita na seção <a class="reference internal" href="compound_stmts.html#with"><span class="std std-ref">The with statement</span></a>), mas também podem ser usados invocando diretamente seus métodos.</p>
<p id="index-102">Os usos típicos de gerenciadores de contexto incluem salvar e restaurar vários tipos de estado global, bloquear e desbloquear recursos, fechar arquivos abertos, etc.</p>
<p>Para obter mais informações sobre gerenciadores de contexto, consulte <a class="reference internal" href="../library/stdtypes.html#typecontextmanager"><span class="std std-ref">Tipos de Gerenciador de Contexto</span></a>.</p>
<dl class="py method">
<dt id="object.__enter__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__enter__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__enter__" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Insere o contexto de tempo de execução relacionado a este objeto. A instrução <a class="reference internal" href="compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> vinculará o valor de retorno deste método ao(s) alvo(s) especificado(s) na cláusula <code class="xref std std-keyword docutils literal notranslate"><span class="pre">as</span></code> da instrução, se houver.</p>
</dd></dl>

<dl class="py method">
<dt id="object.__exit__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__exit__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">exc_type</span></em>, <em class="sig-param"><span class="n">exc_value</span></em>, <em class="sig-param"><span class="n">traceback</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__exit__" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Sai do contexto de tempo de execução relacionado a este objeto. Os parâmetros descrevem a exceção que fez com que o contexto fosse encerrado. Se o contexto foi encerrado sem exceção, todos os três argumentos serão <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>.</p>
<p>Se uma exceção for fornecida e o método desejar suprimir a exceção (ou seja, evitar que ela seja propagada), ele deve retornar um valor verdadeiro. Caso contrário, a exceção será processada normalmente ao sair deste método.</p>
<p>Observe que os métodos <a class="reference internal" href="#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> não devem relançar a exceção passada; esta é a responsabilidade do chamador.</p>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">Ver também</p>
<dl class="simple">
<dt><span class="target" id="index-124"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0343"><strong>PEP 343</strong></a> - A instrução “with”</dt><dd><p>A especificação, o histórico e os exemplos para a instrução Python <a class="reference internal" href="compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>.</p>
</dd>
</dl>
</div>
</section>
<section id="customizing-positional-arguments-in-class-pattern-matching">
<span id="class-pattern-matching"></span><h3><span class="section-number">3.3.10. </span>Customizando argumentos posicionais na classe correspondência de padrão<a class="headerlink" href="#customizing-positional-arguments-in-class-pattern-matching" title="Link permanente para este título">¶</a></h3>
<p>Ao usar um nome de classe em um padrão, argumentos posicionais não são permitidos por padrão, ou seja, <code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">MyClass(x,</span> <span class="pre">y)</span></code> é tipicamente inválida sem suporte especial em <code class="docutils literal notranslate"><span class="pre">MyClass</span></code>. Para permitir a utilização desse tipo de padrão, a classe precisa definir um atributo <em>__match_args__</em></p>
<dl class="py data">
<dt id="object.__match_args__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__match_args__</code><a class="headerlink" href="#object.__match_args__" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Essa variável de classe pode ser atribuída a uma tupla de strings. Quando essa classe é usada em uma classe padrão com argumentos posicionais, cada argumento posicional será convertido para um argumento nomeado, usando correspondência de valor em  <em>__match_args__</em> como palavra reservada. A ausência desse atributo é equivalente a defini-lo como <code class="docutils literal notranslate"><span class="pre">()</span></code></p>
</dd></dl>

<p>Por exemplo, se <code class="docutils literal notranslate"><span class="pre">MyClass.__match_args__</span></code> é <code class="docutils literal notranslate"><span class="pre">(&quot;left&quot;,</span> <span class="pre">&quot;center&quot;,</span> <span class="pre">&quot;right&quot;)</span></code> significa que <code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">MyClass(x,</span> <span class="pre">y)</span></code> é equivalente a <code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">MyClass(left=x,</span> <span class="pre">center=y)</span></code>. Note que o número de argumentos no padrão deve ser menor ou igual ao número de elementos em <em>__match_args__</em>; caso seja maior, a tentativa de correspondência de padrão irá levantar uma <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.10.</span></p>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver também</p>
<dl class="simple">
<dt><span class="target" id="index-125"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0634"><strong>PEP 634</strong></a> - Correspondência de Padrão Estrutural</dt><dd><p>A especificação para a instrução Python <code class="docutils literal notranslate"><span class="pre">match</span></code></p>
</dd>
</dl>
</div>
</section>
<section id="special-method-lookup">
<span id="special-lookup"></span><h3><span class="section-number">3.3.11. </span>Pesquisa de método especial<a class="headerlink" href="#special-method-lookup" title="Link permanente para este título">¶</a></h3>
<p>Para classes personalizadas, as invocações implícitas de métodos especiais só têm garantia de funcionar corretamente se definidas em um tipo de objeto, não no dicionário de instância do objeto. Esse comportamento é o motivo pelo qual o código a seguir levanta uma exceção:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="fm">__len__</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">object of type &#39;C&#39; has no len()</span>
</pre></div>
</div>
<p>The rationale behind this behaviour lies with a number of special methods such
as <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> and <a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code></a> that are implemented
by all objects,
including type objects. If the implicit lookup of these methods used the
conventional lookup process, they would fail when invoked on the type object
itself:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">1</span> <span class="o">.</span><span class="fm">__hash__</span><span class="p">()</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">()</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">descriptor &#39;__hash__&#39; of &#39;int&#39; object needs an argument</span>
</pre></div>
</div>
<p>A tentativa incorreta de invocar um método não vinculado de uma classe dessa maneira é às vezes referida como “confusão de metaclasse” e é evitada ignorando a instância ao pesquisar métodos especiais:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>In addition to bypassing any instance attributes in the interest of
correctness, implicit special method lookup generally also bypasses the
<a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> method even of the object’s metaclass:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Meta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__getattribute__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Metaclass getattribute invoked&quot;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="nb">type</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">Meta</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="mi">10</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__getattribute__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Class getattribute invoked&quot;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="fm">__len__</span><span class="p">()</span>                 <span class="c1"># Explicit lookup via instance</span>
<span class="go">Class getattribute invoked</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="fm">__len__</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>          <span class="c1"># Explicit lookup via type</span>
<span class="go">Metaclass getattribute invoked</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>                      <span class="c1"># Implicit lookup</span>
<span class="go">10</span>
</pre></div>
</div>
<p>Bypassing the <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> machinery in this fashion
provides significant scope for speed optimisations within the
interpreter, at the cost of some flexibility in the handling of
special methods (the special method <em>must</em> be set on the class
object itself in order to be consistently invoked by the interpreter).</p>
</section>
</section>
<section id="coroutines">
<span id="index-105"></span><h2><span class="section-number">3.4. </span>Corrotinas<a class="headerlink" href="#coroutines" title="Link permanente para este título">¶</a></h2>
<section id="awaitable-objects">
<h3><span class="section-number">3.4.1. </span>Objetos aguardáveis<a class="headerlink" href="#awaitable-objects" title="Link permanente para este título">¶</a></h3>
<p>An <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a> object generally implements an <a class="reference internal" href="#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a> method.
<a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">Coroutine objects</span></a> returned from <a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> functions
are awaitable.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>The <a class="reference internal" href="../glossary.html#term-generator-iterator"><span class="xref std std-term">generator iterator</span></a> objects returned from generators
decorated with <a class="reference internal" href="../library/types.html#types.coroutine" title="types.coroutine"><code class="xref py py-func docutils literal notranslate"><span class="pre">types.coroutine()</span></code></a> or <a class="reference internal" href="../library/asyncio-task.html#asyncio.coroutine" title="asyncio.coroutine"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.coroutine()</span></code></a>
are also awaitable, but they do not implement <a class="reference internal" href="#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a>.</p>
</div>
<dl class="py method">
<dt id="object.__await__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__await__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__await__" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Deve retornar um <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterador</span></a>. Deve ser usado para implementar objetos <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">aguardáveis</span></a>. Por exemplo, <a class="reference internal" href="../library/asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Future</span></code></a> implementa este método para ser compatível com a expressão <a class="reference internal" href="expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a>.</p>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.5.</span></p>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver também</p>
<p><span class="target" id="index-126"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0492"><strong>PEP 492</strong></a> para informações adicionais sobre objetos aguardáveis.</p>
</div>
</section>
<section id="coroutine-objects">
<span id="id7"></span><h3><span class="section-number">3.4.2. </span>Objetos corrotina<a class="headerlink" href="#coroutine-objects" title="Link permanente para este título">¶</a></h3>
<p><a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">Coroutine objects</span></a> are <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a> objects.
A coroutine’s execution can be controlled by calling <a class="reference internal" href="#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a> and
iterating over the result.  When the coroutine has finished executing and
returns, the iterator raises <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a>, and the exception’s
<code class="xref py py-attr docutils literal notranslate"><span class="pre">value</span></code> attribute holds the return value.  If the
coroutine raises an exception, it is propagated by the iterator.  Coroutines
should not directly raise unhandled <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> exceptions.</p>
<p>As corrotinas também têm os métodos listados abaixo, que são análogos aos dos geradores (ver <a class="reference internal" href="expressions.html#generator-methods"><span class="std std-ref">Generator-iterator methods</span></a>). No entanto, ao contrário dos geradores, as corrotinas não suportam diretamente a iteração.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.5.2: </span>É uma <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> para aguardar uma corrotina mais de uma vez.</p>
</div>
<dl class="py method">
<dt id="coroutine.send">
<code class="sig-prename descclassname">coroutine.</code><code class="sig-name descname">send</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">value</span></em><span class="sig-paren">)</span><a class="headerlink" href="#coroutine.send" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Starts or resumes execution of the coroutine.  If <em>value</em> is <code class="docutils literal notranslate"><span class="pre">None</span></code>,
this is equivalent to advancing the iterator returned by
<a class="reference internal" href="#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a>.  If <em>value</em> is not <code class="docutils literal notranslate"><span class="pre">None</span></code>, this method delegates
to the <a class="reference internal" href="expressions.html#generator.send" title="generator.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> method of the iterator that caused
the coroutine to suspend.  The result (return value,
<a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a>, or other exception) is the same as when
iterating over the <code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code> return value, described above.</p>
</dd></dl>

<dl class="py method">
<dt id="coroutine.throw">
<code class="sig-prename descclassname">coroutine.</code><code class="sig-name descname">throw</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">value</span></em><span class="sig-paren">)</span><a class="headerlink" href="#coroutine.throw" title="Link permanente para esta definição">¶</a></dt>
<dt>
<code class="sig-prename descclassname">coroutine.</code><code class="sig-name descname">throw</code><span class="sig-paren">(</span><em class="sig-param">type</em><span class="optional">[</span>, <em class="sig-param">value</em><span class="optional">[</span>, <em class="sig-param">traceback</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>Raises the specified exception in the coroutine.  This method delegates
to the <a class="reference internal" href="expressions.html#generator.throw" title="generator.throw"><code class="xref py py-meth docutils literal notranslate"><span class="pre">throw()</span></code></a> method of the iterator that caused
the coroutine to suspend, if it has such a method.  Otherwise,
the exception is raised at the suspension point.  The result
(return value, <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a>, or other exception) is the same as
when iterating over the <a class="reference internal" href="#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a> return value, described
above.  If the exception is not caught in the coroutine, it propagates
back to the caller.</p>
</dd></dl>

<dl class="py method">
<dt id="coroutine.close">
<code class="sig-prename descclassname">coroutine.</code><code class="sig-name descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#coroutine.close" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Faz com que a corrotina se limpe e saia. Se a corrotina for suspensa, este método primeiro delega para o método <a class="reference internal" href="expressions.html#generator.close" title="generator.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> do iterador que causou a suspensão da corrotina, se tiver tal método. Então ele levanta <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">GeneratorExit</span></code></a> no ponto de suspensão, fazendo com que a corrotina se limpe imediatamente. Por fim, a corrotina é marcada como tendo sua execução concluída, mesmo que nunca tenha sido iniciada.</p>
<p>Objetos corrotina são fechados automaticamente usando o processo acima quando estão prestes a ser destruídos.</p>
</dd></dl>

</section>
<section id="asynchronous-iterators">
<span id="async-iterators"></span><h3><span class="section-number">3.4.3. </span>Iteradores assíncronos<a class="headerlink" href="#asynchronous-iterators" title="Link permanente para este título">¶</a></h3>
<p>Um <em>iterador assíncrono</em> pode chamar código assíncrono em seu método <code class="docutils literal notranslate"><span class="pre">__anext__</span></code>.</p>
<p>Os iteradores assíncronos podem ser usados ​​em uma instrução <a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a>.</p>
<dl class="py method">
<dt id="object.__aiter__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__aiter__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__aiter__" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Deve retornar um objeto <em>iterador assíncrono</em>.</p>
</dd></dl>

<dl class="py method">
<dt id="object.__anext__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__anext__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__anext__" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Deve retornar um <em>aguardável</em> resultando em um próximo valor do iterador. Deve levantar um erro <a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a> quando a iteração terminar.</p>
</dd></dl>

<p>Um exemplo de objeto iterável assíncrono:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Reader</span><span class="p">:</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">readline</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="fm">__aiter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">async</span> <span class="k">def</span> <span class="fm">__anext__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">val</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">StopAsyncIteration</span>
        <span class="k">return</span> <span class="n">val</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.5.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.7: </span>Prior to Python 3.7, <a class="reference internal" href="#object.__aiter__" title="object.__aiter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aiter__()</span></code></a> could return an <em>awaitable</em>
that would resolve to an
<a class="reference internal" href="../glossary.html#term-asynchronous-iterator"><span class="xref std std-term">asynchronous iterator</span></a>.</p>
<p>Starting with Python 3.7, <a class="reference internal" href="#object.__aiter__" title="object.__aiter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aiter__()</span></code></a> must return an
asynchronous iterator object.  Returning anything else
will result in a <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> error.</p>
</div>
</section>
<section id="asynchronous-context-managers">
<span id="async-context-managers"></span><h3><span class="section-number">3.4.4. </span>Gerenciadores de contexto assíncronos<a class="headerlink" href="#asynchronous-context-managers" title="Link permanente para este título">¶</a></h3>
<p>Um <em>gerenciador de contexto assíncrono</em> é um <em>gerenciador de contexto</em> que é capaz de suspender a execução em seus métodos <code class="docutils literal notranslate"><span class="pre">__aenter__</span></code> e <code class="docutils literal notranslate"><span class="pre">__aexit__</span></code>.</p>
<p>Os gerenciadores de contexto assíncronos podem ser usados ​​em uma instrução <a class="reference internal" href="compound_stmts.html#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a>.</p>
<dl class="py method">
<dt id="object.__aenter__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__aenter__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__aenter__" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Semanticamente semelhante a <a class="reference internal" href="#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a>, a única diferença é que ele deve retornar um <em>aguardável</em>.</p>
</dd></dl>

<dl class="py method">
<dt id="object.__aexit__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__aexit__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">exc_type</span></em>, <em class="sig-param"><span class="n">exc_value</span></em>, <em class="sig-param"><span class="n">traceback</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__aexit__" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Semanticamente semelhante a <a class="reference internal" href="#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a>, a única diferença é que ele deve retornar um <em>aguardável</em>.</p>
</dd></dl>

<p>Um exemplo de uma classe gerenciadora de contexto assíncrona:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">AsyncContextManager</span><span class="p">:</span>
    <span class="k">async</span> <span class="k">def</span> <span class="fm">__aenter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">await</span> <span class="n">log</span><span class="p">(</span><span class="s1">&#39;entering context&#39;</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="fm">__aexit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc</span><span class="p">,</span> <span class="n">tb</span><span class="p">):</span>
        <span class="k">await</span> <span class="n">log</span><span class="p">(</span><span class="s1">&#39;exiting context&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.5.</span></p>
</div>
<p class="rubric">Notas de rodapé</p>
<dl class="footnote brackets">
<dt class="label" id="id8"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Em alguns casos, <em>é</em> possível alterar o tipo de um objeto, sob certas condições controladas. No entanto, geralmente não é uma boa ideia, pois pode levar a um comportamento muito estranho se for tratado incorretamente.</p>
</dd>
<dt class="label" id="id9"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>The <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a>, <a class="reference internal" href="#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a>,
<a class="reference internal" href="#object.__reversed__" title="object.__reversed__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reversed__()</span></code></a>, and <a class="reference internal" href="#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code></a> methods have
special handling for this; others
will still raise a <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>, but may do so by relying on
the behavior that <code class="docutils literal notranslate"><span class="pre">None</span></code> is not callable.</p>
</dd>
<dt class="label" id="id10"><span class="brackets"><a class="fn-backref" href="#id5">3</a></span></dt>
<dd><p>“Não suportar” aqui significa que a classe não possui tal método, ou o método retorna <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code>. Não defina o método como <code class="docutils literal notranslate"><span class="pre">None</span></code> se quiser forçar o fallback para o método refletido do operando correto – isso terá o efeito oposto de <em>bloquear</em> explicitamente esse fallback.</p>
</dd>
<dt class="label" id="id11"><span class="brackets"><a class="fn-backref" href="#id6">4</a></span></dt>
<dd><p>For operands of the same type, it is assumed that if the non-reflected
method – such as <a class="reference internal" href="#object.__add__" title="object.__add__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__add__()</span></code></a> – fails then the overall
operation is not
supported, which is why the reflected method is not called.</p>
</dd>
</dl>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Tabela de Conteúdo</a></h3>
  <ul>
<li><a class="reference internal" href="#">3. Modelo de dados</a><ul>
<li><a class="reference internal" href="#objects-values-and-types">3.1. Objetos, valores e tipos</a></li>
<li><a class="reference internal" href="#the-standard-type-hierarchy">3.2. A hierarquia de tipos padrão</a></li>
<li><a class="reference internal" href="#special-method-names">3.3. Nomes de métodos especiais</a><ul>
<li><a class="reference internal" href="#basic-customization">3.3.1. Personalização básica</a></li>
<li><a class="reference internal" href="#customizing-attribute-access">3.3.2. Personalizando o acesso aos atributos</a><ul>
<li><a class="reference internal" href="#customizing-module-attribute-access">3.3.2.1. Personalizando acesso a atributos de módulos</a></li>
<li><a class="reference internal" href="#implementing-descriptors">3.3.2.2. Implementando descritores</a></li>
<li><a class="reference internal" href="#invoking-descriptors">3.3.2.3. Invocando descritores</a></li>
<li><a class="reference internal" href="#slots">3.3.2.4. __slots__</a><ul>
<li><a class="reference internal" href="#notes-on-using-slots">3.3.2.4.1. Observações ao uso de <em>__slots__</em></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#customizing-class-creation">3.3.3. Personalizando a criação de classe</a><ul>
<li><a class="reference internal" href="#metaclasses">3.3.3.1. Metaclasses</a></li>
<li><a class="reference internal" href="#resolving-mro-entries">3.3.3.2. Resolvendo entradas de MRO</a></li>
<li><a class="reference internal" href="#determining-the-appropriate-metaclass">3.3.3.3. Determinando a metaclasse apropriada</a></li>
<li><a class="reference internal" href="#preparing-the-class-namespace">3.3.3.4. Preparando o espaço de nomes da classe</a></li>
<li><a class="reference internal" href="#executing-the-class-body">3.3.3.5. Executando o corpo da classe</a></li>
<li><a class="reference internal" href="#creating-the-class-object">3.3.3.6. Criando o objeto da classe</a></li>
<li><a class="reference internal" href="#uses-for-metaclasses">3.3.3.7. Usos para metaclasses</a></li>
</ul>
</li>
<li><a class="reference internal" href="#customizing-instance-and-subclass-checks">3.3.4. Personalizando verificações de instância e subclasse</a></li>
<li><a class="reference internal" href="#emulating-generic-types">3.3.5. Emulando tipos genéricos</a><ul>
<li><a class="reference internal" href="#the-purpose-of-class-getitem">3.3.5.1. The purpose of <em>__class_getitem__</em></a></li>
<li><a class="reference internal" href="#class-getitem-versus-getitem">3.3.5.2. <em>__class_getitem__</em> versus <em>__getitem__</em></a></li>
</ul>
</li>
<li><a class="reference internal" href="#emulating-callable-objects">3.3.6. Emulando objetos chamáveis</a></li>
<li><a class="reference internal" href="#emulating-container-types">3.3.7. Emulando de tipos contêineres</a></li>
<li><a class="reference internal" href="#emulating-numeric-types">3.3.8. Emulando tipos numéricos</a></li>
<li><a class="reference internal" href="#with-statement-context-managers">3.3.9. Com gerenciadores de contexto de instruções</a></li>
<li><a class="reference internal" href="#customizing-positional-arguments-in-class-pattern-matching">3.3.10. Customizando argumentos posicionais na classe correspondência de padrão</a></li>
<li><a class="reference internal" href="#special-method-lookup">3.3.11. Pesquisa de método especial</a></li>
</ul>
</li>
<li><a class="reference internal" href="#coroutines">3.4. Corrotinas</a><ul>
<li><a class="reference internal" href="#awaitable-objects">3.4.1. Objetos aguardáveis</a></li>
<li><a class="reference internal" href="#coroutine-objects">3.4.2. Objetos corrotina</a></li>
<li><a class="reference internal" href="#asynchronous-iterators">3.4.3. Iteradores assíncronos</a></li>
<li><a class="reference internal" href="#asynchronous-context-managers">3.4.4. Gerenciadores de contexto assíncronos</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Tópico anterior</h4>
  <p class="topless"><a href="lexical_analysis.html"
                        title="capítulo anterior"><span class="section-number">2. </span>Análise léxica</a></p>
  <h4>Próximo tópico</h4>
  <p class="topless"><a href="executionmodel.html"
                        title="próximo capítulo"><span class="section-number">4. </span>Modelo de execução</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Relatar um erro</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.10/Doc/reference/datamodel.rst"
            rel="nofollow">Exibir código-fonte
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegação</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice geral"
             >índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="executionmodel.html" title="4. Modelo de execução"
             >próximo</a> |</li>
        <li class="right" >
          <a href="lexical_analysis.html" title="2. Análise léxica"
             >anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.10.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >A Referência da Linguagem Python</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">3. </span>Modelo de dados</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Busca rápida" aria-label="Busca rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Direitos autorais</a> 2001-2022, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    Última atualização em jun. 04, 2022.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.4.3.
    </div>

  </body>
</html>