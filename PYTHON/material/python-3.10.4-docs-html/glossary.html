
<!DOCTYPE html>

<html lang="pt_BR">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17: http://docutils.sourceforge.net/" />

    <title>Glossário &#8212; documentação Python 3.10.4</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/pydoctheme.css?2022.1" type="text/css" />
    
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/translations.js"></script>
    
    <script src="_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Pesquisar dentro de documentação Python 3.10.4"
          href="_static/opensearch.xml"/>
    <link rel="author" title="Sobre esses documentos" href="about.html" />
    <link rel="index" title="Índice" href="genindex.html" />
    <link rel="search" title="Buscar" href="search.html" />
    <link rel="copyright" title="Direitos autorais" href="copyright.html" />
    <link rel="next" title="Sobre esses documentos" href="about.html" />
    <link rel="prev" title="FAD de “Por que o Python está instalado em meu computador?”" href="faq/installed.html" />
    <link rel="canonical" href="https://docs.python.org/3/glossary.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="shortcut icon" type="image/png" href="_static/py.svg" />
            <script type="text/javascript" src="_static/copybutton.js"></script>
            <script type="text/javascript" src="_static/menu.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <label for="menuToggler" class="toggler__label">
        <span></span>
    </label>
    <nav class="nav-content" role="navigation">
         <a href="https://www.python.org/" class="nav-logo">
             <img src="_static/py.svg" alt="Logo"/>
         </a>
        <div class="version_switcher_placeholder"></div>
        <form role="search" class="search" action="search.html" method="get">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                <path fill-rule="nonzero"
                        d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="#444"></path>
            </svg>
            <input type="text" name="q" aria-label="Busca rápida"/>
            <input type="submit" value="Ir"/>
        </form>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
  <h4>Tópico anterior</h4>
  <p class="topless"><a href="faq/installed.html"
                        title="capítulo anterior">FAD de “Por que o Python está instalado em meu computador?”</a></p>
  <h4>Próximo tópico</h4>
  <p class="topless"><a href="about.html"
                        title="próximo capítulo">Sobre esses documentos</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="bugs.html">Relatar um erro</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.10/Doc/glossary.rst"
            rel="nofollow">Exibir código-fonte
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegação</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Índice geral"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="about.html" title="Sobre esses documentos"
             accesskey="N">próximo</a> |</li>
        <li class="right" >
          <a href="faq/installed.html" title="FAD de “Por que o Python está instalado em meu computador?”"
             accesskey="P">anterior</a> |</li>

          <li><img src="_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="index.html">3.10.4 Documentation</a> &#187;
    </li>

        <li class="nav-item nav-item-this"><a href="">Glossário</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="search.html" method="get">
          <input placeholder="Busca rápida" aria-label="Busca rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="glossary">
<span id="id1"></span><h1>Glossário<a class="headerlink" href="#glossary" title="Link permanente para este título">¶</a></h1>
<dl class="glossary">
<dt id="term-0"><code class="docutils literal notranslate"><span class="pre">&gt;&gt;&gt;</span></code></dt><dd><p>O prompt padrão do console interativo do Python. Normalmente visto em exemplos de código que podem ser executados interativamente no interpretador.</p>
</dd>
<dt id="term-..."><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>Pode se referir a:</p>
<ul class="simple">
<li><p>O prompt padrão do shell interativo do Python ao inserir o código para um bloco de código recuado, quando dentro de um par de delimitadores correspondentes esquerdo e direito (parênteses, colchetes, chaves ou aspas triplas) ou após especificar um decorador.</p></li>
<li><p>A constante embutida <a class="reference internal" href="library/constants.html#Ellipsis" title="Ellipsis"><code class="xref py py-const docutils literal notranslate"><span class="pre">Ellipsis</span></code></a>.</p></li>
</ul>
</dd>
<dt id="term-2to3">2to3</dt><dd><p>Uma ferramenta que tenta converter código Python 2.x em código Python 3.x tratando a maioria das incompatibilidades que podem ser detectadas com análise do código-fonte e navegação na árvore sintática.</p>
<p>O 2to3 está disponível na biblioteca padrão como <a class="reference internal" href="library/2to3.html#module-lib2to3" title="lib2to3: The 2to3 library"><code class="xref py py-mod docutils literal notranslate"><span class="pre">lib2to3</span></code></a>; um ponto de entrada é disponibilizado como <code class="file docutils literal notranslate"><span class="pre">Tools/scripts/2to3</span></code>. Veja <a class="reference internal" href="library/2to3.html#to3-reference"><span class="std std-ref">2to3 - Tradução Automatizada de Código Python 2 para 3</span></a>.</p>
</dd>
<dt id="term-abstract-base-class">classe base abstrata</dt><dd><p>Classes bases abstratas complementam <a class="reference internal" href="#term-duck-typing"><span class="xref std std-term">tipagem pato</span></a>, fornecendo uma maneira de definir interfaces quando outras técnicas, como <a class="reference internal" href="library/functions.html#hasattr" title="hasattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">hasattr()</span></code></a>, seriam desajeitadas ou sutilmente erradas (por exemplo, com <a class="reference internal" href="reference/datamodel.html#special-lookup"><span class="std std-ref">métodos mágicos</span></a>). CBAs introduzem subclasses virtuais, classes que não herdam de uma classe mas ainda são reconhecidas por <a class="reference internal" href="library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> e <a class="reference internal" href="library/functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a>; veja a documentação do módulo <a class="reference internal" href="library/abc.html#module-abc" title="abc: Abstract base classes according to :pep:`3119`."><code class="xref py py-mod docutils literal notranslate"><span class="pre">abc</span></code></a>. Python vem com muitas CBAs embutidas para estruturas de dados (no módulo <a class="reference internal" href="library/collections.abc.html#module-collections.abc" title="collections.abc: Abstract base classes for containers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a>), números (no módulo <a class="reference internal" href="library/numbers.html#module-numbers" title="numbers: Numeric abstract base classes (Complex, Real, Integral, etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">numbers</span></code></a>), fluxos (no módulo <a class="reference internal" href="library/io.html#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">io</span></code></a>), localizadores e carregadores de importação (no módulo <a class="reference internal" href="library/importlib.html#module-importlib.abc" title="importlib.abc: Abstract base classes related to import"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.abc</span></code></a>). Você pode criar suas próprias CBAs com o módulo <a class="reference internal" href="library/abc.html#module-abc" title="abc: Abstract base classes according to :pep:`3119`."><code class="xref py py-mod docutils literal notranslate"><span class="pre">abc</span></code></a>.</p>
</dd>
<dt id="term-annotation">anotação</dt><dd><p>Um rótulo associado a uma variável, um atributo de classe ou um parâmetro de função ou valor de retorno, usado por convenção como <a class="reference internal" href="#term-type-hint"><span class="xref std std-term">dica de tipo</span></a>.</p>
<p>Anotações de variáveis ​​locais não podem ser acessadas em tempo de execução, mas anotações de variáveis ​​globais, atributos de classe e funções são armazenadas no atributo especial <code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code> de módulos, classes e funções, respectivamente.</p>
<p>Veja <a class="reference internal" href="#term-variable-annotation"><span class="xref std std-term">anotação de variável</span></a>, <a class="reference internal" href="#term-function-annotation"><span class="xref std std-term">anotação de função</span></a>, <span class="target" id="index-74"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a> e <span class="target" id="index-75"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0526"><strong>PEP 526</strong></a>, que descrevem esta funcionalidade. Veja também <a class="reference internal" href="howto/annotations.html#annotations-howto"><span class="std std-ref">Annotations Best Practices</span></a> para as melhores práticas sobre como trabalhar com anotações.</p>
</dd>
<dt id="term-argument">argumento</dt><dd><p>Um valor passado para uma <a class="reference internal" href="#term-function"><span class="xref std std-term">função</span></a> (ou <a class="reference internal" href="#term-method"><span class="xref std std-term">método</span></a>) ao chamar a função. Existem dois tipos de argumento:</p>
<ul>
<li><p><em class="dfn">argumento nomeado</em>: um argumento precedido por um identificador (por exemplo, <code class="docutils literal notranslate"><span class="pre">name=</span></code>) na chamada de uma função ou passada como um valor em um dicionário precedido por <code class="docutils literal notranslate"><span class="pre">**</span></code>. Por exemplo, <code class="docutils literal notranslate"><span class="pre">3</span></code> e <code class="docutils literal notranslate"><span class="pre">5</span></code> são ambos argumentos nomeados na chamada da função <a class="reference internal" href="library/functions.html#complex" title="complex"><code class="xref py py-func docutils literal notranslate"><span class="pre">complex()</span></code></a> a seguir:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">complex</span><span class="p">(</span><span class="n">real</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">imag</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="nb">complex</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="s1">&#39;real&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;imag&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">})</span>
</pre></div>
</div>
</li>
<li><p><em class="dfn">argumento posicional</em>: um argumento que não é um argumento nomeado. Argumentos posicionais podem aparecer no início da lista de argumentos e/ou podem ser passados com elementos de um <a class="reference internal" href="#term-iterable"><span class="xref std std-term">iterável</span></a> precedido por <code class="docutils literal notranslate"><span class="pre">*</span></code>. Por exemplo, <code class="docutils literal notranslate"><span class="pre">3</span></code> e <code class="docutils literal notranslate"><span class="pre">5</span></code> são ambos argumentos posicionais nas chamadas a seguir:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">complex</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="nb">complex</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
</pre></div>
</div>
</li>
</ul>
<p>Argumentos são atribuídos às variáveis locais nomeadas no corpo da função. Veja a seção <a class="reference internal" href="reference/expressions.html#calls"><span class="std std-ref">Calls</span></a> para as regras de atribuição. Sintaticamente, qualquer expressão pode ser usada para representar um argumento; avaliada a expressão, o valor é atribuído à variável local.</p>
<p>Veja também o termo <a class="reference internal" href="#term-parameter"><span class="xref std std-term">parâmetro</span></a> no glossário, a pergunta no FAQ sobre <a class="reference internal" href="faq/programming.html#faq-argument-vs-parameter"><span class="std std-ref">a diferença entre argumentos e parâmetros</span></a> e <span class="target" id="index-76"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0362"><strong>PEP 362</strong></a>.</p>
</dd>
<dt id="term-asynchronous-context-manager">gerenciador de contexto assíncrono</dt><dd><p>Um objeto que controla o ambiente visto numa instrução <a class="reference internal" href="reference/compound_stmts.html#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a> por meio da definição dos métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">__aenter__()</span></code> e <code class="xref py py-meth docutils literal notranslate"><span class="pre">__aexit__()</span></code>. Introduzido pela <span class="target" id="index-77"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0492"><strong>PEP 492</strong></a>.</p>
</dd>
<dt id="term-asynchronous-generator">gerador assíncrono</dt><dd><p>Uma função que retorna um <a class="reference internal" href="#term-asynchronous-generator-iterator"><span class="xref std std-term">iterador gerador assíncrono</span></a>. É parecida com uma função de corrotina definida com <a class="reference internal" href="reference/compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> exceto pelo fato de conter instruções <a class="reference internal" href="reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> para produzir uma série de valores que podem ser usados em um laço <a class="reference internal" href="reference/compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a>.</p>
<p>Normalmente se refere a uma função geradora assíncrona, mas pode se referir a um <em>iterador gerador assíncrono</em> em alguns contextos. Em casos em que o significado não esteja claro, usar o termo completo evita a ambiguidade.</p>
<p>Uma função geradora assíncrona pode conter expressões <a class="reference internal" href="reference/expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a> e também as instruções <a class="reference internal" href="reference/compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> e <a class="reference internal" href="reference/compound_stmts.html#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a>.</p>
</dd>
<dt id="term-asynchronous-generator-iterator">iterador gerador assíncrono</dt><dd><p>Um objeto criado por uma função <a class="reference internal" href="#term-asynchronous-generator"><span class="xref std std-term">geradora assíncrona</span></a>.</p>
<p>Este é um <a class="reference internal" href="#term-asynchronous-iterator"><span class="xref std std-term">iterador assíncrono</span></a> que, quando chamado usando o método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code>, retorna um objeto aguardável que executará o corpo da função geradora assíncrona até a próxima expressão <a class="reference internal" href="reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a>.</p>
<p>Cada <a class="reference internal" href="reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> suspende temporariamente o processamento, lembrando o estado de execução do local (incluindo variáveis locais e instruções <code class="docutils literal notranslate"><span class="pre">try</span></code> pendentes). Quando o <em>iterador gerador assíncrono</em> é efetivamente retomado com outro aguardável retornado por <code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code>, ele inicia de onde parou. Veja <span class="target" id="index-78"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0492"><strong>PEP 492</strong></a> e <span class="target" id="index-79"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0525"><strong>PEP 525</strong></a>.</p>
</dd>
<dt id="term-asynchronous-iterable">iterável assíncrono</dt><dd><p>Um objeto que pode ser usado em uma instrução <a class="reference internal" href="reference/compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a>. Deve retornar um <a class="reference internal" href="#term-asynchronous-iterator"><span class="xref std std-term">iterador assíncrono</span></a> do seu método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__aiter__()</span></code>. Introduzido por <span class="target" id="index-80"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0492"><strong>PEP 492</strong></a>.</p>
</dd>
<dt id="term-asynchronous-iterator">iterador assíncrono</dt><dd><p>Um objeto que implementa os métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">__aiter__()</span></code> e <code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code>. <code class="docutils literal notranslate"><span class="pre">__anext__</span></code> deve retornar um objeto <a class="reference internal" href="#term-awaitable"><span class="xref std std-term">aguardável</span></a>. <a class="reference internal" href="reference/compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> resolve os aguardáveis retornados por um método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code> do iterador assíncrono até que ele levante uma exceção <a class="reference internal" href="library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a>. Introduzido pela <span class="target" id="index-81"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0492"><strong>PEP 492</strong></a>.</p>
</dd>
<dt id="term-attribute">atributo</dt><dd><p>Um valor associado a um objeto que é referenciado pelo nome separado por um ponto. Por exemplo, se um objeto <em>o</em> tem um atributo <em>a</em> esse seria referenciado como <em>o.a</em>.</p>
</dd>
<dt id="term-awaitable">aguardável</dt><dd><p>Um objeto que pode ser usado em uma expressão <a class="reference internal" href="reference/expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a>. Pode ser uma <a class="reference internal" href="#term-coroutine"><span class="xref std std-term">corrotina</span></a> ou um objeto com um método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code>. Veja também a <span class="target" id="index-82"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0492"><strong>PEP 492</strong></a>.</p>
</dd>
<dt id="term-BDFL">BDFL</dt><dd><p>Abreviação da expressão da língua inglesa “Benevolent Dictator for Life” (em português, “Ditador Benevolente Vitalício”), referindo-se a <a class="reference external" href="https://gvanrossum.github.io/">Guido van Rossum</a>, criador do Python.</p>
</dd>
<dt id="term-binary-file">arquivo binário</dt><dd><p>Um <a class="reference internal" href="#term-file-object"><span class="xref std std-term">objeto arquivo</span></a> capaz de ler e gravar em <a class="reference internal" href="#term-bytes-like-object"><span class="xref std std-term">objetos byte ou similar</span></a>. Exemplos de arquivos binários são arquivos abertos no modo binário (<code class="docutils literal notranslate"><span class="pre">'rb'</span></code>, <code class="docutils literal notranslate"><span class="pre">'wb'</span></code> ou <code class="docutils literal notranslate"><span class="pre">'rb+'</span></code>), <code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdin.buffer</span></code>, <code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdout.buffer</span></code> e instâncias de <a class="reference internal" href="library/io.html#io.BytesIO" title="io.BytesIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.BytesIO</span></code></a> e <a class="reference internal" href="library/gzip.html#gzip.GzipFile" title="gzip.GzipFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">gzip.GzipFile</span></code></a>.</p>
<p>Veja também <a class="reference internal" href="#term-text-file"><span class="xref std std-term">arquivo texto</span></a> para um objeto arquivo capaz de ler e gravar em objetos <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>.</p>
</dd>
<dt id="term-borrowed-reference">referência emprestada</dt><dd><p>Na API C do Python, uma referência emprestada é uma referência a um objeto. Ela não modifica a contagem de referências do objeto. Ela se torna um ponteiro pendente se o objeto for destruído. Por exemplo, uma coleta de lixo pode remover a última <a class="reference internal" href="#term-strong-reference"><span class="xref std std-term">referência forte</span></a> para o objeto e assim destruí-lo.</p>
<p>Chamar <a class="reference internal" href="c-api/refcounting.html#c.Py_INCREF" title="Py_INCREF"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_INCREF()</span></code></a> na <a class="reference internal" href="#term-borrowed-reference"><span class="xref std std-term">referência emprestada</span></a> é recomendado para convertê-lo, internamente, em uma <a class="reference internal" href="#term-strong-reference"><span class="xref std std-term">referência forte</span></a>, exceto quando o objeto não pode ser destruído antes do último uso da referência emprestada. A função <a class="reference internal" href="c-api/refcounting.html#c.Py_NewRef" title="Py_NewRef"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_NewRef()</span></code></a> pode ser usada para criar uma nova <a class="reference internal" href="#term-strong-reference"><span class="xref std std-term">referência forte</span></a>.</p>
</dd>
<dt id="term-bytes-like-object">objeto byte ou similar</dt><dd><p>Um objeto com suporte ao o <a class="reference internal" href="c-api/buffer.html#bufferobjects"><span class="std std-ref">Protocolo de Buffer</span></a> e que pode exportar um buffer C <a class="reference internal" href="#term-contiguous"><span class="xref std std-term">contíguo</span></a>. Isso inclui todos os objetos <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, <a class="reference internal" href="library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> e <a class="reference internal" href="library/array.html#array.array" title="array.array"><code class="xref py py-class docutils literal notranslate"><span class="pre">array.array</span></code></a>, além de muitos objetos  <a class="reference internal" href="library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> comuns. Objetos byte ou similar podem ser usados para várias operações que funcionam com dados binários; isso inclui compactação, salvamento em um arquivo binário e envio por um soquete.</p>
<p>Algumas operações precisam que os dados binários sejam mutáveis. A documentação geralmente se refere a eles como “objetos byte ou similar para leitura e escrita”. Exemplos de objetos de buffer mutável incluem <a class="reference internal" href="library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> e um <a class="reference internal" href="library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> de um <a class="reference internal" href="library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>. Outras operações exigem que os dados binários sejam armazenados em objetos imutáveis (“objetos byte ou similar para somente leitura”); exemplos disso incluem <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> e a <a class="reference internal" href="library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> de um objeto <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>.</p>
</dd>
<dt id="term-bytecode">bytecode</dt><dd><p>O código-fonte Python é compilado para bytecode, a representação interna de um programa em Python no interpretador CPython. O bytecode também é mantido em cache em arquivos <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> e <code class="docutils literal notranslate"><span class="pre">.pyo</span></code>, de forma que executar um mesmo arquivo é mais rápido na segunda vez (a recompilação dos fontes para bytecode não é necessária). Esta “linguagem intermediária” é adequada para execução em uma <a class="reference internal" href="#term-virtual-machine"><span class="xref std std-term">máquina virtual</span></a>, que executa o código de máquina correspondente para cada bytecode. Tenha em mente que não se espera que bytecodes sejam executados entre máquinas virtuais Python diferentes, nem que se mantenham estáveis entre versões de Python.</p>
<p>Uma lista de instruções bytecode pode ser encontrada na documentação para <a class="reference internal" href="library/dis.html#bytecodes"><span class="std std-ref">o módulo dis</span></a>.</p>
</dd>
<dt id="term-callback">função de retorno</dt><dd><p>Também conhecida como callback, é uma função sub-rotina que é passada como um argumento a ser executado em algum ponto no futuro.</p>
</dd>
<dt id="term-class">classe</dt><dd><p>Um modelo para criação de objetos definidos pelo usuário. Definições de classe normalmente contém definições de métodos que operam sobre instâncias da classe.</p>
</dd>
<dt id="term-class-variable">variável de classe</dt><dd><p>Uma variável definida em uma classe e destinada a ser modificada apenas no nível da classe (ou seja, não em uma instância da classe).</p>
</dd>
<dt id="term-coercion">coerção</dt><dd><p>A conversão implícita de uma instância de um tipo para outro durante uma operação que envolve dois argumentos do mesmo tipo. Por exemplo, <code class="docutils literal notranslate"><span class="pre">int(3.15)</span></code> converte o número do ponto flutuante no número inteiro <code class="docutils literal notranslate"><span class="pre">3</span></code>, mas em <code class="docutils literal notranslate"><span class="pre">3+4.5</span></code>, cada argumento é de um tipo diferente (um int, um float), e ambos devem ser convertidos para o mesmo tipo antes de poderem ser adicionados ou isso levantará um <a class="reference internal" href="library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>. Sem coerção, todos os argumentos de tipos compatíveis teriam que ser normalizados com o mesmo valor pelo programador, por exemplo, <code class="docutils literal notranslate"><span class="pre">float(3)+4.5</span></code> em vez de apenas <code class="docutils literal notranslate"><span class="pre">3+4.5</span></code>.</p>
</dd>
<dt id="term-complex-number">número complexo</dt><dd><p>Uma extensão ao familiar sistema de números reais em que todos os números são expressos como uma soma de uma parte real e uma parte imaginária. Números imaginários são múltiplos reais da unidade imaginária (a raiz quadrada de <code class="docutils literal notranslate"><span class="pre">-1</span></code>), normalmente escrita como <code class="docutils literal notranslate"><span class="pre">i</span></code> em matemática ou <code class="docutils literal notranslate"><span class="pre">j</span></code> em engenharia. O Python tem suporte nativo para números complexos, que são escritos com esta última notação; a parte imaginária escrita com um sufixo <code class="docutils literal notranslate"><span class="pre">j</span></code>, p.ex., <code class="docutils literal notranslate"><span class="pre">3+1j</span></code>. Para ter acesso aos equivalentes para números complexos do módulo <a class="reference internal" href="library/math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code></a>, utilize <a class="reference internal" href="library/cmath.html#module-cmath" title="cmath: Mathematical functions for complex numbers."><code class="xref py py-mod docutils literal notranslate"><span class="pre">cmath</span></code></a>. O uso de números complexos é uma funcionalidade matemática bastante avançada. Se você não sabe se irá precisar deles, é quase certo que você pode ignorá-los sem problemas.</p>
</dd>
<dt id="term-context-manager">gerenciador de contexto</dt><dd><p>Um objeto que controla o ambiente visto numa instrução <a class="reference internal" href="reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> por meio da definição dos métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code> e <code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code>. Veja <span class="target" id="index-83"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0343"><strong>PEP 343</strong></a>.</p>
</dd>
<dt id="term-context-variable">variável de contexto</dt><dd><p>Uma variável que pode ter valores diferentes, dependendo do seu contexto. Isso é semelhante ao armazenamento local de threads, no qual cada thread pode ter um valor diferente para uma variável. No entanto, com variáveis de contexto, pode haver vários contextos em uma thread e o principal uso para variáveis de contexto é acompanhar as variáveis em tarefas assíncronas simultâneas. Veja <a class="reference internal" href="library/contextvars.html#module-contextvars" title="contextvars: Context Variables"><code class="xref py py-mod docutils literal notranslate"><span class="pre">contextvars</span></code></a>.</p>
</dd>
<dt id="term-contiguous">contíguo</dt><dd><p id="index-10">Um buffer é considerado contíguo exatamente se for <em>contíguo C</em> ou <em>contíguo Fortran</em>. Os buffers de dimensão zero são contíguos C e Fortran. Em vetores unidimensionais, os itens devem ser dispostos na memória próximos um do outro, em ordem crescente de índices, começando do zero. Em vetores multidimensionais contíguos C, o último índice varia mais rapidamente ao visitar itens em ordem de endereço de memória. No entanto, nos vetores contíguos do Fortran, o primeiro índice varia mais rapidamente.</p>
</dd>
<dt id="term-coroutine">corrotina</dt><dd><p>Corrotinas são uma forma mais generalizada de sub-rotinas. Sub-rotinas tem a entrada iniciada em um ponto, e a saída em outro ponto. Corrotinas podem entrar, sair, e continuar em muitos pontos diferentes. Elas podem ser implementadas com a instrução <a class="reference internal" href="reference/compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a>. Veja também <span class="target" id="index-84"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0492"><strong>PEP 492</strong></a>.</p>
</dd>
<dt id="term-coroutine-function">função de corrotina</dt><dd><p>Uma função que retorna um objeto do tipo <a class="reference internal" href="#term-coroutine"><span class="xref std std-term">corrotina</span></a>. Uma função de corrotina pode ser definida com a instrução <a class="reference internal" href="reference/compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a>, e pode conter as palavras chaves <a class="reference internal" href="reference/expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a>, <a class="reference internal" href="reference/compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a>, e <a class="reference internal" href="reference/compound_stmts.html#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a>. Isso foi introduzido pela <span class="target" id="index-85"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0492"><strong>PEP 492</strong></a>.</p>
</dd>
<dt id="term-CPython">CPython</dt><dd><p>A implementação canônica da linguagem de programação Python, como disponibilizada pelo <a class="reference external" href="https://www.python.org">python.org</a>. O termo “CPython” é usado quando necessário distinguir esta implementação de outras como Jython ou IronPython.</p>
</dd>
<dt id="term-decorator">decorador</dt><dd><p>Uma função que retorna outra função, geralmente aplicada como uma transformação de função usando a sintaxe <code class="docutils literal notranslate"><span class="pre">&#64;wrapper</span></code>. Exemplos comuns para decoradores são <a class="reference internal" href="library/functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod()</span></code></a> e <a class="reference internal" href="library/functions.html#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">staticmethod()</span></code></a>.</p>
<p>A sintaxe do decorador é meramente um açúcar sintático, as duas definições de funções a seguir são semanticamente equivalentes:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="o">...</span>
<span class="n">f</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

<span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>O mesmo conceito existe para as classes, mas não é comumente utilizado. Veja a documentação de <a class="reference internal" href="reference/compound_stmts.html#function"><span class="std std-ref">definições de função</span></a> e <a class="reference internal" href="reference/compound_stmts.html#class"><span class="std std-ref">definições de classe</span></a> para obter mais informações sobre decoradores.</p>
</dd>
<dt id="term-descriptor">descritor</dt><dd><p>Qualquer objeto que define os métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code> ou <code class="xref py py-meth docutils literal notranslate"><span class="pre">__delete__()</span></code>. Quando um atributo de classe é um descritor, seu comportamento de associação especial é acionado no acesso a um atributo. Normalmente, ao se utilizar <em>a.b</em> para se obter, definir ou excluir, um atributo dispara uma busca no objeto chamado <em>b</em> no dicionário de classe de <em>a</em>, mas se <em>b</em> for um descritor, o respectivo método descritor é chamado. Compreender descritores é a chave para um profundo entendimento de Python pois eles são a base de muitas funcionalidades incluindo funções, métodos, propriedades, métodos de classe, métodos estáticos e referências para superclasses.</p>
<p>Para obter mais informações sobre os métodos dos descritores, veja: <a class="reference internal" href="reference/datamodel.html#descriptors"><span class="std std-ref">Implementando descritores</span></a> ou o <a class="reference internal" href="howto/descriptor.html#descriptorhowto"><span class="std std-ref">Guia de Descritores</span></a>.</p>
</dd>
<dt id="term-dictionary">dicionário</dt><dd><p>Um vetor associativo em que chaves arbitrárias são mapeadas para valores. As chaves podem ser quaisquer objetos que possuam os métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code> e <code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code>. Dicionários são estruturas chamadas de hash na linguagem Perl.</p>
</dd>
<dt id="term-dictionary-comprehension">compreensão de dicionário</dt><dd><p>Uma maneira compacta de processar todos ou parte dos elementos de um iterável e retornar um dicionário com os resultados. <code class="docutils literal notranslate"><span class="pre">results</span> <span class="pre">=</span> <span class="pre">{n:</span> <span class="pre">n</span> <span class="pre">**</span> <span class="pre">2</span> <span class="pre">for</span> <span class="pre">n</span> <span class="pre">in</span> <span class="pre">range(10)}</span></code> gera um dicionário contendo a chave <code class="docutils literal notranslate"><span class="pre">n</span></code> mapeada para o valor <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">**</span> <span class="pre">2</span></code>. Veja <a class="reference internal" href="reference/expressions.html#comprehensions"><span class="std std-ref">Displays for lists, sets and dictionaries</span></a>.</p>
</dd>
<dt id="term-dictionary-view">visão de dicionário</dt><dd><p>Os objetos retornados por <a class="reference internal" href="library/stdtypes.html#dict.keys" title="dict.keys"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.keys()</span></code></a>, <a class="reference internal" href="library/stdtypes.html#dict.values" title="dict.values"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.values()</span></code></a> e <a class="reference internal" href="library/stdtypes.html#dict.items" title="dict.items"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.items()</span></code></a> são chamados de visões de dicionário. Eles fornecem uma visão dinâmica das entradas do dicionário, o que significa que quando o dicionário é alterado, a visão reflete essas alterações. Para forçar a visão de dicionário a se tornar uma lista completa use <code class="docutils literal notranslate"><span class="pre">list(dictview)</span></code>. Veja <a class="reference internal" href="library/stdtypes.html#dict-views"><span class="std std-ref">Objetos de visão de dicionário</span></a>.</p>
</dd>
<dt id="term-docstring">docstring</dt><dd><p>Abreviatura de “documentation string” (string de documentação). Uma string literal que aparece como primeira expressão numa classe, função ou módulo. Ainda que sejam ignoradas quando a suíte é executada, é reconhecida pelo compilador que a coloca no atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code> da classe, função ou módulo que a encapsula. Como ficam disponíveis por meio de introspecção, docstrings são o lugar canônico para documentação do objeto.</p>
</dd>
<dt id="term-duck-typing">tipagem pato</dt><dd><p>Também conhecida como <em>duck-typing</em>, é um estilo de programação que não verifica o tipo do objeto para determinar se ele possui a interface correta; em vez disso, o método ou atributo é simplesmente chamado ou utilizado (“Se se parece com um pato e grasna como um pato, então deve ser um pato.”) Enfatizando interfaces ao invés de tipos específicos, o código bem desenvolvido aprimora sua flexibilidade por permitir substituição polimórfica. Tipagem pato evita necessidade de testes que usem <a class="reference internal" href="library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a> ou <a class="reference internal" href="library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a>. (Note, porém, que a tipagem pato pode ser complementada com o uso de <a class="reference internal" href="#term-abstract-base-class"><span class="xref std std-term">classes base abstratas</span></a>.) Ao invés disso, são normalmente empregados testes <a class="reference internal" href="library/functions.html#hasattr" title="hasattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">hasattr()</span></code></a> ou programação <a class="reference internal" href="#term-EAFP"><span class="xref std std-term">EAFP</span></a>.</p>
</dd>
<dt id="term-EAFP">EAFP</dt><dd><p>Iniciais da expressão em inglês “easier to ask for forgiveness than permission” que significa “é mais fácil pedir perdão que permissão”. Este estilo de codificação comum em Python assume a existência de chaves ou atributos válidos e captura exceções caso essa premissa se prove falsa. Este estilo limpo e rápido se caracteriza pela presença de várias instruções <a class="reference internal" href="reference/compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> e <a class="reference internal" href="reference/compound_stmts.html#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a>. A técnica diverge do estilo <a class="reference internal" href="#term-LBYL"><span class="xref std std-term">LBYL</span></a>, comum em outras linguagens como C, por exemplo.</p>
</dd>
<dt id="term-expression">expressão</dt><dd><p>Uma parte da sintaxe que pode ser avaliada para algum valor. Em outras palavras, uma expressão é a acumulação de elementos de expressão como literais, nomes, atributos de acesso, operadores ou chamadas de funções, todos os quais retornam um valor. Em contraste com muitas outras linguagens, nem todas as construções de linguagem são expressões. Também existem <a class="reference internal" href="#term-statement"><span class="xref std std-term">instruções</span></a>, as quais não podem ser usadas como expressões, como, por exemplo, <a class="reference internal" href="reference/compound_stmts.html#while"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">while</span></code></a>. Atribuições também são instruções, não expressões.</p>
</dd>
<dt id="term-extension-module">módulo de extensão</dt><dd><p>Um módulo escrito em C ou C++, usando a API C do Python para interagir tanto com código de usuário quanto do núcleo.</p>
</dd>
<dt id="term-f-string">f-string</dt><dd><p>Literais string prefixadas com <code class="docutils literal notranslate"><span class="pre">'f'</span></code> ou <code class="docutils literal notranslate"><span class="pre">'F'</span></code> são conhecidas como “f-strings” que é uma abreviação de <a class="reference internal" href="reference/lexical_analysis.html#f-strings"><span class="std std-ref">formatted string literals</span></a>. Veja também <span class="target" id="index-86"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0498"><strong>PEP 498</strong></a>.</p>
</dd>
<dt id="term-file-object">objeto arquivo</dt><dd><p>Um objeto que expõe uma API orientada a arquivos (com métodos tais como <code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code> ou <code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code>) para um recurso subjacente. Dependendo da maneira como foi criado, um objeto arquivo pode mediar o acesso a um arquivo real no disco ou outro tipo de dispositivo de armazenamento ou de comunicação (por exemplo a entrada/saída padrão, buffers em memória, soquetes, pipes, etc.). Objetos arquivo também são chamados de <em class="dfn">objetos arquivo ou similares</em> ou <em class="dfn">fluxos</em>.</p>
<p>Atualmente há três categorias de objetos arquivo: <a class="reference internal" href="#term-binary-file"><span class="xref std std-term">arquivos binários</span></a> brutos, <a class="reference internal" href="#term-binary-file"><span class="xref std std-term">arquivos binários</span></a> em buffer e <a class="reference internal" href="#term-text-file"><span class="xref std std-term">arquivos textos</span></a>. Suas interfaces estão definidas no módulo <a class="reference internal" href="library/io.html#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">io</span></code></a>. A forma canônica para criar um objeto arquivo é usando a função <a class="reference internal" href="library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a>.</p>
</dd>
<dt id="term-file-like-object">objeto arquivo ou similar</dt><dd><p>Um sinônimo do termo <a class="reference internal" href="#term-file-object"><span class="xref std std-term">objeto arquivo</span></a>.</p>
</dd>
<dt id="term-filesystem-encoding-and-error-handler">tratador de erros e codificação do sistema de arquivos</dt><dd><p>Tratador de erros e codificação usado pelo Python para decodificar bytes do sistema operacional e codificar Unicode para o sistema operacional.</p>
<p>A codificação do sistema de arquivos deve garantir a decodificação bem-sucedida de todos os bytes abaixo de 128. Se a codificação do sistema de arquivos falhar em fornecer essa garantia, as funções da API podem levantar <a class="reference internal" href="library/exceptions.html#UnicodeError" title="UnicodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeError</span></code></a>.</p>
<p>As funções <a class="reference internal" href="library/sys.html#sys.getfilesystemencoding" title="sys.getfilesystemencoding"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.getfilesystemencoding()</span></code></a> e <a class="reference internal" href="library/sys.html#sys.getfilesystemencodeerrors" title="sys.getfilesystemencodeerrors"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.getfilesystemencodeerrors()</span></code></a> podem ser usadas para obter o tratador de erros e codificação do sistema de arquivos.</p>
<p>O <a class="reference internal" href="#term-filesystem-encoding-and-error-handler"><span class="xref std std-term">tratador de erros e codificação do sistema de arquivos</span></a> são configurados na inicialização do Python pela função <code class="xref c c-func docutils literal notranslate"><span class="pre">PyConfig_Read()</span></code>: veja os membros <a class="reference internal" href="c-api/init_config.html#c.PyConfig.filesystem_encoding" title="PyConfig.filesystem_encoding"><code class="xref c c-member docutils literal notranslate"><span class="pre">filesystem_encoding</span></code></a> e <a class="reference internal" href="c-api/init_config.html#c.PyConfig.filesystem_errors" title="PyConfig.filesystem_errors"><code class="xref c c-member docutils literal notranslate"><span class="pre">filesystem_errors</span></code></a> do <a class="reference internal" href="c-api/init_config.html#c.PyConfig" title="PyConfig"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyConfig</span></code></a>.</p>
<p>Veja também <a class="reference internal" href="#term-locale-encoding"><span class="xref std std-term">codificação da localidade</span></a>.</p>
</dd>
<dt id="term-finder">localizador</dt><dd><p>Um objeto que tenta encontrar o <a class="reference internal" href="#term-loader"><span class="xref std std-term">carregador</span></a> para um módulo que está sendo importado.</p>
<p>Desde o Python 3.3, existem dois tipos de localizador: <a class="reference internal" href="#term-meta-path-finder"><span class="xref std std-term">localizadores de metacaminho</span></a> para uso com <a class="reference internal" href="library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a>, e <a class="reference internal" href="#term-path-entry-finder"><span class="xref std std-term">localizadores de entrada de caminho</span></a> para uso com <a class="reference internal" href="library/sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a>.</p>
<p>Veja <span class="target" id="index-87"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a>, <span class="target" id="index-88"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0420"><strong>PEP 420</strong></a> e <span class="target" id="index-89"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0451"><strong>PEP 451</strong></a> para mais informações.</p>
</dd>
<dt id="term-floor-division">divisão pelo piso</dt><dd><p>Divisão matemática que arredonda para baixo para o inteiro mais próximo. O operador de divisão pelo piso é <code class="docutils literal notranslate"><span class="pre">//</span></code>. Por exemplo, a expressão <code class="docutils literal notranslate"><span class="pre">11</span> <span class="pre">//</span> <span class="pre">4</span></code> retorna o valor <code class="docutils literal notranslate"><span class="pre">2</span></code> ao invés de <code class="docutils literal notranslate"><span class="pre">2.75</span></code>, que seria retornado pela divisão de ponto flutuante. Note que <code class="docutils literal notranslate"><span class="pre">(-11)</span> <span class="pre">//</span> <span class="pre">4</span></code> é <code class="docutils literal notranslate"><span class="pre">-3</span></code> porque é <code class="docutils literal notranslate"><span class="pre">-2.75</span></code> arredondado <em>para baixo</em>. Consulte a <span class="target" id="index-90"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0238"><strong>PEP 238</strong></a>.</p>
</dd>
<dt id="term-function">função</dt><dd><p>Uma série de instruções que retorna algum valor para um chamador. Também pode ser passado zero ou mais <a class="reference internal" href="#term-argument"><span class="xref std std-term">argumentos</span></a> que podem ser usados na execução do corpo. Veja também <a class="reference internal" href="#term-parameter"><span class="xref std std-term">parâmetro</span></a>, <a class="reference internal" href="#term-method"><span class="xref std std-term">método</span></a> e a seção <a class="reference internal" href="reference/compound_stmts.html#function"><span class="std std-ref">Definições de função</span></a>.</p>
</dd>
<dt id="term-function-annotation">anotação de função</dt><dd><p>Uma <a class="reference internal" href="#term-annotation"><span class="xref std std-term">anotação</span></a> de um parâmetro de função ou valor de retorno.</p>
<p>Anotações de função são comumente usados por <a class="reference internal" href="#term-type-hint"><span class="xref std std-term">dicas de tipo</span></a>: por exemplo, essa função espera receber dois argumentos <a class="reference internal" href="library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> e também é esperado que devolva um valor <a class="reference internal" href="library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">sum_two_numbers</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
   <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</pre></div>
</div>
<p>A sintaxe de anotação de função é explicada na seção <a class="reference internal" href="reference/compound_stmts.html#function"><span class="std std-ref">Definições de função</span></a>.</p>
<p>Veja <a class="reference internal" href="#term-variable-annotation"><span class="xref std std-term">anotação de variável</span></a> e <span class="target" id="index-91"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a>, que descrevem esta funcionalidade. Veja também <a class="reference internal" href="howto/annotations.html#annotations-howto"><span class="std std-ref">Annotations Best Practices</span></a> para as melhores práticas sobre como trabalhar com anotações.</p>
</dd>
<dt id="term-__future__">__future__</dt><dd><p>A <a class="reference internal" href="reference/simple_stmts.html#future"><span class="std std-ref">future statement</span></a>, <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">&lt;feature&gt;</span></code>,
directs the compiler to compile the current module using syntax or
semantics that will become standard in a future release of Python.
The <a class="reference internal" href="library/__future__.html#module-__future__" title="__future__: Future statement definitions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">__future__</span></code></a> module documents the possible values of
<em>feature</em>.  By importing this module and evaluating its variables,
you can see when a new feature was first added to the language and
when it will (or did) become the default:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">__future__</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__future__</span><span class="o">.</span><span class="n">division</span>
<span class="go">_Feature((2, 2, 0, &#39;alpha&#39;, 2), (3, 0, 0, &#39;alpha&#39;, 0), 8192)</span>
</pre></div>
</div>
</dd>
<dt id="term-garbage-collection">coleta de lixo</dt><dd><p>Também conhecido como <em>garbage collection</em>, é o processo de liberar a memória quando ela não é mais utilizada. Python executa a liberação da memória através da contagem de referências e um coletor de lixo cíclico que é capaz de detectar e interromper referências cíclicas. O coletor de lixo pode ser controlado usando o módulo <a class="reference internal" href="library/gc.html#module-gc" title="gc: Interface to the cycle-detecting garbage collector."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gc</span></code></a>.</p>
</dd>
<dt id="index-19"><span id="term-generator"></span>gerador</dt><dd><p>Uma função que retorna um <a class="reference internal" href="#term-generator-iterator"><span class="xref std std-term">iterador gerador</span></a>. É parecida com uma função normal, exceto pelo fato de conter expressões <a class="reference internal" href="reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> para produzir uma série de valores que podem ser usados em um laço “for” ou que podem ser obtidos um de cada vez com a função <a class="reference internal" href="library/functions.html#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a>.</p>
<p>Normalmente refere-se a uma função geradora, mas pode referir-se a um <em>iterador gerador</em> em alguns contextos. Em alguns casos onde o significado desejado não está claro, usar o termo completo evita ambiguidade.</p>
</dd>
<dt id="term-generator-iterator">iterador gerador</dt><dd><p>Um objeto criado por uma função <a class="reference internal" href="#term-generator"><span class="xref std std-term">geradora</span></a>.</p>
<p>Cada <a class="reference internal" href="reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> suspende temporariamente o processamento, memorizando o estado da execução local (incluindo variáveis locais e instruções try pendentes). Quando o <em>iterador gerador</em> retorna, ele se recupera do último ponto onde estava (em contrapartida as funções que iniciam uma nova execução a cada vez que são invocadas).</p>
</dd>
<dt id="index-20"><span id="term-generator-expression"></span>expressão geradora</dt><dd><p>Uma expressão que retorna um iterador. Parece uma expressão normal, seguido de uma cláusula <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> definindo uma variável de loop, um range, e uma cláusula <code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code> opcional. A expressão combinada gera valores para uma função encapsuladora:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>         <span class="c1"># sum of squares 0, 1, 4, ... 81</span>
<span class="go">285</span>
</pre></div>
</div>
</dd>
<dt id="term-generic-function">função genérica</dt><dd><p>Uma função composta por várias funções implementando a mesma operação para diferentes tipos. Qual implementação deverá ser usada durante a execução é determinada pelo algoritmo de despacho.</p>
<p>Veja também a entrada <a class="reference internal" href="#term-single-dispatch"><span class="xref std std-term">despacho único</span></a> no glossário, o decorador <a class="reference internal" href="library/functools.html#functools.singledispatch" title="functools.singledispatch"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.singledispatch()</span></code></a>, e a <span class="target" id="index-92"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0443"><strong>PEP 443</strong></a>.</p>
</dd>
<dt id="term-generic-type">tipo genérico</dt><dd><p>A <a class="reference internal" href="#term-type"><span class="xref std std-term">type</span></a> that can be parameterized; typically a
<a class="reference internal" href="reference/datamodel.html#sequence-types"><span class="std std-ref">container class</span></a> such as <a class="reference internal" href="library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> or
<a class="reference internal" href="library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>. Used for <a class="reference internal" href="#term-type-hint"><span class="xref std std-term">type hints</span></a> and
<a class="reference internal" href="#term-annotation"><span class="xref std std-term">annotations</span></a>.</p>
<p>For more details, see <a class="reference internal" href="library/stdtypes.html#types-genericalias"><span class="std std-ref">generic alias types</span></a>,
<span class="target" id="index-22"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0483"><strong>PEP 483</strong></a>, <span class="target" id="index-23"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a>, <span class="target" id="index-24"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a>, and the <a class="reference internal" href="library/typing.html#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a> module.</p>
</dd>
<dt id="term-GIL">GIL</dt><dd><p>Veja <a class="reference internal" href="#term-global-interpreter-lock"><span class="xref std std-term">bloqueio global do interpretador</span></a>.</p>
</dd>
<dt id="term-global-interpreter-lock">bloqueio global do interpretador</dt><dd><p>O mecanismo utilizado pelo interpretador <a class="reference internal" href="#term-CPython"><span class="xref std std-term">CPython</span></a> para garantir que apenas uma thread execute o <a class="reference internal" href="#term-bytecode"><span class="xref std std-term">bytecode</span></a> Python por vez. Isto simplifica a implementação do CPython ao fazer com que o modelo de objetos (incluindo tipos embutidos críticos como o <a class="reference internal" href="library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>) ganhem segurança implícita contra acesso concorrente. Travar todo o interpretador facilita que o interpretador em si seja multitarefa, às custas de muito do paralelismo já provido por máquinas multiprocessador.</p>
<p>No entanto, alguns módulos de extensão, tanto da biblioteca padrão quanto de terceiros, são desenvolvidos de forma a liberar o GIL ao realizar tarefas computacionalmente muito intensas, como compactação ou cálculos de hash. Além disso, o GIL é sempre liberado nas operações de E/S.</p>
<p>No passado, esforços para criar um interpretador que lidasse plenamente com threads (travando dados compartilhados numa granularidade bem mais fina) não foram bem sucedidos devido a queda no desempenho ao serem executados em processadores de apenas um núcleo. Acredita-se que superar essa questão de desempenho acabaria tornando a implementação muito mais complicada e bem mais difícil de manter.</p>
</dd>
<dt id="term-hash-based-pyc">pyc baseado em hash</dt><dd><p>Um arquivo de cache em bytecode que usa hash ao invés do tempo, no qual o arquivo de código-fonte foi modificado pela última vez, para determinar a sua validade. Veja <a class="reference internal" href="reference/import.html#pyc-invalidation"><span class="std std-ref">Cached bytecode invalidation</span></a>.</p>
</dd>
<dt id="term-hashable">hasheável</dt><dd><p>Um objeto é <em>hasheável</em> se tem um valor de hash que nunca muda durante seu ciclo de vida (precisa ter um método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code>) e pode ser comparado com outros objetos (precisa ter um método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code>). Objetos hasheáveis que são comparados como iguais devem ter o mesmo valor de hash.</p>
<p>A hasheabilidade faz com que um objeto possa ser usado como uma chave de dicionário e como um membro de conjunto, pois estas estruturas de dados utilizam os valores de hash internamente.</p>
<p>A maioria dos objetos embutidos imutáveis do Python são hasheáveis; containers mutáveis (tais como listas ou dicionários) não são; containers imutáveis (tais como tuplas e frozensets) são hasheáveis apenas se os seus elementos são hasheáveis. Objetos que são instâncias de classes definidas pelo usuário são hasheáveis por padrão. Todos eles comparam de forma desigual (exceto entre si mesmos), e o seu valor hash é derivado a partir do seu <a class="reference internal" href="library/functions.html#id" title="id"><code class="xref py py-func docutils literal notranslate"><span class="pre">id()</span></code></a>.</p>
</dd>
<dt id="term-IDLE">IDLE</dt><dd><p>Um ambiente de desenvolvimento integrado para Python. IDLE é um editor básico e um ambiente interpretador que vem junto com a distribuição padrão do Python.</p>
</dd>
<dt id="term-immutable">imutável</dt><dd><p>Um objeto que possui um valor fixo. Objetos imutáveis incluem números, strings e tuplas. Estes objetos não podem ser alterados. Um novo objeto deve ser criado se um valor diferente tiver de ser armazenado. Objetos imutáveis têm um papel importante em lugares onde um valor constante de hash seja necessário, como por exemplo uma chave em um dicionário.</p>
</dd>
<dt id="term-import-path">caminho de importação</dt><dd><p>Uma lista de localizações (ou <a class="reference internal" href="#term-path-entry"><span class="xref std std-term">entradas de caminho</span></a>) que são buscadas pelo <a class="reference internal" href="#term-path-based-finder"><span class="xref std std-term">localizador baseado no caminho</span></a> por módulos para importar. Durante a importação, esta lista de localizações usualmente vem a partir de <a class="reference internal" href="library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a>, mas para subpacotes ela também pode vir do atributo <code class="docutils literal notranslate"><span class="pre">__path__</span></code> de pacotes-pai.</p>
</dd>
<dt id="term-importing">importação</dt><dd><p>O processo pelo qual o código Python em um módulo é disponibilizado para o código Python em outro módulo.</p>
</dd>
<dt id="term-importer">importador</dt><dd><p>Um objeto que localiza e carrega um módulo; Tanto um <a class="reference internal" href="#term-finder"><span class="xref std std-term">localizador</span></a> e o objeto <a class="reference internal" href="#term-loader"><span class="xref std std-term">carregador</span></a>.</p>
</dd>
<dt id="term-interactive">interativo</dt><dd><p>Python tem um interpretador interativo, o que significa que você pode digitar instruções e expressões no prompt do interpretador, executá-los imediatamente e ver seus resultados. Apenas execute <code class="docutils literal notranslate"><span class="pre">python</span></code> sem argumentos (possivelmente selecionando-o a partir do menu de aplicações de seu sistema operacional). O interpretador interativo é uma maneira poderosa de testar novas ideias ou aprender mais sobre módulos e pacotes (lembre-se do comando <code class="docutils literal notranslate"><span class="pre">help(x)</span></code>).</p>
</dd>
<dt id="term-interpreted">interpretado</dt><dd><p>Python é uma linguagem interpretada, em oposição àquelas que são compiladas, embora esta distinção possa ser nebulosa devido à presença do compilador de bytecode. Isto significa que os arquivos-fontes podem ser executados diretamente sem necessidade explícita de se criar um arquivo executável. Linguagens interpretadas normalmente têm um ciclo de desenvolvimento/depuração mais curto que as linguagens compiladas, apesar de seus programas geralmente serem executados mais lentamente. Veja também <a class="reference internal" href="#term-interactive"><span class="xref std std-term">interativo</span></a>.</p>
</dd>
<dt id="term-interpreter-shutdown">desligamento do interpretador</dt><dd><p>Quando solicitado para desligar, o interpretador Python entra em uma fase especial, onde ele gradualmente libera todos os recursos alocados, tais como módulos e várias estruturas internas críticas. Ele também faz diversas chamadas para o <a class="reference internal" href="#term-garbage-collection"><span class="xref std std-term">coletor de lixo</span></a>. Isto pode disparar a execução de código em destrutores definidos pelo usuário ou função de retorno de referência fraca. Código executado durante a fase de desligamento pode encontrar diversas exceções, pois os recursos que ele depende podem não funcionar mais (exemplos comuns são os módulos de bibliotecas, ou os mecanismos de avisos).</p>
<p>A principal razão para o interpretador desligar, é que o módulo <code class="docutils literal notranslate"><span class="pre">__main__</span></code> ou o script sendo executado terminou sua execução.</p>
</dd>
<dt id="term-iterable">iterável</dt><dd><p>Um objeto capaz de retornar seus membros um de cada vez. Exemplos de iteráveis incluem todos os tipos de sequência (tais como <a class="reference internal" href="library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>, <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> e <a class="reference internal" href="library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>) e alguns tipos não sequenciais como <a class="reference internal" href="library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>, <a class="reference internal" href="#term-file-object"><span class="xref std std-term">objeto arquivo</span></a>, e objetos de qualquer classe que você definir com um método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code> ou com um método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code> que implemente a semântica de <a class="reference internal" href="#term-sequence"><span class="xref std std-term">Sequência</span></a>.</p>
<p>Iteráveis podem ser usados em um laço <a class="reference internal" href="reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> e em vários outros lugares em que uma sequência é necessária (<a class="reference internal" href="library/functions.html#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a>, <a class="reference internal" href="library/functions.html#map" title="map"><code class="xref py py-func docutils literal notranslate"><span class="pre">map()</span></code></a>, …). Quando um objeto iterável é passado como argumento para a função nativa <a class="reference internal" href="library/functions.html#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a>, ela retorna um iterador para o objeto. Este iterador é adequado para se varrer todo o conjunto de valores. Ao usar iteráveis, normalmente não é necessário chamar <a class="reference internal" href="library/functions.html#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a> ou lidar com os objetos iteradores em si. A instrução <code class="docutils literal notranslate"><span class="pre">for</span></code> faz isso automaticamente para você, criando uma variável temporária para armazenar o iterador durante a execução do laço. Veja também <a class="reference internal" href="#term-iterator"><span class="xref std std-term">iterador</span></a>, <a class="reference internal" href="#term-sequence"><span class="xref std std-term">sequência</span></a>, e <a class="reference internal" href="#term-generator"><span class="xref std std-term">gerador</span></a>.</p>
</dd>
<dt id="term-iterator">iterador</dt><dd><p>Um objeto que representa um fluxo de dados. Repetidas chamadas ao método <a class="reference internal" href="library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> de um iterador (ou passando o objeto para a função embutida <a class="reference internal" href="library/functions.html#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a>) vão retornar itens sucessivos do fluxo. Quando não houver mais dados disponíveis uma exceção <a class="reference internal" href="library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> exception será levantada. Neste ponto, o objeto iterador se esgotou e quaisquer chamadas subsequentes a seu método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code> vão apenas levantar a exceção <a class="reference internal" href="library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> novamente. Iteradores precisam ter um método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code> que retorne o objeto iterador em si, de forma que todo iterador também é iterável e pode ser usado na maioria dos lugares em que um iterável é requerido. Uma notável exceção é código que tenta realizar passagens em múltiplas iterações. Um objeto contêiner (como uma <a class="reference internal" href="library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>) produz um novo iterador a cada vez que você passá-lo para a função <a class="reference internal" href="library/functions.html#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a> ou utilizá-lo em um laço <a class="reference internal" href="reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a>. Tentar isso com o mesmo iterador apenas iria retornar o mesmo objeto iterador esgotado já utilizado na iteração anterior, como se fosse um contêiner vazio.</p>
<p>Mais informações podem ser encontradas em <a class="reference internal" href="library/stdtypes.html#typeiter"><span class="std std-ref">Tipos iteradores</span></a>.</p>
<div class="impl-detail compound">
<p><strong>CPython implementation detail:</strong> CPython does not consistently apply the requirement that an iterator
define <code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code>.</p>
</div>
</dd>
<dt id="term-key-function">função chave</dt><dd><p>Uma função chave ou função colação é um chamável que retorna um valor usado para ordenação ou classificação. Por exemplo, <a class="reference internal" href="library/locale.html#locale.strxfrm" title="locale.strxfrm"><code class="xref py py-func docutils literal notranslate"><span class="pre">locale.strxfrm()</span></code></a> é usada para produzir uma chave de ordenação que leva o locale em consideração para fins de ordenação.</p>
<p>Uma porção de ferramentas em Python aceitam funções chave para controlar como os elementos são ordenados ou agrupados. Algumas delas incluem <a class="reference internal" href="library/functions.html#min" title="min"><code class="xref py py-func docutils literal notranslate"><span class="pre">min()</span></code></a>, <a class="reference internal" href="library/functions.html#max" title="max"><code class="xref py py-func docutils literal notranslate"><span class="pre">max()</span></code></a>, <a class="reference internal" href="library/functions.html#sorted" title="sorted"><code class="xref py py-func docutils literal notranslate"><span class="pre">sorted()</span></code></a>, <a class="reference internal" href="library/stdtypes.html#list.sort" title="list.sort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">list.sort()</span></code></a>, <a class="reference internal" href="library/heapq.html#heapq.merge" title="heapq.merge"><code class="xref py py-func docutils literal notranslate"><span class="pre">heapq.merge()</span></code></a>, <a class="reference internal" href="library/heapq.html#heapq.nsmallest" title="heapq.nsmallest"><code class="xref py py-func docutils literal notranslate"><span class="pre">heapq.nsmallest()</span></code></a>, <a class="reference internal" href="library/heapq.html#heapq.nlargest" title="heapq.nlargest"><code class="xref py py-func docutils literal notranslate"><span class="pre">heapq.nlargest()</span></code></a> e <a class="reference internal" href="library/itertools.html#itertools.groupby" title="itertools.groupby"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.groupby()</span></code></a>.</p>
<p>Há várias maneiras de se criar funções chave. Por exemplo, o método <a class="reference internal" href="library/stdtypes.html#str.lower" title="str.lower"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.lower()</span></code></a> pode servir como uma função chave para ordenações insensíveis à caixa. Alternativamente, uma função chave ad-hoc pode ser construída a partir de uma expressão <a class="reference internal" href="reference/expressions.html#lambda"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code></a>, como <code class="docutils literal notranslate"><span class="pre">lambda</span> <span class="pre">r:</span> <span class="pre">(r[0],</span> <span class="pre">r[2])</span></code>. Além disso, o módulo <a class="reference internal" href="library/operator.html#module-operator" title="operator: Functions corresponding to the standard operators."><code class="xref py py-mod docutils literal notranslate"><span class="pre">operator</span></code></a> dispõe de três construtores para funções chave: <a class="reference internal" href="library/operator.html#operator.attrgetter" title="operator.attrgetter"><code class="xref py py-func docutils literal notranslate"><span class="pre">attrgetter()</span></code></a>, <a class="reference internal" href="library/operator.html#operator.itemgetter" title="operator.itemgetter"><code class="xref py py-func docutils literal notranslate"><span class="pre">itemgetter()</span></code></a> e o <a class="reference internal" href="library/operator.html#operator.methodcaller" title="operator.methodcaller"><code class="xref py py-func docutils literal notranslate"><span class="pre">methodcaller()</span></code></a>. Consulte o <a class="reference internal" href="howto/sorting.html#sortinghowto"><span class="std std-ref">HowTo de Ordenação</span></a> para ver exemplos de como criar e utilizar funções chave.</p>
</dd>
<dt id="term-keyword-argument">argumento nomeado</dt><dd><p>Veja <a class="reference internal" href="#term-argument"><span class="xref std std-term">argumento</span></a>.</p>
</dd>
<dt id="term-lambda">lambda</dt><dd><p>Uma função de linha anônima consistindo de uma única <a class="reference internal" href="#term-expression"><span class="xref std std-term">expressão</span></a>, que é avaliada quando a função é chamada. A sintaxe para criar uma função lambda é <code class="docutils literal notranslate"><span class="pre">lambda</span> <span class="pre">[parameters]:</span> <span class="pre">expression</span></code></p>
</dd>
<dt id="term-LBYL">LBYL</dt><dd><p>Iniciais da expressão em inglês “look before you leap”, que significa algo como “olhe antes de pisar”. Este estilo de codificação testa as pré-condições explicitamente antes de fazer chamadas ou buscas. Este estilo contrasta com a abordagem <a class="reference internal" href="#term-EAFP"><span class="xref std std-term">EAFP</span></a> e é caracterizada pela presença de muitas instruções <a class="reference internal" href="reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a>.</p>
<p>Em um ambiente multithread, a abordagem LBYL pode arriscar a introdução de uma condição de corrida entre “o olhar” e “o pisar”. Por exemplo, o código <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">key</span> <span class="pre">in</span> <span class="pre">mapping:</span> <span class="pre">return</span> <span class="pre">mapping[key]</span></code> pode falhar se outra thread remover <em>key</em> do <em>mapping</em> após o teste, mas antes da olhada. Esse problema pode ser resolvido com bloqueios ou usando a abordagem EAFP.</p>
</dd>
<dt id="term-locale-encoding">codificação da localidade</dt><dd><p>No Unix, é a codificação da localidade do LC_CTYPE, que pode ser definida com <code class="docutils literal notranslate"><span class="pre">locale.setlocale(locale.LC_CTYPE,</span> <span class="pre">new_locale)</span></code>.</p>
<p>No Windows, é a página de código ANSI (ex: <code class="docutils literal notranslate"><span class="pre">cp1252</span></code>).</p>
<p><code class="docutils literal notranslate"><span class="pre">locale.getpreferredencoding(False)</span></code> pode ser usado para obter da codificação da localidade.</p>
<p>Python usa <a class="reference internal" href="#term-filesystem-encoding-and-error-handler"><span class="xref std std-term">tratador de erros e codificação do sistema de arquivos</span></a> para converter entre nomes de arquivos e nomes de arquivos de bytes Unicode.</p>
</dd>
<dt id="term-list">lista</dt><dd><p>Uma <a class="reference internal" href="#term-sequence"><span class="xref std std-term">sequência</span></a> embutida no Python. Apesar do seu nome, é mais próximo de um vetor em outras linguagens do que uma lista encadeada, como o acesso aos elementos é da ordem O(1).</p>
</dd>
<dt id="term-list-comprehension">compreensão de lista</dt><dd><p>Uma maneira compacta de processar todos ou parte dos elementos de uma sequência e retornar os resultados em uma lista. <code class="docutils literal notranslate"><span class="pre">result</span> <span class="pre">=</span> <span class="pre">['{:#04x}'.format(x)</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">range(256)</span> <span class="pre">if</span> <span class="pre">x</span> <span class="pre">%</span> <span class="pre">2</span> <span class="pre">==</span> <span class="pre">0]</span></code> gera uma lista de strings contendo números hexadecimais (0x..) no intervalo de 0 a 255. A cláusula <a class="reference internal" href="reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a> é opcional. Se omitida, todos os elementos no <code class="docutils literal notranslate"><span class="pre">range(256)</span></code> serão processados.</p>
</dd>
<dt id="term-loader">carregador</dt><dd><p>Um objeto que carrega um módulo. Deve definir um método chamado <code class="xref py py-meth docutils literal notranslate"><span class="pre">load_module()</span></code>. Um carregador é normalmente devolvido por um <a class="reference internal" href="#term-finder"><span class="xref std std-term">localizador</span></a>. Veja a <span class="target" id="index-93"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a> para detalhes e <a class="reference internal" href="library/importlib.html#importlib.abc.Loader" title="importlib.abc.Loader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.Loader</span></code></a> para um <a class="reference internal" href="#term-abstract-base-class"><span class="xref std std-term">classe base abstrata</span></a>.</p>
</dd>
<dt id="term-magic-method">método mágico</dt><dd><p id="index-26">Um sinônimo informal para um <a class="reference internal" href="#term-special-method"><span class="xref std std-term">método especial</span></a>.</p>
</dd>
<dt id="term-mapping">mapeamento</dt><dd><p>Um objeto contêiner que suporta buscas por chaves arbitrárias e implementa os métodos especificados em <a class="reference internal" href="library/collections.abc.html#collections-abstract-base-classes"><span class="std std-ref">classes base abstratas</span></a> <code class="xref py py-class docutils literal notranslate"><span class="pre">Mapping</span></code> ou <code class="xref py py-class docutils literal notranslate"><span class="pre">MutableMapping</span></code>. Exemplos incluem <a class="reference internal" href="library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>, <a class="reference internal" href="library/collections.html#collections.defaultdict" title="collections.defaultdict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.defaultdict</span></code></a>, <a class="reference internal" href="library/collections.html#collections.OrderedDict" title="collections.OrderedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.OrderedDict</span></code></a> e <a class="reference internal" href="library/collections.html#collections.Counter" title="collections.Counter"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.Counter</span></code></a>.</p>
</dd>
<dt id="term-meta-path-finder">localizador de metacaminho</dt><dd><p>Um <a class="reference internal" href="#term-finder"><span class="xref std std-term">localizador</span></a> retornado por uma busca de <a class="reference internal" href="library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a>. Localizadores de metacaminho são relacionados a, mas diferentes de, <a class="reference internal" href="#term-path-entry-finder"><span class="xref std std-term">localizadores de entrada de caminho</span></a>.</p>
<p>Veja <a class="reference internal" href="library/importlib.html#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.MetaPathFinder</span></code></a> para os métodos que localizadores de metacaminho implementam.</p>
</dd>
<dt id="term-metaclass">metaclasse</dt><dd><p>A classe de uma classe. Definições de classe criam um nome de classe, um dicionário de classe e uma lista de classes base. A metaclasse é responsável por receber estes três argumentos e criar a classe. A maioria das linguagens de programação orientadas a objetos provê uma implementação default. O que torna o Python especial é o fato de ser possível criar metaclasses personalizadas. A maioria dos usuários nunca vai precisar deste recurso, mas quando houver necessidade, metaclasses possibilitam soluções poderosas e elegantes. Metaclasses têm sido utilizadas para gerar registros de acesso a atributos, para incluir proteção contra acesso concorrente, rastrear a criação de objetos, implementar singletons, dentre muitas outras tarefas.</p>
<p>Mais informações podem ser encontradas em <a class="reference internal" href="reference/datamodel.html#metaclasses"><span class="std std-ref">Metaclasses</span></a>.</p>
</dd>
<dt id="term-method">método</dt><dd><p>Uma função que é definida dentro do corpo de uma classe. Se chamada como um atributo de uma instância daquela classe, o método receberá a instância do objeto como seu primeiro <a class="reference internal" href="#term-argument"><span class="xref std std-term">argumento</span></a> (que comumente é chamado de <code class="docutils literal notranslate"><span class="pre">self</span></code>). Veja <a class="reference internal" href="#term-function"><span class="xref std std-term">função</span></a> e <a class="reference internal" href="#term-nested-scope"><span class="xref std std-term">escopo aninhado</span></a>.</p>
</dd>
<dt id="term-method-resolution-order">ordem de resolução de métodos</dt><dd><p>Ordem de resolução de métodos é a ordem em que os membros de uma classe base são buscados durante a pesquisa. Veja <a class="reference external" href="https://www.python.org/download/releases/2.3/mro/">A ordem de resolução de métodos do Python 2.3</a> para detalhes do algoritmo usado pelo interpretador do Python desde a versão 2.3.</p>
</dd>
<dt id="term-module">módulo</dt><dd><p>Um objeto que serve como uma unidade organizacional de código Python. Os módulos têm um espaço de nomes contendo objetos Python arbitrários. Os módulos são carregados pelo Python através do processo de <a class="reference internal" href="#term-importing"><span class="xref std std-term">importação</span></a>.</p>
<p>Veja também <a class="reference internal" href="#term-package"><span class="xref std std-term">pacote</span></a>.</p>
</dd>
<dt id="term-module-spec">módulo spec</dt><dd><p>Um espaço de nomes que contém as informações relacionadas à importação usadas para carregar um módulo. Uma instância de <a class="reference internal" href="library/importlib.html#importlib.machinery.ModuleSpec" title="importlib.machinery.ModuleSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.machinery.ModuleSpec</span></code></a>.</p>
</dd>
<dt id="term-MRO">MRO</dt><dd><p>Veja <a class="reference internal" href="#term-method-resolution-order"><span class="xref std std-term">ordem de resolução de métodos</span></a>.</p>
</dd>
<dt id="term-mutable">mutável</dt><dd><p>Objeto mutável é aquele que pode modificar seus valor mas manter seu <a class="reference internal" href="library/functions.html#id" title="id"><code class="xref py py-func docutils literal notranslate"><span class="pre">id()</span></code></a>. Veja também <a class="reference internal" href="#term-immutable"><span class="xref std std-term">imutável</span></a>.</p>
</dd>
<dt id="term-named-tuple">tupla nomeada</dt><dd><p>O termo “tupla nomeada” é aplicado a qualquer tipo ou classe que herda de tupla e cujos elementos indexáveis também são acessíveis usando atributos nomeados. O tipo ou classe pode ter outras funcionalidades também.</p>
<p>Diversos tipos embutidos são tuplas nomeadas, incluindo os valores retornados por <a class="reference internal" href="library/time.html#time.localtime" title="time.localtime"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.localtime()</span></code></a> e <a class="reference internal" href="library/os.html#os.stat" title="os.stat"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.stat()</span></code></a>. Outro exemplo é <a class="reference internal" href="library/sys.html#sys.float_info" title="sys.float_info"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.float_info</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>                   <span class="c1"># indexed access</span>
<span class="go">1024</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="o">.</span><span class="n">max_exp</span>              <span class="c1"># named field access</span>
<span class="go">1024</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>   <span class="c1"># kind of tuple</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Algumas tuplas nomeadas são tipos embutidos (tal como os exemplos acima). Alternativamente, uma tupla nomeada pode ser criada a partir de uma definição de classe regular, que herde de <a class="reference internal" href="library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> e que defina campos nomeados. Tal classe pode ser escrita a mão, ou ela pode ser criada com uma função fábrica <a class="reference internal" href="library/collections.html#collections.namedtuple" title="collections.namedtuple"><code class="xref py py-func docutils literal notranslate"><span class="pre">collections.namedtuple()</span></code></a>. A segunda técnica também adiciona alguns métodos extras, que podem não ser encontrados quando foi escrita manualmente, ou em tuplas nomeadas embutidas.</p>
</dd>
<dt id="term-namespace">espaço de nomes</dt><dd><p>O lugar em que uma variável é armazenada. Espaços de nomes são implementados como dicionários. Existem os espaços de nomes local, global e nativo, bem como espaços de nomes aninhados em objetos (em métodos). Espaços de nomes suportam modularidade ao prevenir conflitos de nomes. Por exemplo, as funções <code class="xref py py-func docutils literal notranslate"><span class="pre">__builtin__.open()</span></code> e <a class="reference internal" href="library/os.html#os.open" title="os.open"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.open()</span></code></a> são diferenciadas por seus espaços de nomes. Espaços de nomes também auxiliam na legibilidade e na manutenibilidade ao torar mais claro quais módulos implementam uma função. Escrever <a class="reference internal" href="library/random.html#random.seed" title="random.seed"><code class="xref py py-func docutils literal notranslate"><span class="pre">random.seed()</span></code></a> ou <code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.izip()</span></code>, por exemplo, deixa claro que estas funções são implementadas pelos módulos <a class="reference internal" href="library/random.html#module-random" title="random: Generate pseudo-random numbers with various common distributions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">random</span></code></a> e <a class="reference internal" href="library/itertools.html#module-itertools" title="itertools: Functions creating iterators for efficient looping."><code class="xref py py-mod docutils literal notranslate"><span class="pre">itertools</span></code></a> respectivamente.</p>
</dd>
<dt id="term-namespace-package">pacote de espaço de nomes</dt><dd><p>Um <a class="reference internal" href="#term-package"><span class="xref std std-term">pacote</span></a> da <span class="target" id="index-94"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0420"><strong>PEP 420</strong></a> que serve apenas como container para sub pacotes. Pacotes de espaços de nomes podem não ter representação física, e especificamente não são como um <a class="reference internal" href="#term-regular-package"><span class="xref std std-term">pacote regular</span></a> porque eles não tem um arquivo <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code>.</p>
<p>Veja também <a class="reference internal" href="#term-module"><span class="xref std std-term">módulo</span></a>.</p>
</dd>
<dt id="term-nested-scope">escopo aninhado</dt><dd><p>A habilidade de referir-se a uma variável em uma definição de fechamento. Por exemplo, uma função definida dentro de outra pode referenciar variáveis da função externa. Perceba que escopos aninhados por padrão funcionam apenas por referência e não por atribuição. Variáveis locais podem ler e escrever no escopo mais interno. De forma similar, variáveis globais podem ler e escrever para o espaço de nomes global. O <a class="reference internal" href="reference/simple_stmts.html#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> permite escrita para escopos externos.</p>
</dd>
<dt id="term-new-style-class">classe estilo novo</dt><dd><p>Antigo nome para o tipo de classes agora usado para todos os objetos de classes. Em versões anteriores do Python, apenas classes estilo podiam usar recursos novos e versáteis do Python, tais como <a class="reference internal" href="reference/datamodel.html#object.__slots__" title="object.__slots__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__slots__</span></code></a>, descritores, propriedades, <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code>, métodos de classe, e métodos estáticos.</p>
</dd>
<dt id="term-object">objeto</dt><dd><p>Qualquer dado que tenha estado (atributos ou valores) e comportamento definidos (métodos). Também a última classe base de qualquer <a class="reference internal" href="#term-new-style-class"><span class="xref std std-term">classe estilo novo</span></a>.</p>
</dd>
<dt id="term-package">pacote</dt><dd><p>Um <a class="reference internal" href="#term-module"><span class="xref std std-term">módulo</span></a> Python é capaz de conter submódulos ou recursivamente, subpacotes. Tecnicamente, um pacote é um módulo Python com um atributo <code class="docutils literal notranslate"><span class="pre">__path__</span></code>.</p>
<p>Veja também <a class="reference internal" href="#term-regular-package"><span class="xref std std-term">pacote regular</span></a> e <a class="reference internal" href="#term-namespace-package"><span class="xref std std-term">pacote de espaço de nomes</span></a>.</p>
</dd>
<dt id="term-parameter">parâmetro</dt><dd><p>Uma entidade nomeada na definição de uma <a class="reference internal" href="#term-function"><span class="xref std std-term">função</span></a> (ou método) que específica um <a class="reference internal" href="#term-argument"><span class="xref std std-term">argumento</span></a> (ou em alguns casos, argumentos) que a função pode receber. Existem cinco tipos de parâmetros:</p>
<ul>
<li><p><em class="dfn">posicional-ou-nomeado</em>: especifica um argumento que pode ser tanto <a class="reference internal" href="#term-argument"><span class="xref std std-term">posicional</span></a> quanto <a class="reference internal" href="#term-argument"><span class="xref std std-term">nomeado</span></a>. Esse é o tipo padrão de parâmetro, por exemplo <em>foo</em> e <em>bar</em> a seguir:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">bar</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
</li>
</ul>
<ul id="positional-only-parameter">
<li><p><em class="dfn">somente-posicional</em>: especifica um argumento que pode ser fornecido apenas por posição. Parâmetros somente-posicionais podem ser definidos incluindo o caractere <code class="docutils literal notranslate"><span class="pre">/</span></code> na lista de parâmetros da definição da função após eles, por exemplo <em>posonly1</em> e <em>posonly2</em> a seguir:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">posonly1</span><span class="p">,</span> <span class="n">posonly2</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">positional_or_keyword</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
</li>
</ul>
<ul id="keyword-only-parameter">
<li><p><em class="dfn">somente-nomeado</em>: especifica um argumento que pode ser passado para a função somente por nome. Parâmetros somente-nomeados podem ser definidos com um simples parâmetro var-posicional ou um <code class="docutils literal notranslate"><span class="pre">*</span></code> antes deles na lista de parâmetros na definição da função, por exemplo <em>kw_only1</em> and <em>kw_only2</em> a seguir:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">kw_only1</span><span class="p">,</span> <span class="n">kw_only2</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
</li>
<li><p><em class="dfn">var-posicional</em>: especifica que uma sequência arbitrária de argumentos posicionais pode ser fornecida (em adição a qualquer argumento posicional já aceito por outros parâmetros). Tal parâmetro pode ser definido colocando um <code class="docutils literal notranslate"><span class="pre">*</span></code> antes do nome do parâmetro, por exemplo <em>args</em> a seguir:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
</li>
<li><p><em class="dfn">var-nomeado</em>: especifica que, arbitrariamente, muitos argumentos nomeados podem ser fornecidos (em adição a qualquer argumento nomeado já aceito por outros parâmetros). Tal parâmetro pode definido colocando-se <code class="docutils literal notranslate"><span class="pre">**</span></code> antes do nome, por exemplo <em>kwargs</em> no exemplo acima.</p></li>
</ul>
<p>Parâmetros podem especificar tanto argumentos opcionais quanto obrigatórios, assim como valores padrão para alguns argumentos opcionais.</p>
<p>Veja o termo <a class="reference internal" href="#term-argument"><span class="xref std std-term">argumento</span></a> no glossário, a pergunta sobre <a class="reference internal" href="faq/programming.html#faq-argument-vs-parameter"><span class="std std-ref">a diferença entre argumentos e parâmetros</span></a>, a classe <a class="reference internal" href="library/inspect.html#inspect.Parameter" title="inspect.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">inspect.Parameter</span></code></a>, a seção <a class="reference internal" href="reference/compound_stmts.html#function"><span class="std std-ref">Definições de função</span></a> e a <span class="target" id="index-95"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0362"><strong>PEP 362</strong></a>.</p>
</dd>
<dt id="term-path-entry">entrada de caminho</dt><dd><p>Um local único no <a class="reference internal" href="#term-import-path"><span class="xref std std-term">caminho de importação</span></a> que o <a class="reference internal" href="#term-path-based-finder"><span class="xref std std-term">localizador baseado no caminho</span></a> consulta para encontrar módulos a serem importados.</p>
</dd>
<dt id="term-path-entry-finder">localizador de entrada de caminho</dt><dd><p>Um <a class="reference internal" href="#term-finder"><span class="xref std std-term">localizador</span></a> retornado por um chamável em <a class="reference internal" href="library/sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a> (ou seja, um <a class="reference internal" href="#term-path-entry-hook"><span class="xref std std-term">gancho de entrada de caminho</span></a>) que sabe como localizar os módulos <a class="reference internal" href="#term-path-entry"><span class="xref std std-term">entrada de caminho</span></a>.</p>
<p>Veja <a class="reference internal" href="library/importlib.html#importlib.abc.PathEntryFinder" title="importlib.abc.PathEntryFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.PathEntryFinder</span></code></a> para os métodos que localizadores de entrada de caminho implementam.</p>
</dd>
<dt id="term-path-entry-hook">gancho de entrada de caminho</dt><dd><p>Um chamável na lista <code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hook</span></code> que retorna um <a class="reference internal" href="#term-path-entry-finder"><span class="xref std std-term">localizador de entrada de caminho</span></a> caso saiba como localizar módulos em uma <a class="reference internal" href="#term-path-entry"><span class="xref std std-term">entrada de caminho</span></a> específica.</p>
</dd>
<dt id="term-path-based-finder">localizador baseado no caminho</dt><dd><p>Um dos <a class="reference internal" href="#term-meta-path-finder"><span class="xref std std-term">localizadores de metacaminho</span></a> que procura por um <a class="reference internal" href="#term-import-path"><span class="xref std std-term">caminho de importação</span></a> de módulos.</p>
</dd>
<dt id="term-path-like-object">objeto caminho ou similar</dt><dd><p>Um objeto representando um caminho de sistema de arquivos. Um objeto caminho ou similar é ou um objeto <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> ou <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> representando um caminho, ou um objeto implementando o protocolo <a class="reference internal" href="library/os.html#os.PathLike" title="os.PathLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">os.PathLike</span></code></a>. Um objeto que suporta o protocolo <a class="reference internal" href="library/os.html#os.PathLike" title="os.PathLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">os.PathLike</span></code></a> pode ser convertido para um arquivo de caminho do sistema <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> ou <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, através da chamada da função <a class="reference internal" href="library/os.html#os.fspath" title="os.fspath"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fspath()</span></code></a>; <a class="reference internal" href="library/os.html#os.fsdecode" title="os.fsdecode"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fsdecode()</span></code></a> e <a class="reference internal" href="library/os.html#os.fsencode" title="os.fsencode"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fsencode()</span></code></a> podem ser usadas para garantir um <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> ou <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> como resultado, respectivamente. Introduzido na <span class="target" id="index-96"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0519"><strong>PEP 519</strong></a>.</p>
</dd>
<dt id="term-PEP">PEP</dt><dd><p>Proposta de melhoria do Python. Uma PEP é um documento de design que fornece informação para a comunidade Python, ou descreve uma nova funcionalidade para o Python ou seus predecessores ou ambientes. PEPs devem prover uma especificação técnica concisa e um racional para funcionalidades propostas.</p>
<p>PEPs têm a intenção de ser os mecanismos primários para propor novas funcionalidades significativas, para coletar opiniões da comunidade sobre um problema, e para documentar as decisões de design que foram adicionadas ao Python. O autor da PEP é responsável por construir um consenso dentro da comunidade e documentar opiniões dissidentes.</p>
<p>Veja <span class="target" id="index-97"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0001"><strong>PEP 1</strong></a>.</p>
</dd>
<dt id="term-portion">porção</dt><dd><p>Um conjunto de arquivos em um único diretório (possivelmente armazenado em um arquivo zip) que contribuem para um pacote de espaço de nomes, conforme definido em <span class="target" id="index-98"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0420"><strong>PEP 420</strong></a>.</p>
</dd>
<dt id="term-positional-argument">argumento posicional</dt><dd><p>Veja <a class="reference internal" href="#term-argument"><span class="xref std std-term">argumento</span></a>.</p>
</dd>
<dt id="term-provisional-API">API provisória</dt><dd><p>Uma API provisória é uma API que foi deliberadamente excluída das bibliotecas padrões com compatibilidade retroativa garantida. Enquanto mudanças maiores para tais interfaces não são esperadas, contanto que elas sejam marcadas como provisórias, mudanças retroativas incompatíveis (até e incluindo a remoção da interface) podem ocorrer se consideradas necessárias pelos desenvolvedores principais. Tais mudanças não serão feitas gratuitamente – elas irão ocorrer apenas se sérias falhas fundamentais forem descobertas, que foram esquecidas anteriormente a inclusão da API.</p>
<p>Mesmo para APIs provisórias, mudanças retroativas incompatíveis são vistas como uma “solução em último caso” - cada tentativa ainda será feita para encontrar uma resolução retroativa compatível para quaisquer problemas encontrados.</p>
<p>Esse processo permite que a biblioteca padrão continue a evoluir com o passar do tempo, sem se prender em erros de design problemáticos por períodos de tempo prolongados. Veja <span class="target" id="index-99"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0411"><strong>PEP 411</strong></a> para mais detalhes.</p>
</dd>
<dt id="term-provisional-package">pacote provisório</dt><dd><p>Veja <a class="reference internal" href="#term-provisional-API"><span class="xref std std-term">API provisória</span></a>.</p>
</dd>
<dt id="term-Python-3000">Python 3000</dt><dd><p>Apelido para a linha de lançamento da versão do Python 3.x (cunhada há muito tempo, quando o lançamento da versão 3 era algo em um futuro muito distante.) Esse termo possui a seguinte abreviação: “Py3k”.</p>
</dd>
<dt id="term-Pythonic">Pythônico</dt><dd><p>Uma ideia ou um pedaço de código que segue de perto os idiomas mais comuns da linguagem Python, ao invés de implementar códigos usando conceitos comuns a outros idiomas. Por exemplo, um idioma comum em Python é fazer um loop sobre todos os elementos de uma iterável usando a instrução <a class="reference internal" href="reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a>. Muitas outras linguagens não têm esse tipo de construção, então as pessoas que não estão familiarizadas com o Python usam um contador numérico:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">food</span><span class="p">)):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">food</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</pre></div>
</div>
<p>Ao contrário do método limpo, ou então, Pythônico:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">piece</span> <span class="ow">in</span> <span class="n">food</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">piece</span><span class="p">)</span>
</pre></div>
</div>
</dd>
<dt id="term-qualified-name">nome qualificado</dt><dd><p>Um nome pontilhado (quando 2 termos são ligados por um ponto) que mostra o “path” do escopo global de um módulo para uma classe, função ou método definido num determinado módulo, conforme definido pela <span class="target" id="index-100"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3155"><strong>PEP 3155</strong></a>. Para funções e classes de nível superior, o nome qualificado é o mesmo que o nome do objeto:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">class</span> <span class="nc">D</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">def</span> <span class="nf">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>            <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="vm">__qualname__</span>
<span class="go">&#39;C&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="n">D</span><span class="o">.</span><span class="vm">__qualname__</span>
<span class="go">&#39;C.D&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="n">D</span><span class="o">.</span><span class="n">meth</span><span class="o">.</span><span class="vm">__qualname__</span>
<span class="go">&#39;C.D.meth&#39;</span>
</pre></div>
</div>
<p>Quando usado para se referir a módulos, o <em>nome totalmente qualificado</em> significa todo o caminho pontilhado para o módulo, incluindo quaisquer pacotes pai, por exemplo: <code class="docutils literal notranslate"><span class="pre">email.mime.text</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">email.mime.text</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">email</span><span class="o">.</span><span class="n">mime</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="vm">__name__</span>
<span class="go">&#39;email.mime.text&#39;</span>
</pre></div>
</div>
</dd>
<dt id="term-reference-count">contagem de referências</dt><dd><p>O número de referências para um objeto. Quando a contagem de referências de um objeto atinge zero, ele é desalocado. Contagem de referências geralmente não é visível no código Python, mas é um elemento chave da implementação <a class="reference internal" href="#term-CPython"><span class="xref std std-term">CPython</span></a>. O módulo <a class="reference internal" href="library/sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sys</span></code></a> define a função <a class="reference internal" href="library/sys.html#sys.getrefcount" title="sys.getrefcount"><code class="xref py py-func docutils literal notranslate"><span class="pre">getrefcount()</span></code></a> que programadores podem chamar para retornar a contagem de referências para um objeto em particular.</p>
</dd>
<dt id="term-regular-package">pacote regular</dt><dd><p>Um <a class="reference internal" href="#term-package"><span class="xref std std-term">pacote</span></a> tradicional, como um diretório contendo um arquivo <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code>.</p>
<p>Veja também <a class="reference internal" href="#term-namespace-package"><span class="xref std std-term">pacote de espaço de nomes</span></a>.</p>
</dd>
<dt id="term-__slots__">__slots__</dt><dd><p>Uma declaração dentro de uma classe que economiza memória pré-declarando espaço para atributos de instâncias, e eliminando dicionários de instâncias. Apesar de popular, a técnica é um tanto quanto complicada de acertar, e é melhor se for reservada para casos raros, onde existe uma grande quantidade de instâncias em uma aplicação onde a memória é crítica.</p>
</dd>
<dt id="term-sequence">sequência</dt><dd><p>Um <a class="reference internal" href="#term-iterable"><span class="xref std std-term">iterável</span></a> com suporte para acesso eficiente a seus elementos através de índices inteiros via método especial <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code> e que define o método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code> que devolve o tamanho da sequência. Alguns tipos de sequência embutidos são: <a class="reference internal" href="library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>, <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, <a class="reference internal" href="library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>, e <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>. Note que <a class="reference internal" href="library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> também tem suporte para <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code> e <code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code>, mas é considerado um mapa e não uma sequência porque a busca usa uma chave <a class="reference internal" href="#term-immutable"><span class="xref std std-term">imutável</span></a> arbitrária em vez de inteiros.</p>
<p>A classe base abstrata <a class="reference internal" href="library/collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Sequence</span></code></a> define uma interface mais rica que vai além de apenas <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code> e <code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code>, adicionando <code class="xref py py-meth docutils literal notranslate"><span class="pre">count()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">index()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code>, e <code class="xref py py-meth docutils literal notranslate"><span class="pre">__reversed__()</span></code>. Tipos que implementam essa interface podem ser explicitamente registrados usando <a class="reference internal" href="library/abc.html#abc.ABCMeta.register" title="abc.ABCMeta.register"><code class="xref py py-func docutils literal notranslate"><span class="pre">register()</span></code></a>.</p>
</dd>
<dt id="term-set-comprehension">compreensão de conjunto</dt><dd><p>Uma maneira compacta de processar todos ou parte dos elementos em iterável e retornar um conjunto com os resultados. <code class="docutils literal notranslate"><span class="pre">results</span> <span class="pre">=</span> <span class="pre">{c</span> <span class="pre">for</span> <span class="pre">c</span> <span class="pre">in</span> <span class="pre">'abracadabra'</span> <span class="pre">if</span> <span class="pre">c</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">'abc'}</span></code> gera um conjunto de strings <code class="docutils literal notranslate"><span class="pre">{'r',</span> <span class="pre">'d'}</span></code>.  Veja <a class="reference internal" href="reference/expressions.html#comprehensions"><span class="std std-ref">Displays for lists, sets and dictionaries</span></a>.</p>
</dd>
<dt id="term-single-dispatch">despacho único</dt><dd><p>Uma forma de despacho de <a class="reference internal" href="#term-generic-function"><span class="xref std std-term">função genérica</span></a> onde a implementação é escolhida com base no tipo de um único argumento.</p>
</dd>
<dt id="term-slice">fatia</dt><dd><p>Um objeto geralmente contendo uma parte de uma <a class="reference internal" href="#term-sequence"><span class="xref std std-term">sequência</span></a>. Uma fatia é criada usando a notação de subscrito <code class="docutils literal notranslate"><span class="pre">[]</span></code> pode conter também até dois pontos entre números, como em <code class="docutils literal notranslate"><span class="pre">variable_name[1:3:5]</span></code>. A notação de suporte (subscrito) utiliza objetos <a class="reference internal" href="library/functions.html#slice" title="slice"><code class="xref py py-class docutils literal notranslate"><span class="pre">slice</span></code></a> internamente.</p>
</dd>
<dt id="term-special-method">método especial</dt><dd><p id="index-34">Um método que é chamado implicitamente pelo Python para executar uma certa operação em um tipo, como uma adição por exemplo. Tais métodos tem nomes iniciando e terminando com dois underscores. Métodos especiais estão documentados em <a class="reference internal" href="reference/datamodel.html#specialnames"><span class="std std-ref">Nomes de métodos especiais</span></a>.</p>
</dd>
<dt id="term-statement">instrução</dt><dd><p>Uma instrução é parte de uma suíte (um “bloco” de código). Uma instrução é ou uma <a class="reference internal" href="#term-expression"><span class="xref std std-term">expressão</span></a> ou uma de várias construções com uma palavra reservada, tal como <a class="reference internal" href="reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a>, <a class="reference internal" href="reference/compound_stmts.html#while"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">while</span></code></a> ou <a class="reference internal" href="reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a>.</p>
</dd>
<dt id="term-strong-reference">referência forte</dt><dd><p>Na API C do Python, uma referência forte é uma referência a um objeto que aumenta a contagem de referências do objeto quando ele é criado e diminui a contagem de referências do objeto quando ele é excluído.</p>
<p>A função <a class="reference internal" href="c-api/refcounting.html#c.Py_NewRef" title="Py_NewRef"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_NewRef()</span></code></a> pode ser usada para criar uma referência forte para um objeto. Normalmente, a função <a class="reference internal" href="c-api/refcounting.html#c.Py_DECREF" title="Py_DECREF"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_DECREF()</span></code></a> deve ser chamada na referência forte antes de sair do escopo da referência forte, para evitar o vazamento de uma referência.</p>
<p>Veja também <a class="reference internal" href="#term-borrowed-reference"><span class="xref std std-term">referência emprestada</span></a>.</p>
</dd>
<dt id="term-text-encoding">codificador de texto</dt><dd><p>A string in Python is a sequence of Unicode code points (in range
<code class="docutils literal notranslate"><span class="pre">U+0000</span></code>–<code class="docutils literal notranslate"><span class="pre">U+10FFFF</span></code>). To store or transfer a string, it needs to be
serialized as a sequence of bytes.</p>
<p>Serializing a string into a sequence of bytes is known as “encoding”, and
recreating the string from the sequence of bytes is known as “decoding”.</p>
<p>There are a variety of different text serialization
<a class="reference internal" href="library/codecs.html#standard-encodings"><span class="std std-ref">codecs</span></a>, which are collectively referred to as
“text encodings”.</p>
</dd>
<dt id="term-text-file">arquivo texto</dt><dd><p>Um  <a class="reference internal" href="#term-file-object"><span class="xref std std-term">objeto arquivo</span></a> apto a ler e escrever objetos <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>. Geralmente, um arquivo texto, na verdade, acessa um fluxo de dados de bytes e captura o <a class="reference internal" href="#term-text-encoding"><span class="xref std std-term">codificador de texto</span></a> automaticamente. Exemplos de arquivos texto são: arquivos abertos em modo texto (<code class="docutils literal notranslate"><span class="pre">'r'</span></code> or <code class="docutils literal notranslate"><span class="pre">'w'</span></code>), <a class="reference internal" href="library/sys.html#sys.stdin" title="sys.stdin"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdin</span></code></a>, <a class="reference internal" href="library/sys.html#sys.stdout" title="sys.stdout"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdout</span></code></a>, e instâncias de <a class="reference internal" href="library/io.html#io.StringIO" title="io.StringIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.StringIO</span></code></a>.</p>
<p>Veja também <a class="reference internal" href="#term-binary-file"><span class="xref std std-term">arquivo binário</span></a> para um objeto arquivo apto a ler e escrever <a class="reference internal" href="#term-bytes-like-object"><span class="xref std std-term">objetos byte ou similar</span></a>.</p>
</dd>
<dt id="term-triple-quoted-string">aspas triplas</dt><dd><p>Uma string que está definida com três ocorrências de aspas duplas (”) ou apóstrofos (‘). Enquanto elas não fornecem nenhuma funcionalidade não disponível com strings de aspas simples, elas são úteis para inúmeras razões. Elas permitem que você inclua aspas simples e duplas não escapadas dentro de uma string, e elas podem utilizar múltiplas linhas sem o uso de caractere de continuação, fazendo-as especialmente úteis quando escrevemos documentação em docstrings.</p>
</dd>
<dt id="term-type">tipo</dt><dd><p>O tipo de um objeto Python determina qual tipo de objeto ele é; cada objeto tem um tipo. Um tipo de objeto é acessível pelo atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">__class__</span></code> ou pode ser recuperado com <code class="docutils literal notranslate"><span class="pre">type(obj)</span></code>.</p>
</dd>
<dt id="term-type-alias">tipo alias</dt><dd><p>Um sinônimo para um tipo, criado através da atribuição do tipo para um identificador.</p>
<p>Tipos alias são úteis para simplificar <a class="reference internal" href="#term-type-hint"><span class="xref std std-term">dicas de tipo</span></a>. Por exemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">remove_gray_shades</span><span class="p">(</span>
        <span class="n">colors</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>pode tornar-se mais legível desta forma:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Color</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">remove_gray_shades</span><span class="p">(</span><span class="n">colors</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Color</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Color</span><span class="p">]:</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>Veja <a class="reference internal" href="library/typing.html#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a> e <span class="target" id="index-101"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a>, a qual descreve esta funcionalidade.</p>
</dd>
<dt id="term-type-hint">dica de tipo</dt><dd><p>Uma <a class="reference internal" href="#term-annotation"><span class="xref std std-term">anotação</span></a> que especifica o tipo esperado para uma variável, um atributo de classe, ou um parâmetro de função ou um valor de retorno.</p>
<p>Dicas de tipo são opcionais e não são forçadas pelo Python, mas elas são úteis para ferramentas de análise de tipos estático, e ajudam IDEs a completar e refatorar código.</p>
<p>Dicas de tipos de variáveis globais, atributos de classes, e funções, mas não de variáveis locais, podem ser acessadas usando <a class="reference internal" href="library/typing.html#typing.get_type_hints" title="typing.get_type_hints"><code class="xref py py-func docutils literal notranslate"><span class="pre">typing.get_type_hints()</span></code></a>.</p>
<p>Veja <a class="reference internal" href="library/typing.html#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a> e <span class="target" id="index-102"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a>, a qual descreve esta funcionalidade.</p>
</dd>
<dt id="term-universal-newlines">novas linhas universais</dt><dd><p>Uma maneira de interpretar fluxos de textos, na qual todos estes são reconhecidos como caracteres de fim de linha: a convenção para fim de linha no Unix <code class="docutils literal notranslate"><span class="pre">'\n'</span></code>, a convenção no Windows <code class="docutils literal notranslate"><span class="pre">'\r\n'</span></code>, e a antiga convenção no Macintosh <code class="docutils literal notranslate"><span class="pre">'\r'</span></code>. Veja <span class="target" id="index-103"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0278"><strong>PEP 278</strong></a> e <span class="target" id="index-104"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3116"><strong>PEP 3116</strong></a>, bem como <a class="reference internal" href="library/stdtypes.html#bytes.splitlines" title="bytes.splitlines"><code class="xref py py-func docutils literal notranslate"><span class="pre">bytes.splitlines()</span></code></a> para uso adicional.</p>
</dd>
<dt id="term-variable-annotation">anotação de variável</dt><dd><p>Uma <a class="reference internal" href="#term-annotation"><span class="xref std std-term">anotação</span></a> de uma variável ou um atributo de classe.</p>
<p>Ao fazer uma anotação de uma variável ou um atributo de classe, a atribuição é opcional:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="n">field</span><span class="p">:</span> <span class="s1">&#39;annotation&#39;</span>
</pre></div>
</div>
<p>Anotações de variáveis são normalmente usadas para <a class="reference internal" href="#term-type-hint"><span class="xref std std-term">dicas de tipo</span></a>: por exemplo, espera-se que esta variável receba valores do tipo <a class="reference internal" href="library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
<p>A sintaxe de anotação de variável é explicada na seção <a class="reference internal" href="reference/simple_stmts.html#annassign"><span class="std std-ref">Annotated assignment statements</span></a>.</p>
<p>Veja <a class="reference internal" href="#term-function-annotation"><span class="xref std std-term">anotação de função</span></a>, <span class="target" id="index-105"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a> e <span class="target" id="index-106"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0526"><strong>PEP 526</strong></a>, que descrevem esta funcionalidade. Veja também <a class="reference internal" href="howto/annotations.html#annotations-howto"><span class="std std-ref">Annotations Best Practices</span></a> para as melhores práticas sobre como trabalhar com anotações.</p>
</dd>
<dt id="term-virtual-environment">ambiente virtual</dt><dd><p>Um ambiente de execução isolado que permite usuários Python e aplicações instalarem e atualizarem pacotes Python sem interferir no comportamento de outras aplicações Python em execução no mesmo sistema.</p>
<p>Veja também <a class="reference internal" href="library/venv.html#module-venv" title="venv: Creation of virtual environments."><code class="xref py py-mod docutils literal notranslate"><span class="pre">venv</span></code></a>.</p>
</dd>
<dt id="term-virtual-machine">máquina virtual</dt><dd><p>Um computador definido inteiramente em software. A máquina virtual de Python executa o <a class="reference internal" href="#term-bytecode"><span class="xref std std-term">bytecode</span></a> emitido pelo compilador de bytecode.</p>
</dd>
<dt id="term-Zen-of-Python">Zen do Python</dt><dd><p>Lista de princípios de projeto e filosofias do Python que são úteis para a compreensão e uso da linguagem. A lista é exibida quando se digita “<code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">this</span></code>” no console interativo.</p>
</dd>
</dl>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Tópico anterior</h4>
  <p class="topless"><a href="faq/installed.html"
                        title="capítulo anterior">FAD de “Por que o Python está instalado em meu computador?”</a></p>
  <h4>Próximo tópico</h4>
  <p class="topless"><a href="about.html"
                        title="próximo capítulo">Sobre esses documentos</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="bugs.html">Relatar um erro</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.10/Doc/glossary.rst"
            rel="nofollow">Exibir código-fonte
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegação</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Índice geral"
             >índice</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="about.html" title="Sobre esses documentos"
             >próximo</a> |</li>
        <li class="right" >
          <a href="faq/installed.html" title="FAD de “Por que o Python está instalado em meu computador?”"
             >anterior</a> |</li>

          <li><img src="_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="index.html">3.10.4 Documentation</a> &#187;
    </li>

        <li class="nav-item nav-item-this"><a href="">Glossário</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="search.html" method="get">
          <input placeholder="Busca rápida" aria-label="Busca rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="copyright.html">Direitos autorais</a> 2001-2022, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    Última atualização em jun. 04, 2022.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.4.3.
    </div>

  </body>
</html>