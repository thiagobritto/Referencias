
<!DOCTYPE html>

<html lang="pt_BR">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17: http://docutils.sourceforge.net/" />

    <title>Expressões Regulares HOWTO &#8212; documentação Python 3.10.4</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pydoctheme.css?2022.1" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Pesquisar dentro de documentação Python 3.10.4"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="Sobre esses documentos" href="../about.html" />
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Buscar" href="../search.html" />
    <link rel="copyright" title="Direitos autorais" href="../copyright.html" />
    <link rel="next" title="HOWTO sobre a Programação de Soquetes" href="sockets.html" />
    <link rel="prev" title="Livro de Receitas do Logging" href="logging-cookbook.html" />
    <link rel="canonical" href="https://docs.python.org/3/howto/regex.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <label for="menuToggler" class="toggler__label">
        <span></span>
    </label>
    <nav class="nav-content" role="navigation">
         <a href="https://www.python.org/" class="nav-logo">
             <img src="../_static/py.svg" alt="Logo"/>
         </a>
        <div class="version_switcher_placeholder"></div>
        <form role="search" class="search" action="../search.html" method="get">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                <path fill-rule="nonzero"
                        d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="#444"></path>
            </svg>
            <input type="text" name="q" aria-label="Busca rápida"/>
            <input type="submit" value="Ir"/>
        </form>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
  <h3><a href="../contents.html">Tabela de Conteúdo</a></h3>
  <ul>
<li><a class="reference internal" href="#">Expressões Regulares HOWTO</a><ul>
<li><a class="reference internal" href="#introduction">Introdução</a></li>
<li><a class="reference internal" href="#simple-patterns">Padrões Simples</a><ul>
<li><a class="reference internal" href="#matching-characters">Caracteres Correspondentes</a></li>
<li><a class="reference internal" href="#repeating-things">Repetindo Coisas</a></li>
</ul>
</li>
<li><a class="reference internal" href="#using-regular-expressions">Usando expressões regulares</a><ul>
<li><a class="reference internal" href="#compiling-regular-expressions">Compilando Expressões Regulares</a></li>
<li><a class="reference internal" href="#the-backslash-plague">A praga da barra invertida</a></li>
<li><a class="reference internal" href="#performing-matches">Executando Comparações</a></li>
<li><a class="reference internal" href="#module-level-functions">Funções de Nível de Módulo</a></li>
<li><a class="reference internal" href="#compilation-flags">Sinalizadores de Compilação</a></li>
</ul>
</li>
<li><a class="reference internal" href="#more-pattern-power">Mais Poder dos Padrões</a><ul>
<li><a class="reference internal" href="#more-metacharacters">Mais Metacaracteres</a></li>
<li><a class="reference internal" href="#grouping">Agrupamento</a></li>
<li><a class="reference internal" href="#non-capturing-and-named-groups">Não captura e Grupos Nomeados</a></li>
<li><a class="reference internal" href="#lookahead-assertions">Afirmação Lookahead</a></li>
</ul>
</li>
<li><a class="reference internal" href="#modifying-strings">Modificando Strings</a><ul>
<li><a class="reference internal" href="#splitting-strings">Dividindo as Strings</a></li>
<li><a class="reference internal" href="#search-and-replace">Busca e Substituição</a></li>
</ul>
</li>
<li><a class="reference internal" href="#common-problems">Problemas Comuns</a><ul>
<li><a class="reference internal" href="#use-string-methods">Usando String Methods</a></li>
<li><a class="reference internal" href="#match-versus-search">match() versus search()</a></li>
<li><a class="reference internal" href="#greedy-versus-non-greedy">Gulosos versus não Gulosos</a></li>
<li><a class="reference internal" href="#using-re-verbose">Usando re.VERBOSE</a></li>
</ul>
</li>
<li><a class="reference internal" href="#feedback">Comentários</a></li>
</ul>
</li>
</ul>

  <h4>Tópico anterior</h4>
  <p class="topless"><a href="logging-cookbook.html"
                        title="capítulo anterior">Livro de Receitas do Logging</a></p>
  <h4>Próximo tópico</h4>
  <p class="topless"><a href="sockets.html"
                        title="próximo capítulo">HOWTO sobre a Programação de Soquetes</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Relatar um erro</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.10/Doc/howto/regex.rst"
            rel="nofollow">Exibir código-fonte
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegação</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice geral"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="sockets.html" title="HOWTO sobre a Programação de Soquetes"
             accesskey="N">próximo</a> |</li>
        <li class="right" >
          <a href="logging-cookbook.html" title="Livro de Receitas do Logging"
             accesskey="P">anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.10.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Python HOWTOs</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Expressões Regulares HOWTO</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Busca rápida" aria-label="Busca rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="regular-expression-howto">
<span id="regex-howto"></span><h1>Expressões Regulares HOWTO<a class="headerlink" href="#regular-expression-howto" title="Link permanente para este título">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Autor</dt>
<dd class="field-odd"><p>A.M. Kuchling &lt;<a class="reference external" href="mailto:amk&#37;&#52;&#48;amk&#46;ca">amk<span>&#64;</span>amk<span>&#46;</span>ca</a>&gt;</p>
</dd>
</dl>
<div class="topic">
<p class="topic-title">Resumo</p>
<p>Este documento é um tutorial introdutório sobre expressões regulares em Python com o módulo <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a>. Ele provê uma introdução mais tranquila que a seção correspondente à documentação do módulo.</p>
</div>
<section id="introduction">
<h2>Introdução<a class="headerlink" href="#introduction" title="Link permanente para este título">¶</a></h2>
<p>Expressões regulares (chamadas REs, ou regexes ou padrões regex) são essencialmente uma mini linguagem de programação altamente especializada incluída dentro do Python e disponível através do módulo <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a>. Usando esta pequena linguagem, você especifica as regras para o conjunto de strings possíveis que você quer combinar; esse conjunto pode conter sentenças em inglês, endereços de e-mail, ou comandos TeX ou qualquer coisa que você queira. Você poderá então perguntar coisas como “Essa string se enquadra dentro do padrão?” ou “Existe alguma parte da string que se enquadra nesse padrão?”. Você também pode usar as REs para modificar uma string ou dividi-la de diversas formas.</p>
<p>Os padrões das expressões regulares são compilados em uma série de bytecodes que são então executadas por um mecanismo de combinação escrito em C. Para usos avançados, talvez seja necessário prestar atenção em como o mecanismo irá executar uma dada RE, e escrever a RE de forma que os bytecodes executem de forma mais rápida. Otimização é um tema que não será visto neste documento, porque ele requer que você tenha um bom entendimento dos mecanismos de combinação internos.</p>
<p>A linguagem de expressão regular é relativamente pequena e restrita, por isso nem
todas as tarefas de processamento de strings possíveis podem ser feitas usando
expressões regulares. Existem também tarefas que podem ser feitas com expressões
regulares, mas as expressões acabam por ser tornar muito complicadas. Nestes casos, pode
ser melhor para você escrever um código Python para fazer o processamento;
embora um código Python seja mais lento do que uma expressão regular elaborada,
ele provavelmente será mais compreensível.</p>
</section>
<section id="simple-patterns">
<h2>Padrões Simples<a class="headerlink" href="#simple-patterns" title="Link permanente para este título">¶</a></h2>
<p>Vamos começar por aprender sobre as expressões regulares mais simples possíveis.
Como as expressões regulares são usadas para operar em strings, vamos começar
com a tarefa mais comum: de correspondência caracteres.</p>
<p>Para uma explicação detalhada da ciência da computação referente a expressões
regulares (autômatos finitos determinísticos e não-determinístico), você pode consultar
a praticamente qualquer livro sobre a escrita de compiladores.</p>
<section id="matching-characters">
<h3>Caracteres Correspondentes<a class="headerlink" href="#matching-characters" title="Link permanente para este título">¶</a></h3>
<p>A maioria das letras e caracteres simplesmente irão corresponder entre si. Por exemplo, a expressão regular <code class="docutils literal notranslate"><span class="pre">teste</span></code>
irá combinar com a string <code class="docutils literal notranslate"><span class="pre">teste</span></code> totalmente. (Você pode habilitar o modo de maiúsculas e minúsculas que faria com que
a RE corresponder com <code class="docutils literal notranslate"><span class="pre">Test</span></code> ou <code class="docutils literal notranslate"><span class="pre">TEST</span></code> também; veremos mais sobre isso mais adiante.)</p>
<p>Há exceções a essa regra, alguns caracteres são metacaracteres especiais, e não se
correspondem. Em vez disso, eles sinalizam que alguma coisa fora do normal deve
ser correspondida, ou eles afetam outras partes da RE, repetindo-as ou alterando seus
significados. Grande parte deste documento é dedicada à discussão de vários metacaracteres
e o que eles fazem.</p>
<p>Aqui está a lista completa de metacaracteres; seus significados serão discutidos ao longo deste documento.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>. ^ $ * + ? { } [ ] \ | ( )
</pre></div>
</div>
<p>O primeiro metacaractere que vamos estudos é o <code class="docutils literal notranslate"><span class="pre">[</span></code> e o <code class="docutils literal notranslate"><span class="pre">]</span></code>.  Eles são usados para especificar uma classe de caracteres, que é um conjunto de caracteres que você deseja combinar. Caracteres podem ser listados individualmente ou um range de caracteres pode ser indicado dando dois caracteres e separando-os por um <code class="docutils literal notranslate"><span class="pre">'-'</span></code>.  Por exemplo, <code class="docutils literal notranslate"><span class="pre">[abc]</span></code> irá encontrar qualquer caractere <code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code>, ou <code class="docutils literal notranslate"><span class="pre">c</span></code>; isso é o mesmo que escrever <code class="docutils literal notranslate"><span class="pre">[a-c]</span></code>, que usa um range para expressar o mesmo conjunto de caracteres, Se você deseja encontrar apenas letras minúsculas, sua RE seria <code class="docutils literal notranslate"><span class="pre">[a-z]</span></code>.</p>
<p>Metacharacters (except <code class="docutils literal notranslate"><span class="pre">\</span></code>) are not active inside classes.  For example, <code class="docutils literal notranslate"><span class="pre">[akm$]</span></code> will
match any of the characters <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, <code class="docutils literal notranslate"><span class="pre">'k'</span></code>, <code class="docutils literal notranslate"><span class="pre">'m'</span></code>, or <code class="docutils literal notranslate"><span class="pre">'$'</span></code>; <code class="docutils literal notranslate"><span class="pre">'$'</span></code> is
usually a metacharacter, but inside a character class it’s stripped of its
special nature.</p>
<p>Você pode combinar os caracteres não listados na classe <em class="dfn">complementando</em> o conjunto. Isso é indicado pela inclusão de um <code class="docutils literal notranslate"><span class="pre">'^'</span></code> como o primeiro caractere da classe. Por exemplo, <code class="docutils literal notranslate"><span class="pre">[^5]</span></code> combinará a qualquer caractere, exceto <code class="docutils literal notranslate"><span class="pre">'5'</span></code>. Se o sinal de intercalação aparecer em outro lugar da classe de caracteres, ele não terá um significado especial. Por exemplo: <code class="docutils literal notranslate"><span class="pre">[5^]</span></code> corresponderá a um <code class="docutils literal notranslate"><span class="pre">'5'</span></code> ou a <code class="docutils literal notranslate"><span class="pre">'^'</span></code>.</p>
<p>Talvez o metacaractere mais importante é a contrabarra, <code class="docutils literal notranslate"><span class="pre">\</span></code>. Como as strings literais em Python, a barra invertida pode ser seguida por vários caracteres para sinalizar várias sequências especiais. Ela também é usada para <em>escapar</em> todos os metacaracteres, e assim, você poder combiná-los em padrões; por exemplo, se você precisa fazer correspondência a um <code class="docutils literal notranslate"><span class="pre">[</span></code> ou <code class="docutils literal notranslate"><span class="pre">\</span></code>, você pode precedê-los com uma barra invertida para remover seu significado especial: <code class="docutils literal notranslate"><span class="pre">\[</span></code> ou <code class="docutils literal notranslate"><span class="pre">\\</span></code>.</p>
<p>Algumas das sequências especiais que começam com <code class="docutils literal notranslate"><span class="pre">'\'</span></code> representam conjuntos de caracteres predefinidos que são frequentemente úteis, como o conjunto de dígitos, o conjunto de letras ou o conjunto de qualquer coisa que não seja espaço em branco.</p>
<p>Vejamos um exemplo: <code class="docutils literal notranslate"><span class="pre">\w</span></code> corresponde a qualquer caractere alfanumérico. Se o padrão regex for expresso em bytes, isso é equivalente à classe <code class="docutils literal notranslate"><span class="pre">[a-zA-Z0-9_]</span></code>. Se o padrão regex for uma string, <code class="docutils literal notranslate"><span class="pre">\w</span></code> combinará todos os caracteres marcados como letras no banco de dados Unicode fornecido pelo módulo <a class="reference internal" href="../library/unicodedata.html#module-unicodedata" title="unicodedata: Access the Unicode Database."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unicodedata</span></code></a>. Você pode usar a definição mais restrita de <code class="docutils literal notranslate"><span class="pre">\w</span></code> em um padrão de string, fornecendo o sinalizador <a class="reference internal" href="../library/re.html#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.ASCII</span></code></a> ao compilar a expressão regular.</p>
<p>A lista a seguir de sequências especiais não está completa. Para obter uma lista completa das sequências e definições de classe expandidas para padrões de Strings Unicode, veja a última parte de <a class="reference internal" href="../library/re.html#re-syntax"><span class="std std-ref">Sintaxe de Expressão Regular</span></a> na referência da Biblioteca Padrão. Em geral, as versões Unicode correspondem a qualquer caractere que esteja na categoria apropriada do banco de dados Unicode.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">\d</span></code></dt><dd><p>corresponde a qualquer <code class="docutils literal notranslate"><span class="pre">dígito</span> <span class="pre">decimal</span></code>, que é equivalente à classe <code class="docutils literal notranslate"><span class="pre">[0-9]</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">\D</span></code></dt><dd><p>corresponde a qualquer caractere <code class="docutils literal notranslate"><span class="pre">não-dígito</span></code>, o que é equivalente à classe <code class="docutils literal notranslate"><span class="pre">[^0-9]</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">\s</span></code></dt><dd><p>corresponde a qualquer caractere <code class="docutils literal notranslate"><span class="pre">espaço-em-branco</span></code>, o que é equivalente à classe <code class="docutils literal notranslate"><span class="pre">[\t\n\r\f\v]</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">\S</span></code></dt><dd><p>corresponde a qualquer caractere <code class="docutils literal notranslate"><span class="pre">não-espaço-branco</span></code>, o que é equivalente à classe <code class="docutils literal notranslate"><span class="pre">[^\t\n\r\f\v].</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">\w</span></code></dt><dd><p>corresponde a qualquer caractere <code class="docutils literal notranslate"><span class="pre">alfanumérico</span></code>, o que é equivalente à classe <code class="docutils literal notranslate"><span class="pre">[azA-Z0-9_]</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">\W</span></code></dt><dd><p>corresponde a qualquer caractere <code class="docutils literal notranslate"><span class="pre">não-alfanumérico</span></code>, o que é equivalente à classe <code class="docutils literal notranslate"><span class="pre">[^a-zA-Z0-9_]</span></code>.</p>
</dd>
</dl>
<p>Estas sequências podem ser incluídas dentro de uma classe caractere. Por exemplo, <code class="docutils literal notranslate"><span class="pre">[\s,.]</span></code> É uma classe caractere que irá corresponder a qualquer caractere <code class="docutils literal notranslate"><span class="pre">espaço-em-branco</span></code>, ou <code class="docutils literal notranslate"><span class="pre">,</span></code> ou <code class="docutils literal notranslate"><span class="pre">.</span></code>.</p>
<p>O metacaractere final desta seção é o <code class="docutils literal notranslate"><span class="pre">.</span></code>. Ele encontra tudo, exceto um caractere de nova linha, e existe um modo alternativo (<a class="reference internal" href="../library/re.html#re.DOTALL" title="re.DOTALL"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.DOTALL</span></code></a>), onde ele irá corresponder até mesmo a um caractere de nova linha. <code class="docutils literal notranslate"><span class="pre">.</span></code> é frequentemente usado quando você quer corresponder com “qualquer caractere”.</p>
</section>
<section id="repeating-things">
<h3>Repetindo Coisas<a class="headerlink" href="#repeating-things" title="Link permanente para este título">¶</a></h3>
<p>Ser capaz de corresponder com variados conjuntos de caracteres é a primeira coisa que as expressões regulares podem fazer que ainda não é possível com os métodos disponíveis para strings. No entanto, se essa fosse a única capacidade adicional das expressões regulares, elas não seriam um avanço relevante. Outro recurso que você pode especificar é que partes do RE devem ser repetidas um certo número de vezes.</p>
<p>O primeiro metacaractere para repetir coisas que veremos é <code class="docutils literal notranslate"><span class="pre">*</span></code>. <code class="docutils literal notranslate"><span class="pre">*</span></code> não corresponde ao caractere literal <code class="docutils literal notranslate"><span class="pre">'*'</span></code>; em vez disso, ele especifica que o caractere anterior pode ser correspondido zero ou mais vezes, em vez de exatamente uma vez.</p>
<p>Por exemplo, <code class="docutils literal notranslate"><span class="pre">ca*t</span></code> vai corresponder <code class="docutils literal notranslate"><span class="pre">'ct'</span></code> (0 <code class="docutils literal notranslate"><span class="pre">'a'</span></code> caracteres), <code class="docutils literal notranslate"><span class="pre">'cat'</span></code> (1 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>), <code class="docutils literal notranslate"><span class="pre">'caaat'</span></code> (3 <code class="docutils literal notranslate"><span class="pre">'a'</span></code> caracteres), e assim por diante.</p>
<p>Repetições, tais como <code class="docutils literal notranslate"><span class="pre">*</span></code> são gananciosas; ao repetir a RE, o motor de correspondência vai tentar repeti-la tantas vezes quanto possível. Se porções posteriores do padrão não corresponderem, o motor de correspondência, em seguida, volta e tenta novamente com algumas repetições.</p>
<p>Um exemplo passo a passo fará isso mais óbvio. Vamos considerar a expressão “a[bcd]*b”. Isto corresponde à letra “a”, zero ou mais letras da classe “[bcd]” e, finalmente, termina com “b”.  Agora, imagine corresponder este RE com a string “abcbd”.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 12%" />
<col style="width: 22%" />
<col style="width: 66%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Passo</p></th>
<th class="head"><p>Correspondência</p></th>
<th class="head"><p>Explanação</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span></code></p></td>
<td><p>O caractere <code class="docutils literal notranslate"><span class="pre">a</span></code> na RE tem correspondência.</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">abcbd</span></code></p></td>
<td><p>O motor corresponde com [bcd]*, indo tão longe quanto possível, que é o fim do string.</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p><em>Failure</em></p></td>
<td><p>O motor tenta corresponder com <code class="docutils literal notranslate"><span class="pre">b</span></code>, mas a posição corrente está no final da string, então ele falha.</p></td>
</tr>
<tr class="row-odd"><td><p>4</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">abcb</span></code></p></td>
<td><p>Voltando, de modo que <code class="docutils literal notranslate"><span class="pre">[bcd]*</span></code> corresponde a um caractere a menos.</p></td>
</tr>
<tr class="row-even"><td><p>5</p></td>
<td><p><em>Failure</em></p></td>
<td><p>Tenta <code class="docutils literal notranslate"><span class="pre">b</span></code> novamente, mas a posição corrente é a do último caractere, que é um <code class="docutils literal notranslate"><span class="pre">d</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p>6</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">abc</span></code></p></td>
<td><p>Voltando novamente, de modo que [bcd]* está correspondendo com <code class="docutils literal notranslate"><span class="pre">bc</span></code> somente.</p></td>
</tr>
<tr class="row-even"><td><p>6</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">abcb</span></code></p></td>
<td><p>Tenta <code class="docutils literal notranslate"><span class="pre">b</span></code> novamente. Desta vez, o caractere na posição corrente é <code class="docutils literal notranslate"><span class="pre">b</span></code>, por isso sucesso.</p></td>
</tr>
</tbody>
</table>
<p>O final da RE foi atingido e correspondeu a <code class="docutils literal notranslate"><span class="pre">'abcb'</span></code>. Isso demonstra como o mecanismo de correspondência vai tão longe quanto pode no início e, se nenhuma correspondência for encontrada, ele fará o backup progressivamente e tentará novamente o restante da RE. Ele fará backup até que tenha tentado zero correspondências para <code class="docutils literal notranslate"><span class="pre">[bcd]*</span></code>, e se isso falhar subsequentemente, o mecanismo concluirá que a string não corresponde a RE de forma alguma.</p>
<p>Another repeating metacharacter is <code class="docutils literal notranslate"><span class="pre">+</span></code>, which matches one or more times.  Pay
careful attention to the difference between <code class="docutils literal notranslate"><span class="pre">*</span></code> and <code class="docutils literal notranslate"><span class="pre">+</span></code>; <code class="docutils literal notranslate"><span class="pre">*</span></code> matches
<em>zero</em> or more times, so whatever’s being repeated may not be present at all,
while <code class="docutils literal notranslate"><span class="pre">+</span></code> requires at least <em>one</em> occurrence.  To use a similar example,
<code class="docutils literal notranslate"><span class="pre">ca+t</span></code> will match <code class="docutils literal notranslate"><span class="pre">'cat'</span></code> (1 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>), <code class="docutils literal notranslate"><span class="pre">'caaat'</span></code> (3 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>s), but won’t
match <code class="docutils literal notranslate"><span class="pre">'ct'</span></code>.</p>
<p>There are two more repeating qualifiers.  The question mark character, <code class="docutils literal notranslate"><span class="pre">?</span></code>,
matches either once or zero times; you can think of it as marking something as
being optional.  For example, <code class="docutils literal notranslate"><span class="pre">home-?brew</span></code> matches either <code class="docutils literal notranslate"><span class="pre">'homebrew'</span></code> or
<code class="docutils literal notranslate"><span class="pre">'home-brew'</span></code>.</p>
<p>The most complicated repeated qualifier is <code class="docutils literal notranslate"><span class="pre">{m,n}</span></code>, where <em>m</em> and <em>n</em> are
decimal integers.  This qualifier means there must be at least <em>m</em> repetitions,
and at most <em>n</em>.  For example, <code class="docutils literal notranslate"><span class="pre">a/{1,3}b</span></code> will match <code class="docutils literal notranslate"><span class="pre">'a/b'</span></code>, <code class="docutils literal notranslate"><span class="pre">'a//b'</span></code>, and
<code class="docutils literal notranslate"><span class="pre">'a///b'</span></code>.  It won’t match <code class="docutils literal notranslate"><span class="pre">'ab'</span></code>, which has no slashes, or <code class="docutils literal notranslate"><span class="pre">'a////b'</span></code>, which
has four.</p>
<p>You can omit either <em>m</em> or <em>n</em>; in that case, a reasonable value is assumed for
the missing value.  Omitting <em>m</em> is interpreted as a lower limit of 0, while
omitting <em>n</em> results in an upper bound of infinity.</p>
<p>Os leitores de uma inclinação reducionista podem notar que os três outros qualificadores podem todos serem expressos utilizando esta notação. <code class="docutils literal notranslate"><span class="pre">{0,}</span></code> é o mesmo que <code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">{1,}</span></code> é equivalente a <code class="docutils literal notranslate"><span class="pre">+</span></code>, e <code class="docutils literal notranslate"><span class="pre">{0,1}</span></code> é o mesmo que <code class="docutils literal notranslate"><span class="pre">?</span></code>. É melhor usar <code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">+</span></code> ou <code class="docutils literal notranslate"><span class="pre">?</span></code> quando puder, simplesmente porque eles são mais curtos e fáceis de ler.</p>
</section>
</section>
<section id="using-regular-expressions">
<h2>Usando expressões regulares<a class="headerlink" href="#using-regular-expressions" title="Link permanente para este título">¶</a></h2>
<p>Agora que nós vimos algumas expressões regulares simples, como nós realmente as usamos em Python? O módulo <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> fornece uma interface para o mecanismo de expressão regular, permitindo compilar REs em objetos e, em seguida, executar comparações com eles.</p>
<section id="compiling-regular-expressions">
<h3>Compilando Expressões Regulares<a class="headerlink" href="#compiling-regular-expressions" title="Link permanente para este título">¶</a></h3>
<p>As expressões regulares são compiladas em objetos padrão, que têm métodos para várias operações, tais como a procura por padrões de correspondência ou realizar substituições de strings.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">re</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;ab*&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span>
<span class="go">re.compile(&#39;ab*&#39;)</span>
</pre></div>
</div>
<p><a class="reference internal" href="../library/re.html#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.compile()</span></code></a> também aceita um argumento opcional <em>flags</em>, utilizados para habilitar vários recursos especiais e variações de sintaxe. Nós vamos ver todas as configurações disponíveis mais tarde, mas por agora, um único exemplo vai servir:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;ab*&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
</pre></div>
</div>
<p>A RE é passada para <a class="reference internal" href="../library/re.html#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.compile()</span></code></a> como uma string. REs são tratadas como strings porque as expressões regulares não são parte do núcleo da linguagem Python, e nenhuma sintaxe especial foi criada para expressá-las. (Existem aplicações que não necessitam de REs nenhuma, por isso não há necessidade de inchar a especificação da linguagem, incluindo-as.) Em vez disso, o módulo <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> é simplesmente um módulo de extensão C incluído no Python, assim como os módulos de <a class="reference internal" href="../library/socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> ou <a class="reference internal" href="../library/zlib.html#module-zlib" title="zlib: Low-level interface to compression and decompression routines compatible with gzip."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zlib</span></code></a>.</p>
<p>Colocando REs em strings mantém a linguagem Python mais simples, mas tem uma desvantagem, que é o tema da próxima seção.</p>
</section>
<section id="the-backslash-plague">
<span id="id1"></span><h3>A praga da barra invertida<a class="headerlink" href="#the-backslash-plague" title="Link permanente para este título">¶</a></h3>
<p>Como afirmado anteriormente, expressões regulares usam o caractere de barra invertida (<code class="docutils literal notranslate"><span class="pre">\</span></code>) para indicar formas especiais ou para permitir que caracteres especiais sejam usados sem invocar o seu significado especial. Isso entra em conflito com o uso pelo Python do mesmo caractere para o mesmo propósito nas strings literais.</p>
<p>Vamos dizer que você quer escrever uma RE que corresponde com a string <code class="docutils literal notranslate"><span class="pre">\section</span></code>, que pode ser encontrada em um arquivo LaTeX. Para descobrir o que escrever no código do programa, comece com a string que se deseja corresponder. Em seguida, você deve preceder qualquer barra invertida e outros metacaracteres com uma barra invertida, tendo como resultado a string <code class="docutils literal notranslate"><span class="pre">\\section</span></code>. A string resultante que deve ser passada para <a class="reference internal" href="../library/re.html#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.compile()</span></code></a> deve ser <code class="docutils literal notranslate"><span class="pre">\\section</span></code>. No entanto, para expressar isso como uma string literal Python, ambas as barras invertidas devem ser precedidas com uma barra invertida novamente.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 31%" />
<col style="width: 69%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Caracteres</p></th>
<th class="head"><p>Etapa</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">\section</span></code></p></td>
<td><p>Text string to be matched</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">\\section</span></code></p></td>
<td><p>preceder com barra invertida para <a class="reference internal" href="../library/re.html#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.compile()</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">&quot;\\\\section&quot;</span></code></p></td>
<td><p>barras invertidas precedidas novamente para uma string literal</p></td>
</tr>
</tbody>
</table>
<p>Em suma, para corresponder com uma barra invertida literal, tem de se escrever <code class="docutils literal notranslate"><span class="pre">'\\\\'</span></code> como a string da RE, porque a expressão regular deve ser <code class="docutils literal notranslate"><span class="pre">\\</span></code>, e cada barra invertida deve ser expressa como <code class="docutils literal notranslate"><span class="pre">\\</span></code> dentro de uma string literal Python normal. Em REs que apresentam barras invertidas repetidas vezes, isso leva a um monte de barras invertidas repetidas e faz as strings resultantes difíceis de entender.</p>
<p>A solução é usar a notação de string crua (raw) do Python para expressões regulares; barras invertidas não são tratadas de nenhuma forma especial em uma string literal se prefixada com <code class="docutils literal notranslate"><span class="pre">r</span></code>, então <code class="docutils literal notranslate"><span class="pre">r&quot;\n&quot;</span></code> é uma string de dois caracteres contendo <code class="docutils literal notranslate"><span class="pre">\</span></code> e <code class="docutils literal notranslate"><span class="pre">n</span></code>, enquanto <code class="docutils literal notranslate"><span class="pre">&quot;\n&quot;</span></code> é uma string de um único caractere contendo uma nova linha. As expressões regulares, muitas vezes, são escritas no código Python usando esta notação de string crua (raw).</p>
<p>In addition, special escape sequences that are valid in regular expressions,
but not valid as Python string literals, now result in a
<a class="reference internal" href="../library/exceptions.html#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a> and will eventually become a <a class="reference internal" href="../library/exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a>,
which means the sequences will be invalid if raw string notation or escaping
the backslashes isn’t used.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 51%" />
<col style="width: 49%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><strong>String Regular</strong></p></th>
<th class="head"><p><strong>String Crua</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">&quot;ab*&quot;</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">r&quot;ab*&quot;</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">&quot;\\\\section&quot;</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">r&quot;\\section&quot;</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">&quot;\\w+\\s+\\1&quot;</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">r&quot;\w+\s+\1&quot;</span></code></p></td>
</tr>
</tbody>
</table>
</section>
<section id="performing-matches">
<h3>Executando Comparações<a class="headerlink" href="#performing-matches" title="Link permanente para este título">¶</a></h3>
<p>Uma vez que você tem um objeto que representa uma expressão regular compilada, o que você faz com ele? Objetos padrão têm vários métodos e atributos. Apenas os mais significativos serão vistos aqui; consulte a documentação do módulo <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> para uma lista completa.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 28%" />
<col style="width: 72%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><strong>Método/Atributo</strong></p></th>
<th class="head"><p>Purpose</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">match()</span></code></p></td>
<td><p>Determina se a RE combina com o início da string.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">search()</span></code></p></td>
<td><p>Varre toda a string, procurando qualquer local onde esta RE tem correspondência.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">findall()</span></code></p></td>
<td><p>Encontra todas as substrings onde a RE corresponde, e as retorna como uma lista.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">finditer()</span></code></p></td>
<td><p>Encontra todas as substrings onde a RE corresponde, e as retorna como um <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterador</span></a>.</p></td>
</tr>
</tbody>
</table>
<p><a class="reference internal" href="../library/re.html#re.Pattern.match" title="re.Pattern.match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">match()</span></code></a> and <a class="reference internal" href="../library/re.html#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a> return <code class="docutils literal notranslate"><span class="pre">None</span></code> if no match can be found.  If
they’re successful, a <a class="reference internal" href="../library/re.html#match-objects"><span class="std std-ref">match object</span></a> instance is returned,
containing information about the match: where it starts and ends, the substring
it matched, and more.</p>
<p>You can learn about this by interactively experimenting with the <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a>
module.  If you have <a class="reference internal" href="../library/tkinter.html#module-tkinter" title="tkinter: Interface to Tcl/Tk for graphical user interfaces"><code class="xref py py-mod docutils literal notranslate"><span class="pre">tkinter</span></code></a> available, you may also want to look at
<a class="reference external" href="https://github.com/python/cpython/tree/3.10/Tools/demo/redemo.py">Tools/demo/redemo.py</a>, a demonstration program included with the
Python distribution.  It allows you to enter REs and strings, and displays
whether the RE matches or fails. <code class="file docutils literal notranslate"><span class="pre">redemo.py</span></code> can be quite useful when
trying to debug a complicated RE.</p>
<p>Este HOWTO usa o interpretador Python padrão para seus exemplos. Primeiro, execute o interpretador Python, importe o modulo <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a>, e compile uma RE:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">re</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;[a-z]+&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span>
<span class="go">re.compile(&#39;[a-z]+&#39;)</span>
</pre></div>
</div>
<p>Now, you can try matching various strings against the RE <code class="docutils literal notranslate"><span class="pre">[a-z]+</span></code>.  An empty
string shouldn’t match at all, since <code class="docutils literal notranslate"><span class="pre">+</span></code> means ‘one or more repetitions’.
<a class="reference internal" href="../library/re.html#re.Pattern.match" title="re.Pattern.match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">match()</span></code></a> should return <code class="docutils literal notranslate"><span class="pre">None</span></code> in this case, which will cause the
interpreter to print no output.  You can explicitly print the result of
<code class="xref py py-meth docutils literal notranslate"><span class="pre">match()</span></code> to make this clear.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">))</span>
<span class="go">None</span>
</pre></div>
</div>
<p>Now, let’s try it on a string that it should match, such as <code class="docutils literal notranslate"><span class="pre">tempo</span></code>.  In this
case, <a class="reference internal" href="../library/re.html#re.Pattern.match" title="re.Pattern.match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">match()</span></code></a> will return a <a class="reference internal" href="../library/re.html#match-objects"><span class="std std-ref">match object</span></a>, so you
should store the result in a variable for later use.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;tempo&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span>
<span class="go">&lt;re.Match object; span=(0, 5), match=&#39;tempo&#39;&gt;</span>
</pre></div>
</div>
<p>Now you can query the <a class="reference internal" href="../library/re.html#match-objects"><span class="std std-ref">match object</span></a> for information
about the matching string.  Match object instances
also have several methods and attributes; the most important ones are:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 29%" />
<col style="width: 71%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><strong>Método/Atributo</strong></p></th>
<th class="head"><p>Purpose</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">group()</span></code></p></td>
<td><p>Retorna a string que corresponde com a RE</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">start()</span></code></p></td>
<td><p>Retorna a posição inicial da string correspondente</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">end()</span></code></p></td>
<td><p>Retorna a posição final da string correspondente</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">span()</span></code></p></td>
<td><p>Retorna uma tupla contendo as posições (inicial, final) da string combinada</p></td>
</tr>
</tbody>
</table>
<p>Experimentando estes métodos teremos seus significado esclarecidos:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
<span class="go">&#39;tempo&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> <span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
<span class="go">(0, 5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">span</span><span class="p">()</span>
<span class="go">(0, 5)</span>
</pre></div>
</div>
<p><a class="reference internal" href="../library/re.html#re.Match.group" title="re.Match.group"><code class="xref py py-meth docutils literal notranslate"><span class="pre">group()</span></code></a> returns the substring that was matched by the RE.  <a class="reference internal" href="../library/re.html#re.Match.start" title="re.Match.start"><code class="xref py py-meth docutils literal notranslate"><span class="pre">start()</span></code></a>
and <a class="reference internal" href="../library/re.html#re.Match.end" title="re.Match.end"><code class="xref py py-meth docutils literal notranslate"><span class="pre">end()</span></code></a> return the starting and ending index of the match. <a class="reference internal" href="../library/re.html#re.Match.span" title="re.Match.span"><code class="xref py py-meth docutils literal notranslate"><span class="pre">span()</span></code></a>
returns both start and end indexes in a single tuple.  Since the <a class="reference internal" href="../library/re.html#re.Pattern.match" title="re.Pattern.match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">match()</span></code></a>
method only checks if the RE matches at the start of a string, <code class="xref py py-meth docutils literal notranslate"><span class="pre">start()</span></code>
will always be zero.  However, the <a class="reference internal" href="../library/re.html#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a> method of patterns
scans through the string, so  the match may not start at zero in that
case.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;::: message&#39;</span><span class="p">))</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;::: message&#39;</span><span class="p">);</span> <span class="nb">print</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">&lt;re.Match object; span=(4, 11), match=&#39;message&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
<span class="go">&#39;message&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">span</span><span class="p">()</span>
<span class="go">(4, 11)</span>
</pre></div>
</div>
<p>Nos programas reais, o estilo mais comum é armazenar o <a class="reference internal" href="../library/re.html#match-objects"><span class="std std-ref">objeto Match</span></a> em uma variável e, em seguida, verificar se ela é <code class="docutils literal notranslate"><span class="pre">None</span></code>. Isso geralmente se parece com:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span> <span class="o">...</span> <span class="p">)</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">match</span><span class="p">(</span> <span class="s1">&#39;string goes here&#39;</span> <span class="p">)</span>
<span class="k">if</span> <span class="n">m</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Match found: &#39;</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">())</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;No match&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Two pattern methods return all of the matches for a pattern.
<a class="reference internal" href="../library/re.html#re.Pattern.findall" title="re.Pattern.findall"><code class="xref py py-meth docutils literal notranslate"><span class="pre">findall()</span></code></a> returns a list of matching strings:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\d+&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;12 drummers drumming, 11 pipers piping, 10 lords a-leaping&#39;</span><span class="p">)</span>
<span class="go">[&#39;12&#39;, &#39;11&#39;, &#39;10&#39;]</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">r</span></code> prefix, making the literal a raw string literal, is needed in this
example because escape sequences in a normal “cooked” string literal that are
not recognized by Python, as opposed to regular expressions, now result in a
<a class="reference internal" href="../library/exceptions.html#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a> and will eventually become a <a class="reference internal" href="../library/exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a>.  See
<a class="reference internal" href="#the-backslash-plague"><span class="std std-ref">A praga da barra invertida</span></a>.</p>
<p><a class="reference internal" href="../library/re.html#re.Pattern.findall" title="re.Pattern.findall"><code class="xref py py-meth docutils literal notranslate"><span class="pre">findall()</span></code></a> has to create the entire list before it can be returned as the
result.  The <a class="reference internal" href="../library/re.html#re.Pattern.finditer" title="re.Pattern.finditer"><code class="xref py py-meth docutils literal notranslate"><span class="pre">finditer()</span></code></a> method returns a sequence of
<a class="reference internal" href="../library/re.html#match-objects"><span class="std std-ref">match object</span></a> instances as an <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">iterator</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="s1">&#39;12 drummers drumming, 11 ... 10 ...&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">iterator</span>  
<span class="go">&lt;callable_iterator object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">iterator</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">span</span><span class="p">())</span>
<span class="gp">...</span>
<span class="go">(0, 2)</span>
<span class="go">(22, 24)</span>
<span class="go">(29, 31)</span>
</pre></div>
</div>
</section>
<section id="module-level-functions">
<h3>Funções de Nível de Módulo<a class="headerlink" href="#module-level-functions" title="Link permanente para este título">¶</a></h3>
<p>You don’t have to create a pattern object and call its methods; the
<a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> module also provides top-level functions called <a class="reference internal" href="../library/re.html#re.match" title="re.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">match()</span></code></a>,
<a class="reference internal" href="../library/re.html#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">search()</span></code></a>, <a class="reference internal" href="../library/re.html#re.findall" title="re.findall"><code class="xref py py-func docutils literal notranslate"><span class="pre">findall()</span></code></a>, <a class="reference internal" href="../library/re.html#re.sub" title="re.sub"><code class="xref py py-func docutils literal notranslate"><span class="pre">sub()</span></code></a>, and so forth.  These functions
take the same arguments as the corresponding pattern method with
the RE string added as the first argument, and still return either <code class="docutils literal notranslate"><span class="pre">None</span></code> or a
<a class="reference internal" href="../library/re.html#match-objects"><span class="std std-ref">match object</span></a> instance.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;From\s+&#39;</span><span class="p">,</span> <span class="s1">&#39;Fromage amk&#39;</span><span class="p">))</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;From\s+&#39;</span><span class="p">,</span> <span class="s1">&#39;From amk Thu May 14 19:12:10 1998&#39;</span><span class="p">)</span>  
<span class="go">&lt;re.Match object; span=(0, 5), match=&#39;From &#39;&gt;</span>
</pre></div>
</div>
<p>Under the hood, these functions simply create a pattern object for you
and call the appropriate method on it.  They also store the compiled
object in a cache, so future calls using the same RE won’t need to
parse the pattern again and again.</p>
<p>Should you use these module-level functions, or should you get the
pattern and call its methods yourself?  If you’re accessing a regex
within a loop, pre-compiling it will save a few function calls.
Outside of loops, there’s not much difference thanks to the internal
cache.</p>
</section>
<section id="compilation-flags">
<h3>Sinalizadores de Compilação<a class="headerlink" href="#compilation-flags" title="Link permanente para este título">¶</a></h3>
<p>Sinalizadores de compilação permitem modificar alguns aspectos de como as expressões regulares funcionam. Sinalizadores estão disponíveis no módulo <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> sob dois nomes, um nome longo, tal como <code class="xref py py-const docutils literal notranslate"><span class="pre">IGNORECASE</span></code> e um curto, na forma de uma letra, como <code class="xref py py-const docutils literal notranslate"><span class="pre">I</span></code>. (Se você estiver familiarizado com o padrão dos modificadores do Perl, o nome curto usa as mesmas letras; o forma abreviada de <a class="reference internal" href="../library/re.html#re.VERBOSE" title="re.VERBOSE"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.VERBOSE</span></code></a> é <a class="reference internal" href="../library/re.html#re.X" title="re.X"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.X</span></code></a>, por exemplo). Vários sinalizadores podem ser especificados aplicando um <code class="docutils literal notranslate"><span class="pre">OU</span></code> bit a bit nelas; <code class="docutils literal notranslate"><span class="pre">re.I</span> <span class="pre">|</span> <span class="pre">re.M</span></code> define os sinalizadores <code class="xref py py-const docutils literal notranslate"><span class="pre">I</span></code> e <code class="xref py py-const docutils literal notranslate"><span class="pre">M</span></code>, por exemplo.</p>
<p>Aqui está uma tabela dos sinalizadores disponíveis, seguida por uma explicação mais detalhada de cada um:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 43%" />
<col style="width: 57%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Sinalizador</p></th>
<th class="head"><p>Significado</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">A</span></code></p></td>
<td><p>Makes several escapes like <code class="docutils literal notranslate"><span class="pre">\w</span></code>, <code class="docutils literal notranslate"><span class="pre">\b</span></code>,
<code class="docutils literal notranslate"><span class="pre">\s</span></code> and <code class="docutils literal notranslate"><span class="pre">\d</span></code> match only on ASCII
characters with the respective property.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">DOTALL</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">S</span></code></p></td>
<td><p>Make <code class="docutils literal notranslate"><span class="pre">.</span></code> match any character, including
newlines.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">IGNORECASE</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">I</span></code></p></td>
<td><p>Faz combinações sem diferenciar maiúsculo de minúsculo</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">LOCALE</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">L</span></code></p></td>
<td><p>Faz uma correspondência considerando a localidade.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">MULTILINE</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">M</span></code></p></td>
<td><p>Correspondência multilinha, afetando <code class="docutils literal notranslate"><span class="pre">^</span></code> e <code class="docutils literal notranslate"><span class="pre">$</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">VERBOSE</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">X</span></code>
(for ‘extended’)</p></td>
<td><p>Habilita REs detalhadas, que podem ser organizadas de forma mais clara e compreensível.</p></td>
</tr>
</tbody>
</table>
<dl class="py data">
<dt>
<code class="sig-name descname">I</code></dt>
<dt>
<code class="sig-name descname">IGNORECASE</code></dt>
<dd><p>Perform case-insensitive matching; character class and literal strings will
match letters by ignoring case.  For example, <code class="docutils literal notranslate"><span class="pre">[A-Z]</span></code> will match lowercase
letters, too. Full Unicode matching also works unless the <code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code>
flag is used to disable non-ASCII matches.  When the Unicode patterns
<code class="docutils literal notranslate"><span class="pre">[a-z]</span></code> or <code class="docutils literal notranslate"><span class="pre">[A-Z]</span></code> are used in combination with the <code class="xref py py-const docutils literal notranslate"><span class="pre">IGNORECASE</span></code>
flag, they will match the 52 ASCII letters and 4 additional non-ASCII
letters: ‘İ’ (U+0130, Latin capital letter I with dot above), ‘ı’ (U+0131,
Latin small letter dotless i), ‘ſ’ (U+017F, Latin small letter long s) and
‘K’ (U+212A, Kelvin sign).  <code class="docutils literal notranslate"><span class="pre">Spam</span></code> will match <code class="docutils literal notranslate"><span class="pre">'Spam'</span></code>, <code class="docutils literal notranslate"><span class="pre">'spam'</span></code>,
<code class="docutils literal notranslate"><span class="pre">'spAM'</span></code>, or <code class="docutils literal notranslate"><span class="pre">'ſpam'</span></code> (the latter is matched only in Unicode mode).
This lowercasing doesn’t take the current locale into account;
it will if you also set the <code class="xref py py-const docutils literal notranslate"><span class="pre">LOCALE</span></code> flag.</p>
</dd></dl>

<dl class="py data">
<dt>
<code class="sig-name descname">L</code></dt>
<dt>
<code class="sig-name descname">LOCALE</code></dt>
<dd><p>Make <code class="docutils literal notranslate"><span class="pre">\w</span></code>, <code class="docutils literal notranslate"><span class="pre">\W</span></code>, <code class="docutils literal notranslate"><span class="pre">\b</span></code>, <code class="docutils literal notranslate"><span class="pre">\B</span></code> and case-insensitive matching dependent
on the current locale instead of the Unicode database.</p>
<p>Locales are a feature of the C library intended to help in writing programs
that take account of language differences.  For example, if you’re
processing encoded French text, you’d want to be able to write <code class="docutils literal notranslate"><span class="pre">\w+</span></code> to
match words, but <code class="docutils literal notranslate"><span class="pre">\w</span></code> only matches the character class <code class="docutils literal notranslate"><span class="pre">[A-Za-z]</span></code> in
bytes patterns; it won’t match bytes corresponding to <code class="docutils literal notranslate"><span class="pre">é</span></code> or <code class="docutils literal notranslate"><span class="pre">ç</span></code>.
If your system is configured properly and a French locale is selected,
certain C functions will tell the program that the byte corresponding to
<code class="docutils literal notranslate"><span class="pre">é</span></code> should also be considered a letter.
Setting the <code class="xref py py-const docutils literal notranslate"><span class="pre">LOCALE</span></code> flag when compiling a regular expression will cause
the resulting compiled object to use these C functions for <code class="docutils literal notranslate"><span class="pre">\w</span></code>; this is
slower, but also enables <code class="docutils literal notranslate"><span class="pre">\w+</span></code> to match French words as you’d expect.
The use of this flag is discouraged in Python 3 as the locale mechanism
is very unreliable, it only handles one “culture” at a time, and it only
works with 8-bit locales.  Unicode matching is already enabled by default
in Python 3 for Unicode (str) patterns, and it is able to handle different
locales/languages.</p>
</dd></dl>

<dl class="py data">
<dt>
<code class="sig-name descname">M</code></dt>
<dt>
<code class="sig-name descname">MULTILINE</code></dt>
<dd><p>(<code class="docutils literal notranslate"><span class="pre">^</span></code> e <code class="docutils literal notranslate"><span class="pre">$</span></code> ainda não foram explicados, eles serão comentados na seção <a class="reference internal" href="#more-metacharacters"><span class="std std-ref">Mais Metacaracteres</span></a>.)</p>
<p>Normalmente <code class="docutils literal notranslate"><span class="pre">^</span></code> corresponde apenas ao início da string e <code class="docutils literal notranslate"><span class="pre">$</span></code> corresponde apenas ao final da string, e imediatamente antes da nova linha (se existir) no final da string. Quando este sinalizador é especificada, o <code class="docutils literal notranslate"><span class="pre">^</span></code> corresponde ao início da string e ao início de cada linha dentro da string, imediatamente após cada nova linha. Da mesma forma, o metacaractere <code class="docutils literal notranslate"><span class="pre">$</span></code> corresponde tanto ao final da string e ao final de cada linha (imediatamente antes de cada nova linha).</p>
</dd></dl>

<dl class="py data">
<dt>
<code class="sig-name descname">S</code></dt>
<dt>
<code class="sig-name descname">DOTALL</code></dt>
<dd><p>Faz o caractere especial <code class="docutils literal notranslate"><span class="pre">.</span></code> corresponder com qualquer caractere que seja, incluindo o nova linha; sem este sinalizador, <code class="docutils literal notranslate"><span class="pre">.</span></code> irá corresponder a qualquer coisa, exceto o nova linha.</p>
</dd></dl>

<dl class="py data">
<dt>
<code class="sig-name descname">A</code></dt>
<dt>
<code class="sig-name descname">ASCII</code></dt>
<dd><p>Make <code class="docutils literal notranslate"><span class="pre">\w</span></code>, <code class="docutils literal notranslate"><span class="pre">\W</span></code>, <code class="docutils literal notranslate"><span class="pre">\b</span></code>, <code class="docutils literal notranslate"><span class="pre">\B</span></code>, <code class="docutils literal notranslate"><span class="pre">\s</span></code> and <code class="docutils literal notranslate"><span class="pre">\S</span></code> perform ASCII-only
matching instead of full Unicode matching. This is only meaningful for
Unicode patterns, and is ignored for byte patterns.</p>
</dd></dl>

<dl class="py data">
<dt>
<code class="sig-name descname">X</code></dt>
<dt>
<code class="sig-name descname">VERBOSE</code></dt>
<dd><p>Este sinalizador permite escrever expressões regulares mais legíveis, permitindo mais flexibilidade na maneira de formatá-la. Quando este sinalizador é especificado, o espaço em branco dentro da string RE é ignorado, exceto quando o espaço em branco está em uma classe de caracteres ou precedido por uma barra invertida não “escapada”; isto permite organizar e formatar a RE de maneira mais clara. Este sinalizador também permite que se coloque comentários dentro de uma RE que serão ignorados pelo mecanismo; os comentários são marcados por um “#” que não está nem em uma classe de caracteres nem precedido por uma barra invertida não “escapada”. Por exemplo, aqui está uma RE que usa re.VERBOSE; veja, o quanto mais fácil de ler é ?</p>
<p>Por exemplo, aqui está uma RE que usa <a class="reference internal" href="../library/re.html#re.VERBOSE" title="re.VERBOSE"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.VERBOSE</span></code></a>; veja, o quanto mais fácil de ler é?</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">charref</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2"> &amp;[#]                # Start of a numeric entity reference</span>
<span class="s2"> (</span>
<span class="s2">     0[0-7]+         # Octal form</span>
<span class="s2">   | [0-9]+          # Decimal form</span>
<span class="s2">   | x[0-9a-fA-F]+   # Hexadecimal form</span>
<span class="s2"> )</span>
<span class="s2"> ;                   # Trailing semicolon</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">VERBOSE</span><span class="p">)</span>
</pre></div>
</div>
<p>Sem o “verbose” definido, A RE iria se parecer como isto:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">charref</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;&amp;#(0[0-7]+&quot;</span>
                     <span class="s2">&quot;|[0-9]+&quot;</span>
                     <span class="s2">&quot;|x[0-9a-fA-F]+);&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>No exemplo acima, a concatenação automática de strings literais em Python foi usada para quebrar a RE em partes menores, mas ainda é mais difícil de entender do que a versão que usa <a class="reference internal" href="../library/re.html#re.VERBOSE" title="re.VERBOSE"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.VERBOSE</span></code></a>.</p>
</dd></dl>

</section>
</section>
<section id="more-pattern-power">
<h2>Mais Poder dos Padrões<a class="headerlink" href="#more-pattern-power" title="Link permanente para este título">¶</a></h2>
<p>Até agora, cobrimos apenas uma parte dos recursos das expressões regulares. Nesta seção, vamos abordar alguns metacaracteres novos, e como usar grupos para recuperar partes do texto que teve correspondência.</p>
<section id="more-metacharacters">
<span id="id2"></span><h3>Mais Metacaracteres<a class="headerlink" href="#more-metacharacters" title="Link permanente para este título">¶</a></h3>
<p>Existem alguns metacaracteres que nós ainda não vimos. A maioria deles serão referenciados nesta seção.</p>
<p>Alguns dos metacaracteres restantes a serem discutidos são como uma afirmação de <code class="docutils literal notranslate"><span class="pre">largura</span> <span class="pre">zero</span></code> (zero-width assertions). Eles não fazem com que o mecanismo avance pela string; ao contrário, eles não consomem nenhum caractere, e simplesmente tem sucesso ou falha. Por exemplo, <code class="docutils literal notranslate"><span class="pre">\b</span></code> é uma afirmação de que a posição atual está localizada nas bordas de uma palavra; a posição não é alterada de nenhuma maneira por <code class="docutils literal notranslate"><span class="pre">\b</span></code>. Isto significa que afirmações de <code class="docutils literal notranslate"><span class="pre">largura</span> <span class="pre">zero</span></code> nunca devem ser repetidas, porque se elas combinam uma vez em um determinado local, elas podem, obviamente, combinar um número infinito de vezes.</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">|</span></code></dt><dd><p>Alternation, or the “or” operator.   If <em>A</em> and <em>B</em> are regular expressions,
<code class="docutils literal notranslate"><span class="pre">A|B</span></code> will match any string that matches either <em>A</em> or <em>B</em>. <code class="docutils literal notranslate"><span class="pre">|</span></code> has very
low precedence in order to make it work reasonably when you’re alternating
multi-character strings. <code class="docutils literal notranslate"><span class="pre">Crow|Servo</span></code> will match either <code class="docutils literal notranslate"><span class="pre">'Crow'</span></code> or <code class="docutils literal notranslate"><span class="pre">'Servo'</span></code>,
not <code class="docutils literal notranslate"><span class="pre">'Cro'</span></code>, a <code class="docutils literal notranslate"><span class="pre">'w'</span></code> or an <code class="docutils literal notranslate"><span class="pre">'S'</span></code>, and <code class="docutils literal notranslate"><span class="pre">'ervo'</span></code>.</p>
<p>Para corresponder com um <code class="docutils literal notranslate"><span class="pre">'|'</span></code> literal, use <code class="docutils literal notranslate"><span class="pre">\|</span></code>, ou coloque ele dentro de uma classe de caracteres, como em <code class="docutils literal notranslate"><span class="pre">[|]</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">^</span></code></dt><dd><p>Corresponde ao início de linha. A menos que o sinalizador <code class="xref py py-const docutils literal notranslate"><span class="pre">MULTILINE</span></code> tenha sido definido, isso só irá corresponder ao início da string. No modo <code class="xref py py-const docutils literal notranslate"><span class="pre">MULTILINE</span></code>, isso também corresponde imediatamente após cada nova linha de dentro da string.</p>
<p>Por exemplo, para ter correspondência com a palavra <code class="docutils literal notranslate"><span class="pre">From</span></code> apenas no início de uma linha, aRE a ser usada é <code class="docutils literal notranslate"><span class="pre">^From</span></code>.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;^From&#39;</span><span class="p">,</span> <span class="s1">&#39;From Here to Eternity&#39;</span><span class="p">))</span>  
<span class="go">&lt;re.Match object; span=(0, 4), match=&#39;From&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;^From&#39;</span><span class="p">,</span> <span class="s1">&#39;Reciting From Memory&#39;</span><span class="p">))</span>
<span class="go">None</span>
</pre></div>
</div>
<p>To match a literal <code class="docutils literal notranslate"><span class="pre">'^'</span></code>, use <code class="docutils literal notranslate"><span class="pre">\^</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">$</span></code></dt><dd><p>Corresponde ao fim de uma linha, que tanto é definido como o fim de uma string, ou qualquer local seguido por um caractere de nova linha.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;}$&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">{block}</span><span class="s1">&#39;</span><span class="p">))</span>  
<span class="go">&lt;re.Match object; span=(6, 7), match=&#39;}&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;}$&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">{block}</span><span class="s1"> &#39;</span><span class="p">))</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;}$&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">{block}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">))</span>  
<span class="go">&lt;re.Match object; span=(6, 7), match=&#39;}&#39;&gt;</span>
</pre></div>
</div>
<p>Para corresponder com um <code class="docutils literal notranslate"><span class="pre">$</span></code> literal, use <code class="docutils literal notranslate"><span class="pre">\$</span></code> ou coloque-o dentro de uma classe de caracteres, como em <code class="docutils literal notranslate"><span class="pre">[$]</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">\A</span></code></dt><dd><p>Corresponde apenas com o início da string. Quando não estiver em modo <code class="xref py py-const docutils literal notranslate"><span class="pre">MULTILINE</span></code>, <code class="docutils literal notranslate"><span class="pre">\A</span></code> e <code class="docutils literal notranslate"><span class="pre">^</span></code> são efetivamente a mesma coisa. No modo <code class="xref py py-const docutils literal notranslate"><span class="pre">MULTILINE</span></code>, eles são diferentes: <code class="docutils literal notranslate"><span class="pre">\A</span></code> continua a corresponder apenas com o início da string, mas <code class="docutils literal notranslate"><span class="pre">^</span></code> pode corresponder com qualquer localização de dentro da string, que seja posterior a um caractere nova linha.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">\Z</span></code></dt><dd><p>Corresponde apenas ao final da string.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">\b</span></code></dt><dd><p>Borda de palavra. Esta é uma afirmação de <code class="docutils literal notranslate"><span class="pre">largura</span> <span class="pre">zero</span></code> que corresponde apenas ao início ou ao final de uma palavra. Uma palavra é definida como uma sequência de caracteres alfanuméricos, de modo que o fim de uma palavra é indicado por espaços em branco ou um caractere não alfanumérico.</p>
<p>O exemplo a seguir corresponde a <code class="docutils literal notranslate"><span class="pre">class</span></code> apenas quando é a palavra exata; ele não irá corresponder quando for contido dentro de uma outra palavra.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\bclass\b&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;no class at all&#39;</span><span class="p">))</span>
<span class="go">&lt;re.Match object; span=(3, 8), match=&#39;class&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;the declassified algorithm&#39;</span><span class="p">))</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;one subclass is&#39;</span><span class="p">))</span>
<span class="go">None</span>
</pre></div>
</div>
<p>Há duas sutilezas você deve lembrar ao usar essa sequência especial. Em primeiro lugar, esta é a pior colisão entre strings literais do Python e sequências de expressão regular. Nas strings literais do Python, <code class="docutils literal notranslate"><span class="pre">\b</span></code> é o caractere backspace, o valor ASCII 8. Se você não estiver usando strings cruas (raw), então Python irá converter o <code class="docutils literal notranslate"><span class="pre">\b</span></code> em um backspace e sua RE não irá funcionar da maneira que você espera. O exemplo a seguir parece igual a nossa RE anterior, mas omite o <code class="docutils literal notranslate"><span class="pre">r</span></code> na frente da string RE.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\b</span><span class="s1">class</span><span class="se">\b</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;no class at all&#39;</span><span class="p">))</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\b</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="s1">&#39;class&#39;</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\b</span><span class="s1">&#39;</span><span class="p">))</span>
<span class="go">&lt;re.Match object; span=(0, 7), match=&#39;\x08class\x08&#39;&gt;</span>
</pre></div>
</div>
<p>Além disso, dentro de uma classe de caracteres, onde não há nenhum uso para esta afirmação, <code class="docutils literal notranslate"><span class="pre">\b</span></code> representa o caractere backspace, para compatibilidade com strings literais do Python</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">\B</span></code></dt><dd><p>Outra afirmação de <code class="docutils literal notranslate"><span class="pre">largura</span> <span class="pre">zero</span></code>; isto é o oposto de <code class="docutils literal notranslate"><span class="pre">\b</span></code>, correspondendo apenas quando a posição corrente não é de uma borda de palavra.</p>
</dd>
</dl>
</section>
<section id="grouping">
<h3>Agrupamento<a class="headerlink" href="#grouping" title="Link permanente para este título">¶</a></h3>
<p>Frequently you need to obtain more information than just whether the RE matched
or not.  Regular expressions are often used to dissect strings by writing a RE
divided into several subgroups which match different components of interest.
For example, an RFC-822 header line is divided into a header name and a value,
separated by a <code class="docutils literal notranslate"><span class="pre">':'</span></code>, like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>From: author@example.com
User-Agent: Thunderbird 1.5.0.9 (X11/20061227)
MIME-Version: 1.0
To: editor@example.com
</pre></div>
</div>
<p>Isto pode ser gerenciado ao escrever uma expressão regular que corresponde com uma linha inteira de cabeçalho, e tem um grupo que corresponde ao nome do cabeçalho, e um outro grupo, que corresponde ao valor do cabeçalho. Os grupos são marcados pelos metacaracteres <code class="docutils literal notranslate"><span class="pre">(</span></code> e <code class="docutils literal notranslate"><span class="pre">)</span></code>. <code class="docutils literal notranslate"><span class="pre">(</span></code> e <code class="docutils literal notranslate"><span class="pre">)</span></code> têm muito do mesmo significado que eles têm em expressões matemáticas; eles agrupam as expressões contidas dentro deles, e você pode repetir o conteúdo de um grupo com um qualificador de repetição, como <code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">?</span></code>, ou <code class="docutils literal notranslate"><span class="pre">{m,n}</span></code>. Por exemplo, <code class="docutils literal notranslate"><span class="pre">(ab)*</span></code> irá corresponder a zero ou mais repetições de <code class="docutils literal notranslate"><span class="pre">ab</span></code>.</p>
<p>Grupos indicados com <code class="docutils literal notranslate"><span class="pre">(</span></code> e <code class="docutils literal notranslate"><span class="pre">)</span></code> também capturam o índice inicial e final do texto que eles correspondem; isso pode ser obtido por meio da passagem de um argumento para <code class="docutils literal notranslate"><span class="pre">group()</span></code>, <code class="docutils literal notranslate"><span class="pre">start()</span></code>, <code class="docutils literal notranslate"><span class="pre">end()</span></code>, e <code class="docutils literal notranslate"><span class="pre">span()</span></code>. Os grupos são numerados começando com 0. O grupo 0 está sempre presente; é toda a RE, logo, todos os métodos MatchObject têm o grupo 0 como seu argumento padrão. Mais tarde veremos como expressar grupos que não capturam a extensão de texto com a qual eles correspondem.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;(ab)*&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;ababababab&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">span</span><span class="p">())</span>
<span class="go">(0, 10)</span>
</pre></div>
</div>
<p>Groups indicated with <code class="docutils literal notranslate"><span class="pre">'('</span></code>, <code class="docutils literal notranslate"><span class="pre">')'</span></code> also capture the starting and ending
index of the text that they match; this can be retrieved by passing an argument
to <a class="reference internal" href="../library/re.html#re.Match.group" title="re.Match.group"><code class="xref py py-meth docutils literal notranslate"><span class="pre">group()</span></code></a>, <a class="reference internal" href="../library/re.html#re.Match.start" title="re.Match.start"><code class="xref py py-meth docutils literal notranslate"><span class="pre">start()</span></code></a>, <a class="reference internal" href="../library/re.html#re.Match.end" title="re.Match.end"><code class="xref py py-meth docutils literal notranslate"><span class="pre">end()</span></code></a>, and
<a class="reference internal" href="../library/re.html#re.Match.span" title="re.Match.span"><code class="xref py py-meth docutils literal notranslate"><span class="pre">span()</span></code></a>.  Groups are
numbered starting with 0.  Group 0 is always present; it’s the whole RE, so
<a class="reference internal" href="../library/re.html#match-objects"><span class="std std-ref">match object</span></a> methods all have group 0 as their default
argument.  Later we’ll see how to express groups that don’t capture the span
of text that they match.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;(a)b&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;ab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
<span class="go">&#39;ab&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">&#39;ab&#39;</span>
</pre></div>
</div>
<p>Subgrupos são numerados a partir da esquerda para a direita, de forma crescente a partir de 1. Os grupos podem ser aninhados; para determinar o número, basta contar os caracteres de abertura de parêntese - <code class="docutils literal notranslate"><span class="pre">(</span></code>, indo da esquerda para a direita.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;(a(b)c)d&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;abcd&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">&#39;abcd&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">&#39;abc&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">&#39;b&#39;</span>
</pre></div>
</div>
<p><a class="reference internal" href="../library/re.html#re.Match.group" title="re.Match.group"><code class="xref py py-meth docutils literal notranslate"><span class="pre">group()</span></code></a> can be passed multiple group numbers at a time, in which case it
will return a tuple containing the corresponding values for those groups.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="go">(&#39;b&#39;, &#39;abc&#39;, &#39;b&#39;)</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="../library/re.html#re.Match.groups" title="re.Match.groups"><code class="xref py py-meth docutils literal notranslate"><span class="pre">groups()</span></code></a> method returns a tuple containing the strings for all the
subgroups, from 1 up to however many there are.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>
<span class="go">(&#39;abc&#39;, &#39;b&#39;)</span>
</pre></div>
</div>
<p>Referências anteriores em um padrão permitem que você especifique que o conteúdo de um grupo capturado anteriormente também deve ser encontrado na posição atual na sequência. Por exemplo, <code class="docutils literal notranslate"><span class="pre">\1</span></code> terá sucesso se o conteúdo exato do grupo 1 puder ser encontrado na posição atual, e falhar caso contrário. Lembre-se que as strings literais do Python também usam a barra invertida seguida por números para permitir a inclusão de caracteres arbitrários em uma string, por isso certifique-se de usar strings cruas (raw) ao incorporar referências anteriores em uma RE.</p>
<p>Por exemplo, a seguinte RE detecta palavras duplicadas em uma string.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\b(\w+)\s+\1\b&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;Paris in the the spring&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
<span class="go">&#39;the the&#39;</span>
</pre></div>
</div>
<p>Referências anteriores como esta não são, geralmente, muito úteis apenas para fazer pesquisa percorrendo uma string — existem alguns formatos de texto que repetem dados dessa forma — mas em breve você irá descobrir que elas são muito úteis para realizar substituições de strings.</p>
</section>
<section id="non-capturing-and-named-groups">
<h3>Não captura e Grupos Nomeados<a class="headerlink" href="#non-capturing-and-named-groups" title="Link permanente para este título">¶</a></h3>
<p>REs elaboradas podem usar muitos grupos, tanto para capturar substrings de interesse, quanto para agrupar e estruturar a própria RE. Em REs complexas, torna-se difícil manter o controle dos números dos grupos. Existem dois recursos que ajudam a lidar com esse problema. Ambos usam uma sintaxe comum para extensões de expressão regular, então vamos olhar para isso em primeiro lugar.</p>
<p>Perl 5 is well known for its powerful additions to standard regular expressions.
For these new features the Perl developers couldn’t choose new single-keystroke metacharacters
or new special sequences beginning with <code class="docutils literal notranslate"><span class="pre">\</span></code> without making Perl’s regular
expressions confusingly different from standard REs.  If they chose <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> as a
new metacharacter, for example, old expressions would be assuming that <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> was
a regular character and wouldn’t have escaped it by writing <code class="docutils literal notranslate"><span class="pre">\&amp;</span></code> or <code class="docutils literal notranslate"><span class="pre">[&amp;]</span></code>.</p>
<p>A solução escolhida pelos desenvolvedores do Perl foi usar <code class="docutils literal notranslate"><span class="pre">(?...)</span></code> como uma sintaxe de extensão. Um <code class="docutils literal notranslate"><span class="pre">?</span></code> imediatamente após um parêntese era um erro de sintaxe porque o <code class="docutils literal notranslate"><span class="pre">?</span></code> não teria nada a repetir, de modo que isso não introduz quaisquer problemas de compatibilidade. Os caracteres imediatamente após um <code class="docutils literal notranslate"><span class="pre">?</span></code> indicam que a extensão está sendo usada, então <code class="docutils literal notranslate"><span class="pre">(?=foo)</span></code> é uma coisa (uma afirmação <code class="docutils literal notranslate"><span class="pre">lookahead</span></code> positiva) e <code class="docutils literal notranslate"><span class="pre">(?:foo)</span></code> é outra coisa (um grupo de não captura contendo a subexpressão <code class="docutils literal notranslate"><span class="pre">foo</span></code>).</p>
<p>Python supports several of Perl’s extensions and adds an extension
syntax to Perl’s extension syntax.  If the first character after the
question mark is a <code class="docutils literal notranslate"><span class="pre">P</span></code>, you know that it’s an extension that’s
specific to Python.</p>
<p>Now that we’ve looked at the general extension syntax, we can return
to the features that simplify working with groups in complex REs.</p>
<p>Sometimes you’ll want to use a group to denote a part of a regular expression,
but aren’t interested in retrieving the group’s contents. You can make this fact
explicit by using a non-capturing group: <code class="docutils literal notranslate"><span class="pre">(?:...)</span></code>, where you can replace the
<code class="docutils literal notranslate"><span class="pre">...</span></code> with any other regular expression.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;([abc])+&quot;</span><span class="p">,</span> <span class="s2">&quot;abc&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>
<span class="go">(&#39;c&#39;,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;(?:[abc])+&quot;</span><span class="p">,</span> <span class="s2">&quot;abc&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>
<span class="go">()</span>
</pre></div>
</div>
<p>Exceto pelo fato de que não é possível recuperar o conteúdo sobre o qual o grupo corresponde, um grupo de não captura se comporta exatamente da mesma forma que um grupo de captura; você pode colocar qualquer coisa dentro dele, repeti-lo com um metacaractere de repetição, como o ‘*’, e aninhá-lo dentro de outros grupos (de captura ou não captura). <code class="docutils literal notranslate"><span class="pre">(?:...)</span></code> é particularmente útil para modificar um padrão existente, já que você pode adicionar novos grupos sem alterar a forma como todos os outros grupos estão numerados. Deve ser mencionado que não há diferença de desempenho na busca entre grupos de captura e grupos de não captura; uma forma não é mais rápida que outra.</p>
<p>Uma característica mais significativa são os grupos nomeados: em vez de se referir a eles por números, os grupos podem ser referenciados por um nome.</p>
<p>The syntax for a named group is one of the Python-specific extensions:
<code class="docutils literal notranslate"><span class="pre">(?P&lt;name&gt;...)</span></code>.  <em>name</em> is, obviously, the name of the group.  Named groups
behave exactly like capturing groups, and additionally associate a name
with a group.  The <a class="reference internal" href="../library/re.html#match-objects"><span class="std std-ref">match object</span></a> methods that deal with
capturing groups all accept either integers that refer to the group by number
or strings that contain the desired group’s name.  Named groups are still
given numbers, so you can retrieve information about a group in two ways:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(?P&lt;word&gt;\b\w+\b)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">search</span><span class="p">(</span> <span class="s1">&#39;(((( Lots of punctuation )))&#39;</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;word&#39;</span><span class="p">)</span>
<span class="go">&#39;Lots&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">&#39;Lots&#39;</span>
</pre></div>
</div>
<p>Additionally, you can retrieve named groups as a dictionary with
<a class="reference internal" href="../library/re.html#re.Match.groupdict" title="re.Match.groupdict"><code class="xref py py-meth docutils literal notranslate"><span class="pre">groupdict()</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(?P&lt;first&gt;\w+) (?P&lt;last&gt;\w+)&#39;</span><span class="p">,</span> <span class="s1">&#39;Jane Doe&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">groupdict</span><span class="p">()</span>
<span class="go">{&#39;first&#39;: &#39;Jane&#39;, &#39;last&#39;: &#39;Doe&#39;}</span>
</pre></div>
</div>
<p>Os grupos nomeados são úteis porque eles permitem que você use nomes de fácil lembrança, em vez de ter que lembrar de números. Aqui está um exemplo de RE usando o módulo <a class="reference internal" href="../library/imaplib.html#module-imaplib" title="imaplib: IMAP4 protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">imaplib</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">InternalDate</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;INTERNALDATE &quot;&#39;</span>
        <span class="sa">r</span><span class="s1">&#39;(?P&lt;day&gt;[ 123][0-9])-(?P&lt;mon&gt;[A-Z][a-z][a-z])-&#39;</span>
        <span class="sa">r</span><span class="s1">&#39;(?P&lt;year&gt;[0-9][0-9][0-9][0-9])&#39;</span>
        <span class="sa">r</span><span class="s1">&#39; (?P&lt;hour&gt;[0-9][0-9]):(?P&lt;min&gt;[0-9][0-9]):(?P&lt;sec&gt;[0-9][0-9])&#39;</span>
        <span class="sa">r</span><span class="s1">&#39; (?P&lt;zonen&gt;[-+])(?P&lt;zoneh&gt;[0-9][0-9])(?P&lt;zonem&gt;[0-9][0-9])&#39;</span>
        <span class="sa">r</span><span class="s1">&#39;&quot;&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>É obviamente muito mais fácil fazer referência a <code class="docutils literal notranslate"><span class="pre">m.group('zonem')</span></code>, do que ter que se lembrar de capturar o grupo 9.</p>
<p>The syntax for backreferences in an expression such as <code class="docutils literal notranslate"><span class="pre">(...)\1</span></code> refers to the
number of the group.  There’s naturally a variant that uses the group name
instead of the number. This is another Python extension: <code class="docutils literal notranslate"><span class="pre">(?P=name)</span></code> indicates
that the contents of the group called <em>name</em> should again be matched at the
current point.  The regular expression for finding doubled words,
<code class="docutils literal notranslate"><span class="pre">\b(\w+)\s+\1\b</span></code> can also be written as <code class="docutils literal notranslate"><span class="pre">\b(?P&lt;word&gt;\w+)\s+(?P=word)\b</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\b(?P&lt;word&gt;\w+)\s+(?P=word)\b&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;Paris in the the spring&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
<span class="go">&#39;the the&#39;</span>
</pre></div>
</div>
</section>
<section id="lookahead-assertions">
<h3>Afirmação Lookahead<a class="headerlink" href="#lookahead-assertions" title="Link permanente para este título">¶</a></h3>
<p>Outra afirmação de “largura zero” é a afirmação lookahead. Afirmações LookAhead estão disponíveis tanto na forma positiva quanto na negativa, e se parece com isto:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">(?=...)</span></code></dt><dd><p>Afirmação lookahead positiva. Retorna sucesso se a expressão regular informada, aqui representada por <code class="docutils literal notranslate"><span class="pre">...</span></code>, corresponde com o conteúdo da localização atual, e retorna falha caso contrário. Mas, uma vez que a expressão informada tenha sido testada, o mecanismo de correspondência não faz qualquer avanço; o resto do padrão é tentado no mesmo local de onde a afirmação foi iniciada.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">(?!...)</span></code></dt><dd><p>Afirmação lookahead negativa. É o oposto da afirmação positiva; será bem-sucedida se a expressão informada não corresponder com o conteúdo da posição atual na string.</p>
</dd>
</dl>
<p>Para tornar isto concreto, vamos olhar para um caso em que um lookahead é útil. Considere um padrão simples para corresponder com um nome de arquivo e divida-o em pedaços, um nome base e uma extensão, separados por um <code class="docutils literal notranslate"><span class="pre">.</span></code>. Por exemplo, em <code class="docutils literal notranslate"><span class="pre">news.rc,news</span></code> é o nome base, e <code class="docutils literal notranslate"><span class="pre">rc</span></code> é a extensão do nome de arquivo.</p>
<p>O padrão para corresponder com isso é muito simples:</p>
<p><code class="docutils literal notranslate"><span class="pre">.*[.].*$</span></code></p>
<p>Notice that the <code class="docutils literal notranslate"><span class="pre">.</span></code> needs to be treated specially because it’s a
metacharacter, so it’s inside a character class to only match that
specific character.  Also notice the trailing <code class="docutils literal notranslate"><span class="pre">$</span></code>; this is added to
ensure that all the rest of the string must be included in the
extension.  This regular expression matches <code class="docutils literal notranslate"><span class="pre">foo.bar</span></code> and
<code class="docutils literal notranslate"><span class="pre">autoexec.bat</span></code> and <code class="docutils literal notranslate"><span class="pre">sendmail.cf</span></code> and <code class="docutils literal notranslate"><span class="pre">printers.conf</span></code>.</p>
<p>Agora, considere complicar um pouco o problema; e se você desejar corresponder com nomes de arquivos onde a extensão não é <code class="docutils literal notranslate"><span class="pre">bat</span></code>? Algumas tentativas incorretas:</p>
<p><code class="docutils literal notranslate"><span class="pre">.*[.][^b].*$</span></code> A primeira tentativa acima tenta excluir bat, exigindo que o primeiro caractere da extensão não é um b. Isso é errado, porque o padrão também não corresponde a <code class="docutils literal notranslate"><span class="pre">foo.bar</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">.*[.]([^b]..|.[^a].|..[^t])$</span></code></p>
<p>A expressão fica mais confusa se você tentar remendar a primeira solução, exigindo que uma das seguintes situações corresponda: o primeiro caractere da extensão não é <code class="docutils literal notranslate"><span class="pre">b</span></code>; o segundo caractere não é <code class="docutils literal notranslate"><span class="pre">a</span></code>; ou o terceiro caractere não é <code class="docutils literal notranslate"><span class="pre">t</span></code>. Isso aceita <code class="docutils literal notranslate"><span class="pre">foo.bar</span></code> e rejeita <code class="docutils literal notranslate"><span class="pre">autoexec.bat</span></code>, mas requer uma extensão de três letras e não aceitará um nome de arquivo com uma extensão de duas letras, tal como <code class="docutils literal notranslate"><span class="pre">sendmail.cf</span></code>. Nós iremos complicar o padrão novamente em um esforço para corrigi-lo.</p>
<p><code class="docutils literal notranslate"><span class="pre">.*[.]([^b].?.?|.[^a]?.?|..?[^t]?)$</span></code></p>
<p>Na terceira tentativa, a segunda e terceira letras são todas consideradas opcionais, a fim de permitir correspondência com as extensões mais curtas do que três caracteres, tais como <code class="docutils literal notranslate"><span class="pre">sendmail.cf</span></code>.</p>
<p>O padrão está ficando realmente muito complicado agora, o que faz com que seja difícil de ler e compreender. Pior ainda, se o problema mudar e você quiser excluir tanto <code class="docutils literal notranslate"><span class="pre">bat</span></code> quanto <code class="docutils literal notranslate"><span class="pre">exe</span></code> como extensões, o padrão iria ficar ainda mais complicado e confuso.</p>
<p>Um lookahead negativo elimina toda esta confusão:</p>
<p><code class="docutils literal notranslate"><span class="pre">.*[.](?!bat$).*$</span></code> O lookahead negativo significa: se a expressão <code class="docutils literal notranslate"><span class="pre">bat</span></code> não corresponder até este momento, tente o resto do padrão; se <code class="docutils literal notranslate"><span class="pre">bat$</span></code> tem correspondência, todo o padrão irá falhar. O final <code class="docutils literal notranslate"><span class="pre">$</span></code> é necessário para garantir que algo como <code class="docutils literal notranslate"><span class="pre">sample.batch</span></code>, onde a extensão só começa com o <code class="docutils literal notranslate"><span class="pre">bat</span></code>, será permitido.</p>
<p>Excluir uma outra extensão de nome de arquivo agora é fácil; basta fazer a adição de uma alternativa dentro da afirmação. O padrão a seguir exclui os nomes de arquivos que terminam com <code class="docutils literal notranslate"><span class="pre">bat</span></code> ou <code class="docutils literal notranslate"><span class="pre">exe</span></code>:</p>
<p><code class="docutils literal notranslate"><span class="pre">.*[.](?!bat$|exe$)[^.]*$</span></code></p>
</section>
</section>
<section id="modifying-strings">
<h2>Modificando Strings<a class="headerlink" href="#modifying-strings" title="Link permanente para este título">¶</a></h2>
<p>Até este ponto, nós simplesmente realizamos pesquisas em uma string estática. As expressões regulares também são comumente usadas para modificar strings através de várias maneiras, usando os seguintes métodos padrão:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 28%" />
<col style="width: 72%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><strong>Método/Atributo</strong></p></th>
<th class="head"><p>Purpose</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">split()</span></code></p></td>
<td><p>Divide a string em uma lista, dividindo-a onde quer que haja correspondência com a RE</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">sub()</span></code></p></td>
<td><p>Encontra todas as substrings que correspondem com a RE e faz a substituição por uma string diferente</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">subn()</span></code></p></td>
<td><p>Does the same thing as <code class="xref py py-meth docutils literal notranslate"><span class="pre">sub()</span></code>,  but
returns the new string and the number of
replacements</p></td>
</tr>
</tbody>
</table>
<section id="splitting-strings">
<h3>Dividindo as Strings<a class="headerlink" href="#splitting-strings" title="Link permanente para este título">¶</a></h3>
<p>The <a class="reference internal" href="../library/re.html#re.Pattern.split" title="re.Pattern.split"><code class="xref py py-meth docutils literal notranslate"><span class="pre">split()</span></code></a> method of a pattern splits a string apart
wherever the RE matches, returning a list of the pieces. It’s similar to the
<a class="reference internal" href="../library/stdtypes.html#str.split" title="str.split"><code class="xref py py-meth docutils literal notranslate"><span class="pre">split()</span></code></a> method of strings but provides much more generality in the
delimiters that you can split by; string <code class="xref py py-meth docutils literal notranslate"><span class="pre">split()</span></code> only supports splitting by
whitespace or by a fixed string.  As you’d expect, there’s a module-level
<a class="reference internal" href="../library/re.html#re.split" title="re.split"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.split()</span></code></a> function, too.</p>
<dl class="py method">
<dt>
<code class="sig-prename descclassname">.</code><code class="sig-name descname">split</code><span class="sig-paren">(</span><em class="sig-param">string</em><span class="optional">[</span>, <em class="sig-param">maxsplit=0</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>Divide a string usando a correspondência com uma expressão regular. Se os parênteses de captura forem utilizados na RE, então seu conteúdo também será retornado como parte da lista resultante. Se maxsplit é diferente de zero, um número de divisões <code class="docutils literal notranslate"><span class="pre">maxsplit</span></code> será executado.</p>
</dd></dl>

<p>Você pode limitar o número de divisões feitas, passando um valor para maxsplit. Quando <code class="docutils literal notranslate"><span class="pre">maxsplit</span></code> é diferente de zero, um determinado número de divisões <code class="docutils literal notranslate"><span class="pre">maxsplit</span></code> será executado, e o restante da string é retornado como o elemento final da lista. No exemplo a seguir, o delimitador é qualquer sequência de caracteres não alfanuméricos.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\W+&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;This is a test, short and sweet, of split().&#39;</span><span class="p">)</span>
<span class="go">[&#39;This&#39;, &#39;is&#39;, &#39;a&#39;, &#39;test&#39;, &#39;short&#39;, &#39;and&#39;, &#39;sweet&#39;, &#39;of&#39;, &#39;split&#39;, &#39;&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;This is a test, short and sweet, of split().&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">[&#39;This&#39;, &#39;is&#39;, &#39;a&#39;, &#39;test, short and sweet, of split().&#39;]</span>
</pre></div>
</div>
<p>Às vezes, você não está apenas interessado no que o texto que está entre delimitadores contém, mas também precisa saber qual o delimitador foi usado. Se os parênteses de captura são utilizados na RE, então os respectivos valores são também retornados como parte da lista. Compare as seguintes chamadas:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\W+&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\W+)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;This... is a test.&#39;</span><span class="p">)</span>
<span class="go">[&#39;This&#39;, &#39;is&#39;, &#39;a&#39;, &#39;test&#39;, &#39;&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;This... is a test.&#39;</span><span class="p">)</span>
<span class="go">[&#39;This&#39;, &#39;... &#39;, &#39;is&#39;, &#39; &#39;, &#39;a&#39;, &#39; &#39;, &#39;test&#39;, &#39;.&#39;, &#39;&#39;]</span>
</pre></div>
</div>
<p>A função de nível de módulo <a class="reference internal" href="../library/re.html#re.split" title="re.split"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.split()</span></code></a> adiciona a RE a ser utilizada como o primeiro argumento, mas é, em determinadas circunstâncias, a mesma.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[\W]+&#39;</span><span class="p">,</span> <span class="s1">&#39;Words, words, words.&#39;</span><span class="p">)</span>
<span class="go">[&#39;Words&#39;, &#39;words&#39;, &#39;words&#39;, &#39;&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;([\W]+)&#39;</span><span class="p">,</span> <span class="s1">&#39;Words, words, words.&#39;</span><span class="p">)</span>
<span class="go">[&#39;Words&#39;, &#39;, &#39;, &#39;words&#39;, &#39;, &#39;, &#39;words&#39;, &#39;.&#39;, &#39;&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[\W]+&#39;</span><span class="p">,</span> <span class="s1">&#39;Words, words, words.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">[&#39;Words&#39;, &#39;words, words.&#39;]</span>
</pre></div>
</div>
</section>
<section id="search-and-replace">
<h3>Busca e Substituição<a class="headerlink" href="#search-and-replace" title="Link permanente para este título">¶</a></h3>
<p>Another common task is to find all the matches for a pattern, and replace them
with a different string.  The <a class="reference internal" href="../library/re.html#re.Pattern.sub" title="re.Pattern.sub"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sub()</span></code></a> method takes a replacement value,
which can be either a string or a function, and the string to be processed.</p>
<dl class="py method">
<dt>
<code class="sig-prename descclassname">.</code><code class="sig-name descname">sub</code><span class="sig-paren">(</span><em class="sig-param">replacement</em>, <em class="sig-param">string</em><span class="optional">[</span>, <em class="sig-param">count=0</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>Retorna a string obtida substituindo as ocorrências mais à esquerda não sobrepostas da RE em <code class="docutils literal notranslate"><span class="pre">string</span></code> pela substituição <code class="docutils literal notranslate"><span class="pre">replacement</span></code>. Se o padrão não for encontrado, a <code class="docutils literal notranslate"><span class="pre">string</span></code> é retornada inalterada.</p>
<p>O argumento opcional <code class="docutils literal notranslate"><span class="pre">count</span></code> é o número máximo de ocorrências do padrão a ser substituído; <code class="docutils literal notranslate"><span class="pre">count</span></code> deve ser um número inteiro não negativo. O valor padrão <code class="docutils literal notranslate"><span class="pre">0</span></code> significa para substituir todas as ocorrências.</p>
</dd></dl>

<p>Here’s a simple example of using the <a class="reference internal" href="../library/re.html#re.Pattern.sub" title="re.Pattern.sub"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sub()</span></code></a> method.  It replaces colour
names with the word <code class="docutils literal notranslate"><span class="pre">colour</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;(blue|white|red)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;colour&#39;</span><span class="p">,</span> <span class="s1">&#39;blue socks and red shoes&#39;</span><span class="p">)</span>
<span class="go">&#39;colour socks and colour shoes&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;colour&#39;</span><span class="p">,</span> <span class="s1">&#39;blue socks and red shoes&#39;</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">&#39;colour socks and red shoes&#39;</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="../library/re.html#re.Pattern.subn" title="re.Pattern.subn"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subn()</span></code></a> method does the same work, but returns a 2-tuple containing the
new string value and the number of replacements  that were performed:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;(blue|white|red)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">subn</span><span class="p">(</span><span class="s1">&#39;colour&#39;</span><span class="p">,</span> <span class="s1">&#39;blue socks and red shoes&#39;</span><span class="p">)</span>
<span class="go">(&#39;colour socks and colour shoes&#39;, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">subn</span><span class="p">(</span><span class="s1">&#39;colour&#39;</span><span class="p">,</span> <span class="s1">&#39;no colours at all&#39;</span><span class="p">)</span>
<span class="go">(&#39;no colours at all&#39;, 0)</span>
</pre></div>
</div>
<p>Empty matches are replaced only when they’re not adjacent to a previous empty match.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;x*&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;abxd&#39;</span><span class="p">)</span>
<span class="go">&#39;-a-b--d-&#39;</span>
</pre></div>
</div>
<p>If <em>replacement</em> is a string, any backslash escapes in it are processed.  That
is, <code class="docutils literal notranslate"><span class="pre">\n</span></code> is converted to a single newline character, <code class="docutils literal notranslate"><span class="pre">\r</span></code> is converted to a
carriage return, and so forth. Unknown escapes such as <code class="docutils literal notranslate"><span class="pre">\&amp;</span></code> are left alone.
Backreferences, such as <code class="docutils literal notranslate"><span class="pre">\6</span></code>, are replaced with the substring matched by the
corresponding group in the RE.  This lets you incorporate portions of the
original text in the resulting replacement string.</p>
<p>Este exemplo corresponde com a palavra <code class="docutils literal notranslate"><span class="pre">section</span></code>, seguida por uma string colocada entre <code class="docutils literal notranslate"><span class="pre">{,</span> <span class="pre">}</span></code> e altera <code class="docutils literal notranslate"><span class="pre">section</span></code> para <code class="docutils literal notranslate"><span class="pre">subsection</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;section{ ( [^}]* ) }&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">VERBOSE</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;subsection{\1}&#39;</span><span class="p">,</span><span class="s1">&#39;section</span><span class="si">{First}</span><span class="s1"> section</span><span class="si">{second}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">&#39;subsection{First} subsection{second}&#39;</span>
</pre></div>
</div>
<p>Há também uma sintaxe para se referir a grupos nomeados como definido pela sintaxe <code class="docutils literal notranslate"><span class="pre">(?P&lt;name&gt;...)</span></code>. <code class="docutils literal notranslate"><span class="pre">\g&lt;name&gt;</span></code> usará a substring correspondida pelo grupo com nome <code class="docutils literal notranslate"><span class="pre">name</span></code> e <code class="docutils literal notranslate"><span class="pre">\g&lt;number&gt;</span></code> utiliza o número do grupo correspondente. <code class="docutils literal notranslate"><span class="pre">.\g&lt;2&gt;</span></code> é, portanto, equivalente a <code class="docutils literal notranslate"><span class="pre">\2</span></code>, mas não é ambígua em uma string de substituição (replacement), tal como <code class="docutils literal notranslate"><span class="pre">\g&lt;2&gt;0</span></code>. (<code class="docutils literal notranslate"><span class="pre">\20</span></code> seria interpretado como uma referência ao grupo de <code class="docutils literal notranslate"><span class="pre">20</span></code>, e não uma referência ao grupo <code class="docutils literal notranslate"><span class="pre">2</span></code> seguido pelo caractere literal <code class="docutils literal notranslate"><span class="pre">0</span></code>). As substituições a seguir são todas equivalentes, mas usam todas as três variações da string de substituição.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;section{ (?P&lt;name&gt; [^}]* ) }&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">VERBOSE</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;subsection{\1}&#39;</span><span class="p">,</span><span class="s1">&#39;section</span><span class="si">{First}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">&#39;subsection{First}&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;subsection{\g&lt;1&gt;}&#39;</span><span class="p">,</span><span class="s1">&#39;section</span><span class="si">{First}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">&#39;subsection{First}&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;subsection{\g&lt;name&gt;}&#39;</span><span class="p">,</span><span class="s1">&#39;section</span><span class="si">{First}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">&#39;subsection{First}&#39;</span>
</pre></div>
</div>
<p><em>replacement</em> também pode ser uma função, que lhe dá ainda mais controle. Se <em>replacement</em> for uma função, a função será chamada para todas as ocorrências não sobrepostas de <em>pattern</em>. Em cada chamada, a função recebe um argumento de <a class="reference internal" href="../library/re.html#match-objects"><span class="std std-ref">objeto Match</span></a> para a correspondência e pode usar essas informações para calcular a string de substituição desejada e retorná-la.</p>
<p>No exemplo a seguir, a função de substituição traduz decimais em hexadecimal:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">hexrepl</span><span class="p">(</span><span class="n">match</span><span class="p">):</span>
<span class="gp">... </span>    <span class="s2">&quot;Return the hex string for a decimal number&quot;</span>
<span class="gp">... </span>    <span class="n">value</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">())</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="nb">hex</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\d+&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">hexrepl</span><span class="p">,</span> <span class="s1">&#39;Call 65490 for printing, 49152 for user code.&#39;</span><span class="p">)</span>
<span class="go">&#39;Call 0xffd2 for printing, 0xc000 for user code.&#39;</span>
</pre></div>
</div>
<p>Ao utilizar a função de nível de módulo <a class="reference internal" href="../library/re.html#re.sub" title="re.sub"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.sub()</span></code></a>, o padrão é passado como o primeiro argumento. O padrão pode ser fornecido como um objeto ou como uma string; se você precisa especificar sinalizadores de expressões regulares, você deve usar um objeto padrão como o primeiro parâmetro, ou usar modificadores embutidos na string padrão, por exemplo, <code class="docutils literal notranslate"><span class="pre">sub(&quot;(?i)b+&quot;,</span> <span class="pre">&quot;x&quot;,</span> <span class="pre">&quot;bbbb</span> <span class="pre">BBBB&quot;)</span></code> retorna <code class="docutils literal notranslate"><span class="pre">'x</span> <span class="pre">x'</span></code>.</p>
</section>
</section>
<section id="common-problems">
<h2>Problemas Comuns<a class="headerlink" href="#common-problems" title="Link permanente para este título">¶</a></h2>
<p>Expressões regulares são uma ferramenta poderosa para algumas aplicações, mas de certa forma o seu comportamento não é intuitivo, e às vezes, as RE não se comportam da maneira que você espera que elas se comportem. Esta seção irá apontar algumas das armadilhas mais comuns.</p>
<section id="use-string-methods">
<h3>Usando String Methods<a class="headerlink" href="#use-string-methods" title="Link permanente para este título">¶</a></h3>
<p>Sometimes using the <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> module is a mistake.  If you’re matching a fixed
string, or a single character class, and you’re not using any <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> features
such as the <a class="reference internal" href="../library/re.html#re.IGNORECASE" title="re.IGNORECASE"><code class="xref py py-const docutils literal notranslate"><span class="pre">IGNORECASE</span></code></a> flag, then the full power of regular expressions
may not be required. Strings have several methods for performing operations with
fixed strings and they’re usually much faster, because the implementation is a
single small C loop that’s been optimized for the purpose, instead of the large,
more generalized regular expression engine.</p>
<p>One example might be replacing a single fixed string with another one; for
example, you might replace <code class="docutils literal notranslate"><span class="pre">word</span></code> with <code class="docutils literal notranslate"><span class="pre">deed</span></code>.  <a class="reference internal" href="../library/re.html#re.sub" title="re.sub"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.sub()</span></code></a> seems like the
function to use for this, but consider the <a class="reference internal" href="../library/stdtypes.html#str.replace" title="str.replace"><code class="xref py py-meth docutils literal notranslate"><span class="pre">replace()</span></code></a> method.  Note that
<code class="xref py py-meth docutils literal notranslate"><span class="pre">replace()</span></code> will also replace <code class="docutils literal notranslate"><span class="pre">word</span></code> inside words, turning <code class="docutils literal notranslate"><span class="pre">swordfish</span></code>
into <code class="docutils literal notranslate"><span class="pre">sdeedfish</span></code>, but the  naive RE <code class="docutils literal notranslate"><span class="pre">word</span></code> would have done that, too.  (To
avoid performing the substitution on parts of words, the pattern would have to
be <code class="docutils literal notranslate"><span class="pre">\bword\b</span></code>, in order to require that <code class="docutils literal notranslate"><span class="pre">word</span></code> have a word boundary on
either side.  This takes the job beyond  <code class="xref py py-meth docutils literal notranslate"><span class="pre">replace()</span></code>’s abilities.)</p>
<p>Another common task is deleting every occurrence of a single character from a
string or replacing it with another single character.  You might do this with
something like <code class="docutils literal notranslate"><span class="pre">re.sub('\n',</span> <span class="pre">'</span> <span class="pre">',</span> <span class="pre">S)</span></code>, but <a class="reference internal" href="../library/stdtypes.html#str.translate" title="str.translate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">translate()</span></code></a> is capable of
doing both tasks and will be faster than any regular expression operation can
be.</p>
<p>Em suma, antes de recorrer ao o módulo <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a>, considere se o seu problema pode ser resolvido com um método string mais rápido e mais simples.</p>
</section>
<section id="match-versus-search">
<h3>match() versus search()<a class="headerlink" href="#match-versus-search" title="Link permanente para este título">¶</a></h3>
<p>The <a class="reference internal" href="../library/re.html#re.match" title="re.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">match()</span></code></a> function only checks if the RE matches at the beginning of the
string while <a class="reference internal" href="../library/re.html#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">search()</span></code></a> will scan forward through the string for a match.
It’s important to keep this distinction in mind.  Remember,  <code class="xref py py-func docutils literal notranslate"><span class="pre">match()</span></code> will
only report a successful match which will start at 0; if the match wouldn’t
start at zero,  <code class="xref py py-func docutils literal notranslate"><span class="pre">match()</span></code> will <em>not</em> report it.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;super&#39;</span><span class="p">,</span> <span class="s1">&#39;superstition&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">span</span><span class="p">())</span>
<span class="go">(0, 5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;super&#39;</span><span class="p">,</span> <span class="s1">&#39;insuperable&#39;</span><span class="p">))</span>
<span class="go">None</span>
</pre></div>
</div>
<p>On the other hand, <a class="reference internal" href="../library/re.html#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">search()</span></code></a> will scan forward through the string,
reporting the first match it finds.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;super&#39;</span><span class="p">,</span> <span class="s1">&#39;superstition&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">span</span><span class="p">())</span>
<span class="go">(0, 5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;super&#39;</span><span class="p">,</span> <span class="s1">&#39;insuperable&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">span</span><span class="p">())</span>
<span class="go">(2, 7)</span>
</pre></div>
</div>
<p>Às vezes, você vai ficar tentado a continuar usando <a class="reference internal" href="../library/re.html#re.match" title="re.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.match()</span></code></a>, e apenas adicionar <code class="docutils literal notranslate"><span class="pre">.*</span></code> ao início de sua RE. Resista a essa tentação e use <a class="reference internal" href="../library/re.html#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.search()</span></code></a> em vez disso. O compilador de expressão regular faz alguma análise das REs, a fim de acelerar o processo de procura de uma correspondência. Tal análise descobre o que o primeiro caractere de uma string deve ser; por exemplo, um padrão começando com <code class="docutils literal notranslate"><span class="pre">Crow</span></code> deve corresponder com algo iniciando com <code class="docutils literal notranslate"><span class="pre">'C'</span></code>. A análise permite que o mecanismo faça a varredura rapidamente através da string a procura do caractere inicial, apenas tentando a combinação completa se um <code class="docutils literal notranslate"><span class="pre">'C'</span></code> for encontrado.</p>
<p>Adicionar um <code class="docutils literal notranslate"><span class="pre">.*</span></code> evita essa otimização, sendo necessário a varredura até o final da string e, em seguida, retroceder para encontrar uma correspondência para o resto da RE. Use <a class="reference internal" href="../library/re.html#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.search()</span></code></a> em vez disso.</p>
</section>
<section id="greedy-versus-non-greedy">
<h3>Gulosos versus não Gulosos<a class="headerlink" href="#greedy-versus-non-greedy" title="Link permanente para este título">¶</a></h3>
<p>Ao repetir uma expressão regular, como em <code class="docutils literal notranslate"><span class="pre">a*</span></code>, a ação resultante é consumir o tanto do padrão quanto possível. Este fato, muitas vezes derruba você quando você está tentando corresponder com um par de delimitadores balanceados, tal como os colchetes que cercam uma tag HTML. O padrão ingênuo para combinar uma única tag HTML não funciona por causa da natureza gulosa de <code class="docutils literal notranslate"><span class="pre">.*</span></code>.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;&lt;html&gt;&lt;head&gt;&lt;title&gt;Title&lt;/title&gt;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">32</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;&lt;.*&gt;&#39;</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">span</span><span class="p">())</span>
<span class="go">(0, 32)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;&lt;.*&gt;&#39;</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">())</span>
<span class="go">&lt;html&gt;&lt;head&gt;&lt;title&gt;Title&lt;/title&gt;</span>
</pre></div>
</div>
<p>The RE matches the <code class="docutils literal notranslate"><span class="pre">'&lt;'</span></code> in <code class="docutils literal notranslate"><span class="pre">'&lt;html&gt;'</span></code>, and the <code class="docutils literal notranslate"><span class="pre">.*</span></code> consumes the rest of
the string.  There’s still more left in the RE, though, and the <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> can’t
match at the end of the string, so the regular expression engine has to
backtrack character by character until it finds a match for the <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>.   The
final match extends from the <code class="docutils literal notranslate"><span class="pre">'&lt;'</span></code> in <code class="docutils literal notranslate"><span class="pre">'&lt;html&gt;'</span></code> to the <code class="docutils literal notranslate"><span class="pre">'&gt;'</span></code> in
<code class="docutils literal notranslate"><span class="pre">'&lt;/title&gt;'</span></code>, which isn’t what you want.</p>
<p>Neste caso, a solução é usar os qualificadores não-gulosos <code class="docutils literal notranslate"><span class="pre">*?,</span> <span class="pre">+?,??</span></code>, or <code class="docutils literal notranslate"><span class="pre">{m,n}?</span></code>, que corresponde com o mínimo de texto possível. No exemplo acima, o <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> é tentado imediatamente após a primeira correspondência de <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, e quando ele falhar, o mecanismo avança um caractere de cada vez, experimentado <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> a cada passo. Isso produz justamente o resultado correto:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;&lt;.*?&gt;&#39;</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">())</span>
<span class="go">&lt;html&gt;</span>
</pre></div>
</div>
<p>(Note que a análise de HTML ou XML com expressões regulares é dolorosa. Padrões “sujos e rápidos” irão lidar com casos comuns, mas HTML e XML tem casos especiais que irão quebrar expressões regulares óbvias; com o tempo, expressões regulares que você venha a escrever para lidar com todos os casos possíveis, se tornarão um padrão muito complicado. Use um módulo de análise de HTML ou XML para tais tarefas.)</p>
</section>
<section id="using-re-verbose">
<h3>Usando re.VERBOSE<a class="headerlink" href="#using-re-verbose" title="Link permanente para este título">¶</a></h3>
<p>Nesse momento, você provavelmente deve ter notado que as expressões regulares são de uma notação muito compacta, mas não é possível dizer que são legíveis. REs de complexidade moderada podem se tornar longas coleções de barras invertidas, parênteses e metacaracteres, fazendo com que se tornem difíceis de ler e compreender.</p>
<p>For such REs, specifying the <a class="reference internal" href="../library/re.html#re.VERBOSE" title="re.VERBOSE"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.VERBOSE</span></code></a> flag when compiling the regular
expression can be helpful, because it allows you to format the regular
expression more clearly.</p>
<p>O sinalizador <code class="docutils literal notranslate"><span class="pre">re.VERBOSE</span></code> produz vários efeitos. Espaço em branco na expressão regular que não está dentro de uma classe de caracteres é ignorado. Isto significa que uma expressão como <code class="docutils literal notranslate"><span class="pre">dog</span> <span class="pre">|</span> <span class="pre">cat</span></code> é equivalente ao menos legível <code class="docutils literal notranslate"><span class="pre">dog|cat</span></code>, mas <code class="docutils literal notranslate"><span class="pre">[a</span> <span class="pre">b]</span></code> ainda vai coincidir com os caracteres <code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code>, ou um <code class="docutils literal notranslate"><span class="pre">espaço</span></code>. Além disso, você também pode colocar comentários dentro de uma RE; comentários se estendem de um caractere <code class="docutils literal notranslate"><span class="pre">#</span></code> até a próxima nova linha. Quando usados junto com strings de aspas triplas, isso permite as REs serem formatadas mais ordenadamente:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">pat</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2"> \s*                 # Skip leading whitespace</span>
<span class="s2"> (?P&lt;header&gt;[^:]+)   # Header name</span>
<span class="s2"> \s* :               # Whitespace, and a colon</span>
<span class="s2"> (?P&lt;value&gt;.*?)      # The header&#39;s value -- *? used to</span>
<span class="s2">                     # lose the following trailing whitespace</span>
<span class="s2"> \s*$                # Trailing whitespace to end-of-line</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">VERBOSE</span><span class="p">)</span>
</pre></div>
</div>
<p>Isso é muito mais legível do que:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">pat</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\s*(?P&lt;header&gt;[^:]+)\s*:(?P&lt;value&gt;.*?)\s*$&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<section id="feedback">
<h2>Comentários<a class="headerlink" href="#feedback" title="Link permanente para este título">¶</a></h2>
<p>Expressões regulares são um tópico complicado. Esse documento ajudou você a compreendê-las? Existem partes que foram pouco claras, ou situações que você vivenciou que não foram abordadas aqui? Se assim for, por favor, envie sugestões de melhorias para o autor.</p>
<p>The most complete book on regular expressions is almost certainly Jeffrey
Friedl’s Mastering Regular Expressions, published by O’Reilly.  Unfortunately,
it exclusively concentrates on Perl and Java’s flavours of regular expressions,
and doesn’t contain any Python material at all, so it won’t be useful as a
reference for programming in Python.  (The first edition covered Python’s
now-removed <code class="xref py py-mod docutils literal notranslate"><span class="pre">regex</span></code> module, which won’t help you much.)  Consider checking
it out from your library.</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Tabela de Conteúdo</a></h3>
  <ul>
<li><a class="reference internal" href="#">Expressões Regulares HOWTO</a><ul>
<li><a class="reference internal" href="#introduction">Introdução</a></li>
<li><a class="reference internal" href="#simple-patterns">Padrões Simples</a><ul>
<li><a class="reference internal" href="#matching-characters">Caracteres Correspondentes</a></li>
<li><a class="reference internal" href="#repeating-things">Repetindo Coisas</a></li>
</ul>
</li>
<li><a class="reference internal" href="#using-regular-expressions">Usando expressões regulares</a><ul>
<li><a class="reference internal" href="#compiling-regular-expressions">Compilando Expressões Regulares</a></li>
<li><a class="reference internal" href="#the-backslash-plague">A praga da barra invertida</a></li>
<li><a class="reference internal" href="#performing-matches">Executando Comparações</a></li>
<li><a class="reference internal" href="#module-level-functions">Funções de Nível de Módulo</a></li>
<li><a class="reference internal" href="#compilation-flags">Sinalizadores de Compilação</a></li>
</ul>
</li>
<li><a class="reference internal" href="#more-pattern-power">Mais Poder dos Padrões</a><ul>
<li><a class="reference internal" href="#more-metacharacters">Mais Metacaracteres</a></li>
<li><a class="reference internal" href="#grouping">Agrupamento</a></li>
<li><a class="reference internal" href="#non-capturing-and-named-groups">Não captura e Grupos Nomeados</a></li>
<li><a class="reference internal" href="#lookahead-assertions">Afirmação Lookahead</a></li>
</ul>
</li>
<li><a class="reference internal" href="#modifying-strings">Modificando Strings</a><ul>
<li><a class="reference internal" href="#splitting-strings">Dividindo as Strings</a></li>
<li><a class="reference internal" href="#search-and-replace">Busca e Substituição</a></li>
</ul>
</li>
<li><a class="reference internal" href="#common-problems">Problemas Comuns</a><ul>
<li><a class="reference internal" href="#use-string-methods">Usando String Methods</a></li>
<li><a class="reference internal" href="#match-versus-search">match() versus search()</a></li>
<li><a class="reference internal" href="#greedy-versus-non-greedy">Gulosos versus não Gulosos</a></li>
<li><a class="reference internal" href="#using-re-verbose">Usando re.VERBOSE</a></li>
</ul>
</li>
<li><a class="reference internal" href="#feedback">Comentários</a></li>
</ul>
</li>
</ul>

  <h4>Tópico anterior</h4>
  <p class="topless"><a href="logging-cookbook.html"
                        title="capítulo anterior">Livro de Receitas do Logging</a></p>
  <h4>Próximo tópico</h4>
  <p class="topless"><a href="sockets.html"
                        title="próximo capítulo">HOWTO sobre a Programação de Soquetes</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Relatar um erro</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.10/Doc/howto/regex.rst"
            rel="nofollow">Exibir código-fonte
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegação</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice geral"
             >índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="sockets.html" title="HOWTO sobre a Programação de Soquetes"
             >próximo</a> |</li>
        <li class="right" >
          <a href="logging-cookbook.html" title="Livro de Receitas do Logging"
             >anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.10.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python HOWTOs</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Expressões Regulares HOWTO</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Busca rápida" aria-label="Busca rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Direitos autorais</a> 2001-2022, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    Última atualização em jun. 04, 2022.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.4.3.
    </div>

  </body>
</html>