
<!DOCTYPE html>

<html lang="pt_BR">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17: http://docutils.sourceforge.net/" />

    <title>Laço de Eventos &#8212; documentação Python 3.10.4</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pydoctheme.css?2022.1" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Pesquisar dentro de documentação Python 3.10.4"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="Sobre esses documentos" href="../about.html" />
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Buscar" href="../search.html" />
    <link rel="copyright" title="Direitos autorais" href="../copyright.html" />
    <link rel="next" title="Futuros" href="asyncio-future.html" />
    <link rel="prev" title="Exceções" href="asyncio-exceptions.html" />
    <link rel="canonical" href="https://docs.python.org/3/library/asyncio-eventloop.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <label for="menuToggler" class="toggler__label">
        <span></span>
    </label>
    <nav class="nav-content" role="navigation">
         <a href="https://www.python.org/" class="nav-logo">
             <img src="../_static/py.svg" alt="Logo"/>
         </a>
        <div class="version_switcher_placeholder"></div>
        <form role="search" class="search" action="../search.html" method="get">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                <path fill-rule="nonzero"
                        d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="#444"></path>
            </svg>
            <input type="text" name="q" aria-label="Busca rápida"/>
            <input type="submit" value="Ir"/>
        </form>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
  <h3><a href="../contents.html">Tabela de Conteúdo</a></h3>
  <ul>
<li><a class="reference internal" href="#">Laço de Eventos</a><ul>
<li><a class="reference internal" href="#event-loop-methods">Métodos do laço de eventos</a><ul>
<li><a class="reference internal" href="#running-and-stopping-the-loop">Executar e interromper o laço</a></li>
<li><a class="reference internal" href="#scheduling-callbacks">Agendando funções de retorno</a></li>
<li><a class="reference internal" href="#scheduling-delayed-callbacks">Agendando funções de retorno atrasadas</a></li>
<li><a class="reference internal" href="#creating-futures-and-tasks">Criando Futures e Tasks</a></li>
<li><a class="reference internal" href="#opening-network-connections">Abrindo conexões de rede</a></li>
<li><a class="reference internal" href="#creating-network-servers">Criando servidores de rede</a></li>
<li><a class="reference internal" href="#transferring-files">Transferindo arquivos</a></li>
<li><a class="reference internal" href="#tls-upgrade">Atualizando TLS</a></li>
<li><a class="reference internal" href="#watching-file-descriptors">Observando descritores de arquivo</a></li>
<li><a class="reference internal" href="#working-with-socket-objects-directly">Trabalhando com objetos soquete diretamente</a></li>
<li><a class="reference internal" href="#dns">DNS</a></li>
<li><a class="reference internal" href="#working-with-pipes">Trabalhando com encadeamentos</a></li>
<li><a class="reference internal" href="#unix-signals">Sinais Unix</a></li>
<li><a class="reference internal" href="#executing-code-in-thread-or-process-pools">Executando código em conjuntos de threads ou processos</a></li>
<li><a class="reference internal" href="#error-handling-api">Tratando erros da API</a></li>
<li><a class="reference internal" href="#enabling-debug-mode">Habilitando o modo de debug</a></li>
<li><a class="reference internal" href="#running-subprocesses">Executando Subprocessos</a></li>
</ul>
</li>
<li><a class="reference internal" href="#callback-handles">Tratadores de função de retorno</a></li>
<li><a class="reference internal" href="#server-objects">Objetos Server</a></li>
<li><a class="reference internal" href="#event-loop-implementations">Implementações do Laço de Eventos</a></li>
<li><a class="reference internal" href="#examples">Exemplos</a><ul>
<li><a class="reference internal" href="#hello-world-with-call-soon">Hello World com call_soon()</a></li>
<li><a class="reference internal" href="#display-the-current-date-with-call-later">Exibe a data atual com call_later()</a></li>
<li><a class="reference internal" href="#watch-a-file-descriptor-for-read-events">Observa um descritor de arquivo por eventos de leitura</a></li>
<li><a class="reference internal" href="#set-signal-handlers-for-sigint-and-sigterm">Define tratadores de sinais para SIGINT e SIGTERM</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Tópico anterior</h4>
  <p class="topless"><a href="asyncio-exceptions.html"
                        title="capítulo anterior">Exceções</a></p>
  <h4>Próximo tópico</h4>
  <p class="topless"><a href="asyncio-future.html"
                        title="próximo capítulo">Futuros</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Relatar um erro</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.10/Doc/library/asyncio-eventloop.rst"
            rel="nofollow">Exibir código-fonte
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegação</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice geral"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="asyncio-future.html" title="Futuros"
             accesskey="N">próximo</a> |</li>
        <li class="right" >
          <a href="asyncio-exceptions.html" title="Exceções"
             accesskey="P">anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.10.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >A Biblioteca Padrão do Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="ipc.html" >Comunicação em Rede e Interprocesso</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="asyncio.html" accesskey="U"><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code> — E/S assíncrona</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Laço de Eventos</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Busca rápida" aria-label="Busca rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="event-loop">
<h1>Laço de Eventos<a class="headerlink" href="#event-loop" title="Link permanente para este título">¶</a></h1>
<p><strong>Código-fonte:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.10/Lib/asyncio/events.py">Lib/asyncio/events.py</a>, <a class="reference external" href="https://github.com/python/cpython/tree/3.10/Lib/asyncio/base_events.py">Lib/asyncio/base_events.py</a></p>
<hr class="docutils" />
<p class="rubric">Prefácio</p>
<p>O laço de eventos é o núcleo de toda aplicação asyncio. Laços de eventos executam tarefas e funções de retorno assíncronas, realizam operações de entrada e saída e executam subprocessos.</p>
<p>Os desenvolvedores de aplicação normalmente devem usar as funções asyncio de alto nível, como <a class="reference internal" href="asyncio-task.html#asyncio.run" title="asyncio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.run()</span></code></a>, e devem raramente precisar fazer referência ao objeto de loop ou chamar seus métodos. Esta seção destina-se principalmente a autores de código de baixo nível, bibliotecas e frameworks, que precisam de um controle mais preciso sobre o comportamento do laço de evento.</p>
<p class="rubric">Obtendo o laço de eventos</p>
<p>As seguintes funções baixo nível podem ser usadas para obter, definir, ou criar um laço de eventos:</p>
<dl class="py function">
<dt id="asyncio.get_running_loop">
<code class="sig-prename descclassname">asyncio.</code><code class="sig-name descname">get_running_loop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.get_running_loop" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna o laço de eventos em execução na thread atual do sistema operacional.</p>
<p>Se não existir nenhum laço de eventos em execução, um <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> é levantado. Esta função somente pode ser chamada a partir de uma corrotina ou uma função de retorno.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.7.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="asyncio.get_event_loop">
<code class="sig-prename descclassname">asyncio.</code><code class="sig-name descname">get_event_loop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.get_event_loop" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Obtém o laço de eventos atual.</p>
<p>Se não existe nenhum laço de eventos definido na thread atual do sistema operacional, é a thread principal do sistema operacional, e <a class="reference internal" href="#asyncio.set_event_loop" title="asyncio.set_event_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">set_event_loop()</span></code></a> ainda não foi chamada, asyncio irá criar um novo laço de eventos e defini-lo como o atual.</p>
<p>Devido ao fato desta função ter um comportamento particularmente complexo (especialmente quando políticas de laço de eventos customizadas estão sendo usadas), usar a função <a class="reference internal" href="#asyncio.get_running_loop" title="asyncio.get_running_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_running_loop()</span></code></a> é preferido ao invés de <a class="reference internal" href="#asyncio.get_event_loop" title="asyncio.get_event_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_event_loop()</span></code></a> em corrotinas e funções de retorno.</p>
<p>Considere também usar a função <a class="reference internal" href="asyncio-task.html#asyncio.run" title="asyncio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.run()</span></code></a> ao invés de usar funções de baixo nível para manualmente criar e fechar um laço de eventos.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde a versão 3.10: </span>Aviso de descontinuidade é emitido se não existe nenhum laço de eventos em execução. Em lançamentos futuros do Python, esta função será um apelido para <a class="reference internal" href="#asyncio.get_running_loop" title="asyncio.get_running_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_running_loop()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="asyncio.set_event_loop">
<code class="sig-prename descclassname">asyncio.</code><code class="sig-name descname">set_event_loop</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">loop</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.set_event_loop" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Define <em>loop</em> como o laço de eventos atual para a thread atual do sistema operacional.</p>
</dd></dl>

<dl class="py function">
<dt id="asyncio.new_event_loop">
<code class="sig-prename descclassname">asyncio.</code><code class="sig-name descname">new_event_loop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.new_event_loop" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Create and return a new event loop object.</p>
</dd></dl>

<p>Perceba que o comportamento das funções <a class="reference internal" href="#asyncio.get_event_loop" title="asyncio.get_event_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_event_loop()</span></code></a>, <a class="reference internal" href="#asyncio.set_event_loop" title="asyncio.set_event_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">set_event_loop()</span></code></a>, e <a class="reference internal" href="#asyncio.new_event_loop" title="asyncio.new_event_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">new_event_loop()</span></code></a> podem ser alteradas <a class="reference internal" href="asyncio-policy.html#asyncio-policies"><span class="std std-ref">definindo uma política de laço de eventos customizada</span></a>.</p>
<p class="rubric">Conteúdo</p>
<p>Esta página de documentação contém as seguintes seções:</p>
<ul class="simple">
<li><p>A seção <a class="reference internal" href="#event-loop-methods">Métodos do laço de eventos</a> é a documentação de referência das APIs de laço de eventos;</p></li>
<li><p>A seção <a class="reference internal" href="#callback-handles">Tratadores de função de retorno</a> documenta as instâncias das classes <a class="reference internal" href="#asyncio.Handle" title="asyncio.Handle"><code class="xref py py-class docutils literal notranslate"><span class="pre">Handle</span></code></a> e <a class="reference internal" href="#asyncio.TimerHandle" title="asyncio.TimerHandle"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimerHandle</span></code></a>, que são retornadas por métodos de agendamento tais como <a class="reference internal" href="#asyncio.loop.call_soon" title="asyncio.loop.call_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_soon()</span></code></a> e <a class="reference internal" href="#asyncio.loop.call_later" title="asyncio.loop.call_later"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_later()</span></code></a>;</p></li>
<li><p>A seção <a class="reference internal" href="#server-objects">Objetos Server</a> documenta tipos retornados a partir de métodos de laço de eventos, como <a class="reference internal" href="#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_server()</span></code></a>;</p></li>
<li><p>A seção <a class="reference internal" href="#event-loop-implementations">Implementações do Laço de Eventos</a> documenta as classes <a class="reference internal" href="#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">SelectorEventLoop</span></code></a> e <a class="reference internal" href="#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProactorEventLoop</span></code></a>;</p></li>
<li><p>A seção <a class="reference internal" href="#examples">Exemplos</a> demonstra como trabalhar com algumas APIs do laço de eventos APIs.</p></li>
</ul>
<section id="event-loop-methods">
<span id="asyncio-event-loop"></span><h2>Métodos do laço de eventos<a class="headerlink" href="#event-loop-methods" title="Link permanente para este título">¶</a></h2>
<p>Laços de eventos possuem APIs de <strong>baixo nível</strong> para as seguintes situações:</p>
<div class="contents local topic" id="sumario">
<ul class="simple">
<li><p><a class="reference internal" href="#running-and-stopping-the-loop" id="id1">Executar e interromper o laço</a></p></li>
<li><p><a class="reference internal" href="#scheduling-callbacks" id="id2">Agendando funções de retorno</a></p></li>
<li><p><a class="reference internal" href="#scheduling-delayed-callbacks" id="id3">Agendando funções de retorno atrasadas</a></p></li>
<li><p><a class="reference internal" href="#creating-futures-and-tasks" id="id4">Criando Futures e Tasks</a></p></li>
<li><p><a class="reference internal" href="#opening-network-connections" id="id5">Abrindo conexões de rede</a></p></li>
<li><p><a class="reference internal" href="#creating-network-servers" id="id6">Criando servidores de rede</a></p></li>
<li><p><a class="reference internal" href="#transferring-files" id="id7">Transferindo arquivos</a></p></li>
<li><p><a class="reference internal" href="#tls-upgrade" id="id8">Atualizando TLS</a></p></li>
<li><p><a class="reference internal" href="#watching-file-descriptors" id="id9">Observando descritores de arquivo</a></p></li>
<li><p><a class="reference internal" href="#working-with-socket-objects-directly" id="id10">Trabalhando com objetos soquete diretamente</a></p></li>
<li><p><a class="reference internal" href="#dns" id="id11">DNS</a></p></li>
<li><p><a class="reference internal" href="#working-with-pipes" id="id12">Trabalhando com encadeamentos</a></p></li>
<li><p><a class="reference internal" href="#unix-signals" id="id13">Sinais Unix</a></p></li>
<li><p><a class="reference internal" href="#executing-code-in-thread-or-process-pools" id="id14">Executando código em conjuntos de threads ou processos</a></p></li>
<li><p><a class="reference internal" href="#error-handling-api" id="id15">Tratando erros da API</a></p></li>
<li><p><a class="reference internal" href="#enabling-debug-mode" id="id16">Habilitando o modo de debug</a></p></li>
<li><p><a class="reference internal" href="#running-subprocesses" id="id17">Executando Subprocessos</a></p></li>
</ul>
</div>
<section id="running-and-stopping-the-loop">
<h3><a class="toc-backref" href="#id1">Executar e interromper o laço</a><a class="headerlink" href="#running-and-stopping-the-loop" title="Link permanente para este título">¶</a></h3>
<dl class="py method">
<dt id="asyncio.loop.run_until_complete">
<code class="sig-prename descclassname">loop.</code><code class="sig-name descname">run_until_complete</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">future</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.run_until_complete" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Executar até que o <em>future</em> (uma instância da classe <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">Future</span></code></a>) seja completada.</p>
<p>Se o argumento é um <a class="reference internal" href="asyncio-task.html#coroutine"><span class="std std-ref">objeto corrotina</span></a>, ele é implicitamente agendado para executar como uma <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Task</span></code></a>.</p>
<p>Retorna o resultado do Future ou levanta sua exceção.</p>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.run_forever">
<code class="sig-prename descclassname">loop.</code><code class="sig-name descname">run_forever</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.run_forever" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Executa o laço de eventos até que <a class="reference internal" href="#asyncio.loop.stop" title="asyncio.loop.stop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stop()</span></code></a> seja chamado.</p>
<p>Se <a class="reference internal" href="#asyncio.loop.stop" title="asyncio.loop.stop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stop()</span></code></a> for chamado antes que <a class="reference internal" href="#asyncio.loop.run_forever" title="asyncio.loop.run_forever"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run_forever()</span></code></a> seja chamado, o laço  irá pesquisar o seletor de E/S uma vez com um tempo limite de zero, executar todas as funções de retorno agendadas na resposta de eventos de E/S (e aqueles que já estavam agendados), e então sair.</p>
<p>Se <a class="reference internal" href="#asyncio.loop.stop" title="asyncio.loop.stop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stop()</span></code></a> for chamado enquanto <a class="reference internal" href="#asyncio.loop.run_forever" title="asyncio.loop.run_forever"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run_forever()</span></code></a> estiver executando, o laço irá executar o lote atual de funções de retorno e então sair. Perceba que novas funções de retorno agendadas por funções de retorno não serão executadas neste caso; ao invés disso, elas serão executadas na próxima vez que <a class="reference internal" href="#asyncio.loop.run_forever" title="asyncio.loop.run_forever"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run_forever()</span></code></a> ou <a class="reference internal" href="#asyncio.loop.run_until_complete" title="asyncio.loop.run_until_complete"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run_until_complete()</span></code></a> forem chamadas.</p>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.stop">
<code class="sig-prename descclassname">loop.</code><code class="sig-name descname">stop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.stop" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Para o laço de eventos.</p>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.is_running">
<code class="sig-prename descclassname">loop.</code><code class="sig-name descname">is_running</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.is_running" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> se o laço de eventos estiver em execução.</p>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.is_closed">
<code class="sig-prename descclassname">loop.</code><code class="sig-name descname">is_closed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.is_closed" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> se o laço de eventos foi fechado.</p>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.close">
<code class="sig-prename descclassname">loop.</code><code class="sig-name descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.close" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Fecha o laço de eventos.</p>
<p>O laço não deve estar em execução quando esta função for chamada. Qualquer função de retorno pendente será descartada.</p>
<p>Este método limpa todas as filas e desliga o executor, mas não aguarda pelo encerramento do executor.</p>
<p>Este método é idempotente e irreversível. Nenhum outro método deve ser chamado depois que o laço de eventos esteja fechado.</p>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.shutdown_asyncgens">
<em class="property">coroutine </em><code class="sig-prename descclassname">loop.</code><code class="sig-name descname">shutdown_asyncgens</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.shutdown_asyncgens" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Agenda todos os objetos <a class="reference internal" href="../glossary.html#term-asynchronous-generator"><span class="xref std std-term">geradores assíncronos</span></a> atualmente abertos para serem fechados com uma chamada <a class="reference internal" href="../reference/expressions.html#agen.aclose" title="agen.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a>. Após chamar este método, o laço de eventos emitirá um aviso se um novo gerador assíncrono for iterado. Isso deve ser utilizado para finalizar  de forma confiável todos os geradores assíncronos agendados.</p>
<p>Perceba que não é necessário chamar esta função quando <a class="reference internal" href="asyncio-task.html#asyncio.run" title="asyncio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.run()</span></code></a> for usado.</p>
<p>Exemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">loop</span><span class="o">.</span><span class="n">shutdown_asyncgens</span><span class="p">())</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.6.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.shutdown_default_executor">
<em class="property">coroutine </em><code class="sig-prename descclassname">loop.</code><code class="sig-name descname">shutdown_default_executor</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.shutdown_default_executor" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Agenda o encerramento do executor padrão e aguarda ele se juntar a todas as threads no <code class="xref py py-class docutils literal notranslate"><span class="pre">ThreadPoolExecutor</span></code>. Após chamar este método, um <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> será levantado se <a class="reference internal" href="#asyncio.loop.run_in_executor" title="asyncio.loop.run_in_executor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.run_in_executor()</span></code></a> for chamado enquanto estiver usando o executor padrão.</p>
<p>Perceba que não é necessário chamar esta função quando <a class="reference internal" href="asyncio-task.html#asyncio.run" title="asyncio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.run()</span></code></a> for usado.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.9.</span></p>
</div>
</dd></dl>

</section>
<section id="scheduling-callbacks">
<h3><a class="toc-backref" href="#id2">Agendando funções de retorno</a><a class="headerlink" href="#scheduling-callbacks" title="Link permanente para este título">¶</a></h3>
<dl class="py method">
<dt id="asyncio.loop.call_soon">
<code class="sig-prename descclassname">loop.</code><code class="sig-name descname">call_soon</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">callback</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="n">context</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.call_soon" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Agenda a <em>função de retorno</em> <a class="reference internal" href="../glossary.html#term-callback"><span class="xref std std-term">callback</span></a> para ser chamada com argumentos <em>args</em> na próxima iteração do laço de eventos.</p>
<p>Funções de retorno são chamadas na ordem em que elas foram registradas. Cada função de retorno será chamada exatamente uma vez.</p>
<p>Um argumento opcional somente-nomeado <em>context</em> permite especificar um <a class="reference internal" href="contextvars.html#contextvars.Context" title="contextvars.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextvars.Context</span></code></a> customizado para executar na <em>função de retorno</em>. O contexto atual é usado quando nenhum <em>context</em> é fornecido.</p>
<p>Uma instância de <a class="reference internal" href="#asyncio.Handle" title="asyncio.Handle"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Handle</span></code></a> é retornado, o qual pode ser usado posteriormente para cancelar a função de retorno.</p>
<p>Este método não é seguro para thread.</p>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.call_soon_threadsafe">
<code class="sig-prename descclassname">loop.</code><code class="sig-name descname">call_soon_threadsafe</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">callback</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="n">context</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.call_soon_threadsafe" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Uma variante segura para thread do <a class="reference internal" href="#asyncio.loop.call_soon" title="asyncio.loop.call_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">call_soon()</span></code></a>. Deve ser usada para agendar funções de retorno <em>a partir de outra thread</em>.</p>
<p>Levanta <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> se chamado em um laço que já foi fechado. Isto pode acontecer em uma thread secundária quando a aplicação principal estiver desligando.</p>
<p>Veja a seção <a class="reference internal" href="asyncio-dev.html#asyncio-multithreading"><span class="std std-ref">concorrência e multithreading</span></a> da documentação.</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.7: </span>O parâmetro somente-nomeado <em>context</em> foi adicionado. Veja <span class="target" id="index-12"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0567"><strong>PEP 567</strong></a> para mais detalhes.</p>
</div>
<div class="admonition note" id="asyncio-pass-keywords">
<p class="admonition-title">Nota</p>
<p>Maior parte das funções de agendamento <a class="reference internal" href="asyncio.html#module-asyncio" title="asyncio: Asynchronous I/O."><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code></a> não permite passar argumentos nomeados. Para fazer isso, use <a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.partial()</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># will schedule &quot;print(&quot;Hello&quot;, flush=True)&quot;</span>
<span class="n">loop</span><span class="o">.</span><span class="n">call_soon</span><span class="p">(</span>
    <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="nb">print</span><span class="p">,</span> <span class="s2">&quot;Hello&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
</pre></div>
</div>
<p>Usar objetos parciais é usualmente mais conveniente que usar lambdas, pois asyncio pode renderizar objetos parciais melhor durante debug e mensagens de erro.</p>
</div>
</section>
<section id="scheduling-delayed-callbacks">
<span id="asyncio-delayed-calls"></span><h3><a class="toc-backref" href="#id3">Agendando funções de retorno atrasadas</a><a class="headerlink" href="#scheduling-delayed-callbacks" title="Link permanente para este título">¶</a></h3>
<p>Laço de eventos fornece mecanismos para agendar funções de retorno para serem chamadas em algum ponto no futuro. Laço de eventos usa relógios monotônico para acompanhar o tempo.</p>
<dl class="py method">
<dt id="asyncio.loop.call_later">
<code class="sig-prename descclassname">loop.</code><code class="sig-name descname">call_later</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">delay</span></em>, <em class="sig-param"><span class="n">callback</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="n">context</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.call_later" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Agenda <em>callback</em> para ser chamada após o <em>delay</em> número de segundos fornecido (pode ser um inteiro ou um ponto flutuante).</p>
<p>Uma instância de <a class="reference internal" href="#asyncio.TimerHandle" title="asyncio.TimerHandle"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.TimerHandle</span></code></a> é retornada, a qual pode ser usada para cancelar a função de retorno.</p>
<p><em>callback</em> será chamada exatamente uma vez. Se duas funções de retorno são agendadas para exatamente o mesmo tempo, a ordem na qual elas são chamadas é indefinida.</p>
<p>O <em>args</em> posicional opcional será passado para a função de retorno quando ela for chamada. Se você quiser que a função de retorno seja chamada com argumentos nomeados, use <a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.partial()</span></code></a>.</p>
<p>Um argumento opcional somente-nomeado <em>context</em> permite especificar um <a class="reference internal" href="contextvars.html#contextvars.Context" title="contextvars.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextvars.Context</span></code></a> customizado para executar na <em>função de retorno</em>. O contexto atual é usado quando nenhum <em>context</em> é fornecido.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.7: </span>O parâmetro somente-nomeado <em>context</em> foi adicionado. Veja <span class="target" id="index-13"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0567"><strong>PEP 567</strong></a> para mais detalhes.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.8: </span>No Python 3.7 e anterior, com a implementação padrão do laço de eventos, o <em>delay</em> não poderia exceder um dia. Isto foi ajustado no Python 3.8.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.call_at">
<code class="sig-prename descclassname">loop.</code><code class="sig-name descname">call_at</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">when</span></em>, <em class="sig-param"><span class="n">callback</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="n">context</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.call_at" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Agenda <em>callback</em> para ser chamada no timestamp absoluto fornecido <em>when</em> (um inteiro ou um ponto flutuante), usando o mesmo horário de referência que <a class="reference internal" href="#asyncio.loop.time" title="asyncio.loop.time"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.time()</span></code></a>.</p>
<p>O comportamento deste método é o mesmo que <a class="reference internal" href="#asyncio.loop.call_later" title="asyncio.loop.call_later"><code class="xref py py-meth docutils literal notranslate"><span class="pre">call_later()</span></code></a>.</p>
<p>Uma instância de <a class="reference internal" href="#asyncio.TimerHandle" title="asyncio.TimerHandle"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.TimerHandle</span></code></a> é retornada, a qual pode ser usada para cancelar a função de retorno.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.7: </span>O parâmetro somente-nomeado <em>context</em> foi adicionado. Veja <span class="target" id="index-14"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0567"><strong>PEP 567</strong></a> para mais detalhes.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.8: </span>No Python 3.7 e anterior, com a implementação padrão do laço de eventos, a diferença entre <em>when</em> e o horário atual não poderia exceder um dia. Isto foi ajustado no Python 3.8.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.time">
<code class="sig-prename descclassname">loop.</code><code class="sig-name descname">time</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.time" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna o horário atual, como um valor <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>, de acordo com o relógio monotônico interno do laço de eventos.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Nota</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.8: </span>No Python 3.7 e anterior, tempos limites (<em>delay</em> relativo ou <em>when</em> absoluto) não poderiam exceder um dia. Isto foi ajustado no Python 3.8.</p>
</div>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver também</p>
<p>A função <a class="reference internal" href="asyncio-task.html#asyncio.sleep" title="asyncio.sleep"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.sleep()</span></code></a>.</p>
</div>
</section>
<section id="creating-futures-and-tasks">
<h3><a class="toc-backref" href="#id4">Criando Futures e Tasks</a><a class="headerlink" href="#creating-futures-and-tasks" title="Link permanente para este título">¶</a></h3>
<dl class="py method">
<dt id="asyncio.loop.create_future">
<code class="sig-prename descclassname">loop.</code><code class="sig-name descname">create_future</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.create_future" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Cria um objeto <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Future</span></code></a> atachado ao laço de eventos.</p>
<p>Este é o modo preferido para criar Futures em asyncio. Isto permite que laços de eventos de terceiros forneçam implementações alternativas do objeto Future (com melhor desempenho ou instrumentação).</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.5.2.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.create_task">
<code class="sig-prename descclassname">loop.</code><code class="sig-name descname">create_task</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">coro</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.create_task" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Agenda a execução de uma <a class="reference internal" href="asyncio-task.html#coroutine"><span class="std std-ref">corrotina</span></a>. Retorna um objeto <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a>.</p>
<p>Laços de eventos de terceiros podem usar suas próprias subclasses de <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> para interoperabilidade. Neste caso, o tipo do resultado é uma subclasse de <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a>.</p>
<p>Se o argumento <em>name</em> for fornecido e não é <code class="docutils literal notranslate"><span class="pre">None</span></code>, ele é definido como o nome da tarefa, usando <a class="reference internal" href="asyncio-task.html#asyncio.Task.set_name" title="asyncio.Task.set_name"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Task.set_name()</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.8: </span>Added the <em>name</em> parameter.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.set_task_factory">
<code class="sig-prename descclassname">loop.</code><code class="sig-name descname">set_task_factory</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">factory</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.set_task_factory" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Define a factory da tarefa que será usada por <a class="reference internal" href="#asyncio.loop.create_task" title="asyncio.loop.create_task"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_task()</span></code></a>.</p>
<p>Se <em>factory</em> for <code class="docutils literal notranslate"><span class="pre">None</span></code>, a factory da task padrão será definida. Caso contrário, <em>factory</em> deve ser algo <em>chamável</em> com a assinatura coincidindo com <code class="docutils literal notranslate"><span class="pre">(loop,</span> <span class="pre">coro)</span></code>, onde <em>loop</em> é uma referência para o laço de eventos ativo, e <em>coro</em> é um objeto corrotina. O objeto chamável deve retornar um objeto compatível com <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Future</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.get_task_factory">
<code class="sig-prename descclassname">loop.</code><code class="sig-name descname">get_task_factory</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.get_task_factory" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna uma factory de tarefa ou <code class="docutils literal notranslate"><span class="pre">None</span></code> se a factory padrão estiver em uso.</p>
</dd></dl>

</section>
<section id="opening-network-connections">
<h3><a class="toc-backref" href="#id5">Abrindo conexões de rede</a><a class="headerlink" href="#opening-network-connections" title="Link permanente para este título">¶</a></h3>
<dl class="py method">
<dt id="asyncio.loop.create_connection">
<em class="property">coroutine </em><code class="sig-prename descclassname">loop.</code><code class="sig-name descname">create_connection</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">protocol_factory</span></em>, <em class="sig-param"><span class="n">host</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">port</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">ssl</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">family</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">proto</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">flags</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">sock</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">local_addr</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">server_hostname</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ssl_handshake_timeout</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">happy_eyeballs_delay</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">interleave</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.create_connection" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Abre uma conexão de transporte para streaming, para um endereço fornecido, especificado por <em>host</em> e <em>port</em>.</p>
<p>A família de soquetes pode ser <a class="reference internal" href="socket.html#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-data docutils literal notranslate"><span class="pre">AF_INET</span></code></a> ou <a class="reference internal" href="socket.html#socket.AF_INET6" title="socket.AF_INET6"><code class="xref py py-data docutils literal notranslate"><span class="pre">AF_INET6</span></code></a> dependendo do <em>host</em> (ou do argumento <em>family</em>, se fornecido).</p>
<p>O tipo de soquete será <a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-data docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code></a>.</p>
<p><em>protocol_factory</em> deve ser um chamável que retorne uma implementação do <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">protocolo asyncio</span></a>.</p>
<p>Este método tentará estabelecer a conexão em segundo plano. Quando tiver sucesso, ele retorna um par <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code>.</p>
<p>A sinopse cronológica da operação subjacente é conforme abaixo:</p>
<ol class="arabic simple">
<li><p>A conexão é estabelecida e um <a class="reference internal" href="asyncio-protocol.html#asyncio-transport"><span class="std std-ref">transporte</span></a> é criado para ela.</p></li>
<li><p><em>protocol_factory</em> é chamada sem argumentos e é esperada que retorne uma instância de <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">protocolo</span></a>.</p></li>
<li><p>A instância de protocolo é acoplada com o transporte, através da chamada do seu método <a class="reference internal" href="asyncio-protocol.html#asyncio.BaseProtocol.connection_made" title="asyncio.BaseProtocol.connection_made"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connection_made()</span></code></a>.</p></li>
<li><p>Uma tupla <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code> é retornada ao ter sucesso.</p></li>
</ol>
<p>O transporte criado é um stream bi-direcional dependente de implementação.</p>
<p>Outros argumentos:</p>
<ul>
<li><p><em>ssl</em>: se fornecido e não for falso, um transporte SSL/TLS é criado (por padrão um transporte TCP simples é criado). Se <em>ssl</em> for um objeto <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLContext</span></code></a>, este contexto é usado para criar o transporte; se <em>ssl</em> for <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>, um contexto padrão retornado de <a class="reference internal" href="ssl.html#ssl.create_default_context" title="ssl.create_default_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">ssl.create_default_context()</span></code></a> é usado.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver também</p>
<p><a class="reference internal" href="ssl.html#ssl-security"><span class="std std-ref">Considerações de segurança sobre SSL/TLS</span></a></p>
</div>
</li>
<li><p><em>server_hostname</em> define ou substitui o hostname que o certificado do servidor de destino será pareado contra. Deve ser passado apenas se <em>ssl</em> não for <code class="docutils literal notranslate"><span class="pre">None</span></code>. Por padrão o valor do argumento <em>host</em> é usado. Se <em>host</em> for vazio, não existe valor padrão e você deve passar um valor para <em>server_hostname</em>. Se <em>server_hostname</em> for uma string vazia, o pareamento de hostname é desabilitado (o que é um risco de segurança sério, permitindo ataques potenciais man-in-the-middle).</p></li>
<li><p><em>family</em>, <em>proto</em>, <em>flags</em> são os endereços familiares, protocolos e sinalizadores opcionais a serem passados por getaddrinfo() para resolução do <em>host</em>. Se fornecidos, eles devem ser todos inteiros e constantes correspondentes do módulo <a class="reference internal" href="socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a>.</p></li>
<li><p><em>happy_eyeballs_delay</em>, se fornecido, habilita Happy Eyeballs para esta conexão. Ele deve ser um número de ponto flutuante representando o tempo em segundos para aguardar uma tentativa de conexão encerrar, antes de começar a próxima tentativa em paralelo. Este é o “Atraso na tentativa de conexão” conforme definido na <span class="target" id="index-15"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc8305.html"><strong>RFC 8305</strong></a>. Um valor padrão sensível recomendado pela  RFC é``0.25`` (250 millisegundos).</p></li>
<li><p><em>interleave</em> controla o reordenamento de endereços quando um nome de servidor resolve para múltiplos endereços IP. Se <code class="docutils literal notranslate"><span class="pre">0</span></code> ou não especificado, nenhum reordenamento é feito, e endereços são tentados na ordem retornada por <a class="reference internal" href="#asyncio.loop.getaddrinfo" title="asyncio.loop.getaddrinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getaddrinfo()</span></code></a>. Se um inteiro positivo for especificado, os endereços são intercalados por um endereço familiar, e o inteiro fornecido é interpretado como “Contagem da família do primeiro endereço” conforme definido na <span class="target" id="index-16"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc8305.html"><strong>RFC 8305</strong></a>. O padrão é <code class="docutils literal notranslate"><span class="pre">0</span></code> se <em>happy_eyeballs_delay</em> não for especificado, e <code class="docutils literal notranslate"><span class="pre">1</span></code> se ele for.</p></li>
<li><p><em>sock</em>, se fornecido, deve ser um objeto <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a> já existente, já conectado, para ser usado por transporte. Se <em>sock</em> é fornecido, <em>host</em>, <em>port</em>, <em>family</em>, <em>proto</em>, <em>flags</em>, <em>happy_eyeballs_delay</em>, <em>interleave</em> e <em>local_addr</em> não devem ser especificados.</p></li>
<li><p><em>local_addr</em>, se fornecido, é uma tupla de <code class="docutils literal notranslate"><span class="pre">(local_host,</span> <span class="pre">local_port)</span></code> usada para se ligar ao soquete localmente. O <em>local_host</em> e a <em>local_port</em> são procurados usando <code class="docutils literal notranslate"><span class="pre">getaddrinfo()</span></code>, de forma similar para <em>host</em> e <em>port</em>.</p></li>
<li><p><em>ssl_handshake_timeout</em> é (para uma conexão TLS) o tempo em segundos para aguardar pelo encerramento do aperto de mão TLS, antes de abortar a conexão. <code class="docutils literal notranslate"><span class="pre">60.0</span></code> segundos se for``None`` (valor padrão).</p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.5: </span>Adicionado suporte para SSL/TLS na <a class="reference internal" href="#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProactorEventLoop</span></code></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.6: </span>A opção de soquete <code class="xref py py-data docutils literal notranslate"><span class="pre">TCP_NODELAY</span></code> é definida por padrão para todas as conexões TCP.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.7: </span>Added the <em>ssl_handshake_timeout</em> parameter.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.8: </span>Adicionados os parâmetros <em>happy_eyeballs_delay</em> e <em>interleave</em>.</p>
<p>Algoritmo Happy Eyeballs: Sucesso com servidores de pilha dupla. Quando o endereço e protocolo de um servidor IPv4 estão funcionando, mas o endereço e protocolo de um servidor IPv6 não estão, uma aplicação cliente de pilha dupla experiência atraso de conexão significativo comparado com um cliente puramente IPv4. Isso é indesejável porque causa o cliente de pilha dupla a ter uma experiência de usuário pior. Este documento espeifica requisitos para algoritmos, que reduzem esse atraso visível pelo usuário e fornece um algoritmo.</p>
<p>Para mais informações: <a class="reference external" href="https://tools.ietf.org/html/rfc6555">https://tools.ietf.org/html/rfc6555</a></p>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver também</p>
<p>A função <a class="reference internal" href="asyncio-stream.html#asyncio.open_connection" title="asyncio.open_connection"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_connection()</span></code></a> é uma API alternativa de alto nível. Ela retorna um par de (<a class="reference internal" href="asyncio-stream.html#asyncio.StreamReader" title="asyncio.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a>, <a class="reference internal" href="asyncio-stream.html#asyncio.StreamWriter" title="asyncio.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a>) que pode ser usado diretamente em código async/await.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.create_datagram_endpoint">
<em class="property">coroutine </em><code class="sig-prename descclassname">loop.</code><code class="sig-name descname">create_datagram_endpoint</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">protocol_factory</span></em>, <em class="sig-param"><span class="n">local_addr</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">remote_addr</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">family</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">proto</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">flags</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">reuse_address</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">reuse_port</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">allow_broadcast</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">sock</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.create_datagram_endpoint" title="Link permanente para esta definição">¶</a></dt>
<dd><div class="admonition note">
<p class="admonition-title">Nota</p>
<p>O parâmetro <em>reuse_address</em> não é mais suportado, assim como usar <code class="xref py py-data docutils literal notranslate"><span class="pre">SO_REUSEADDR</span></code> representa uma preocupação de segurança significativa para UDP. Passar <code class="docutils literal notranslate"><span class="pre">reuse_address=True</span></code> explicitamente irá levantar uma exceção.</p>
<p>Quando múltiplos processos com diferentes UIDs atribuem soquetes para um endereço de soquete UDP idêntico com <code class="docutils literal notranslate"><span class="pre">SO_REUSEADDR</span></code>, pacotes recebidos podem ser distribuídos aleatoriamente entre os soquetes.</p>
<p>Para plataformas suportadas, <em>reuse_port</em> pode ser usado como um substituto para funcionalidades similares. Com <em>reuse_port</em>, <code class="xref py py-data docutils literal notranslate"><span class="pre">SO_REUSEPORT</span></code> é usado ao invés, o qual especificamente previne processos com diferentes UIDs de atribuir soquetes para o mesmo endereço do soquete.</p>
</div>
<p>Cria uma conexão de datagrama.</p>
<p>A família de soquetes pode ser <a class="reference internal" href="socket.html#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-data docutils literal notranslate"><span class="pre">AF_INET</span></code></a>, <a class="reference internal" href="socket.html#socket.AF_INET6" title="socket.AF_INET6"><code class="xref py py-data docutils literal notranslate"><span class="pre">AF_INET6</span></code></a>, ou <a class="reference internal" href="socket.html#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-data docutils literal notranslate"><span class="pre">AF_UNIX</span></code></a>, dependendo do <em>host</em> (ou do argumento <em>family</em>, se fornecido).</p>
<p>O tipo de soquete será <a class="reference internal" href="socket.html#socket.SOCK_DGRAM" title="socket.SOCK_DGRAM"><code class="xref py py-data docutils literal notranslate"><span class="pre">SOCK_DGRAM</span></code></a>.</p>
<p><em>protocol_factory</em> deve ser algo chamável, retornando uma implementação de <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">protocolo</span></a>.</p>
<p>Uma tupla de <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code> é retornada em caso de sucesso.</p>
<p>Outros argumentos:</p>
<ul class="simple">
<li><p><em>local_addr</em>, se fornecido, é uma tupla de <code class="docutils literal notranslate"><span class="pre">(local_host,</span> <span class="pre">local_port)</span></code> usada para ligar o soquete localmente. O <em>local_host</em> e a <em>local_port</em> são procurados usando <a class="reference internal" href="#asyncio.loop.getaddrinfo" title="asyncio.loop.getaddrinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getaddrinfo()</span></code></a>.</p></li>
<li><p><em>remote_addr</em>, se fornecido, é uma tupla de <code class="docutils literal notranslate"><span class="pre">(remote_host,</span> <span class="pre">remote_port)</span></code> usada para conectar o soquete a um endereço remoto. O <em>remote_host</em> e a <em>remote_port</em> são procurados usando <a class="reference internal" href="#asyncio.loop.getaddrinfo" title="asyncio.loop.getaddrinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getaddrinfo()</span></code></a>.</p></li>
<li><p><em>family</em>, <em>proto</em>, <em>flags</em> são os endereços familiares, protocolo e flags opcionais a serem passados para <a class="reference internal" href="#asyncio.loop.getaddrinfo" title="asyncio.loop.getaddrinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getaddrinfo()</span></code></a> para resolução do <em>host</em>. Se fornecido, esses devem ser todos inteiros do módulo de constantes <a class="reference internal" href="socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> correspondente.</p></li>
<li><p><em>reuse_port</em> avisa o kernel para permitir este endpoint para ser ligado a mesma porta da mesma forma que outros endpoints existentes estão ligados a, contanto que todos eles definam este flag quando forem criados. Esta opção não é suportada no Windows e em alguns sistemas Unix. Se a constante <code class="xref py py-data docutils literal notranslate"><span class="pre">SO_REUSEPORT</span></code> não estiver definida, então esta capacidade não é suportada.</p></li>
<li><p><em>allow_broadcast</em> avisa o kernel para permitir que este endpoint envie mensagens para o endereço de broadcast.</p></li>
<li><p><em>sock</em> pode opcionalmente ser especificado em ordem para usar um objeto <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a> pre-existente, já conectado, para ser usado pelo transporte. Se especificado, <em>local_addr</em> e <em>remote_addr</em> devem ser omitidos (devem ser <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>).</p></li>
</ul>
<p>Veja <a class="reference internal" href="asyncio-protocol.html#asyncio-udp-echo-client-protocol"><span class="std std-ref">protocolo UDP eco cliente</span></a> e <a class="reference internal" href="asyncio-protocol.html#asyncio-udp-echo-server-protocol"><span class="std std-ref">protocolo UDP eco servidor</span></a> para exemplos.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.4.4: </span>Os parâmetros <em>family</em>, <em>proto</em>, <em>flags</em>, <em>reuse_address</em>, <em>reuse_port, *allow_broadcast</em>, e <em>sock</em> foram adicionados.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.8.1: </span>O parâmetro <em>reuse_address</em> não é mais suportado devido a preocupações de segurança.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.8: </span>Adicionado suporte para Windows.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.create_unix_connection">
<em class="property">coroutine </em><code class="sig-prename descclassname">loop.</code><code class="sig-name descname">create_unix_connection</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">protocol_factory</span></em>, <em class="sig-param"><span class="n">path</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">ssl</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">sock</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">server_hostname</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ssl_handshake_timeout</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.create_unix_connection" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Cria uma conexão Unix.</p>
<p>A família de soquete será <a class="reference internal" href="socket.html#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-data docutils literal notranslate"><span class="pre">AF_UNIX</span></code></a>; o tipo de soquete será <a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-data docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code></a>.</p>
<p>Uma tupla de <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code> é retornada em caso de sucesso.</p>
<p><em>path</em> é o nome de um soquete de domínio Unix e é obrigatório, a não ser que um parâmetro <em>sock</em> seja esecificado. Soquetes Unix abstratos, <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, e caminhos <a class="reference internal" href="pathlib.html#pathlib.Path" title="pathlib.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code></a> são suportados.</p>
<p>Veja a documentação do método <a class="reference internal" href="#asyncio.loop.create_connection" title="asyncio.loop.create_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_connection()</span></code></a> para informações a respeito de argumentos para este método.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Disponibilidade</span></a>: Unix.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.7: </span>Added the <em>ssl_handshake_timeout</em> parameter.
The <em>path</em> parameter can now be a <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p>
</div>
</dd></dl>

</section>
<section id="creating-network-servers">
<h3><a class="toc-backref" href="#id6">Criando servidores de rede</a><a class="headerlink" href="#creating-network-servers" title="Link permanente para este título">¶</a></h3>
<dl class="py method">
<dt id="asyncio.loop.create_server">
<em class="property">coroutine </em><code class="sig-prename descclassname">loop.</code><code class="sig-name descname">create_server</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">protocol_factory</span></em>, <em class="sig-param"><span class="n">host</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">port</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">family</span><span class="o">=</span><span class="default_value">socket.AF_UNSPEC</span></em>, <em class="sig-param"><span class="n">flags</span><span class="o">=</span><span class="default_value">socket.AI_PASSIVE</span></em>, <em class="sig-param"><span class="n">sock</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">backlog</span><span class="o">=</span><span class="default_value">100</span></em>, <em class="sig-param"><span class="n">ssl</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">reuse_address</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">reuse_port</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ssl_handshake_timeout</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">start_serving</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.create_server" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Cria um servidor TCP (tipo de soquete <a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-data docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code></a>) escutando em <em>port</em> do entedeço <em>host</em>.</p>
<p>Retorna um objeto <a class="reference internal" href="#asyncio.Server" title="asyncio.Server"><code class="xref py py-class docutils literal notranslate"><span class="pre">Server</span></code></a>.</p>
<p>Argumentos:</p>
<ul class="simple">
<li><p><em>protocol_factory</em> deve ser algo chamável, retornando uma implementação de <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">protocolo</span></a>.</p></li>
<li><p>O parâmetro <em>host</em> pode ser definido para diversos tipos, o qual determina onde o servidor deve escutar:</p>
<ul>
<li><p>Se <em>host</em> for uma string, o servidor TCP está vinculado a apenas uma interface de rede, especificada por <em>host</em>.</p></li>
<li><p>Se <em>host</em> é uma sequência de strings, o servidor TCP está vinculado a todas as interfaces de rede especificadas pela sequência.</p></li>
<li><p>Se <em>host</em> é uma string vazia ou <code class="docutils literal notranslate"><span class="pre">None</span></code>, todas as interfaces são assumidas e uma lista de múltiplos soquetes será retornada (muito provavelmente um para IPv4 e outro para IPv6).</p></li>
</ul>
</li>
<li><p>The <em>port</em> parameter can be set to specify which port the server should
listen on. If <code class="docutils literal notranslate"><span class="pre">0</span></code> or <code class="docutils literal notranslate"><span class="pre">None</span></code> (the default), a random unused port will
be selected (note that if <em>host</em> resolves to multiple network interfaces,
a different random port will be selected for each interface).</p></li>
<li><p><em>family</em> pode ser definido para <a class="reference internal" href="socket.html#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-data docutils literal notranslate"><span class="pre">socket.AF_INET</span></code></a> ou <a class="reference internal" href="socket.html#socket.AF_INET6" title="socket.AF_INET6"><code class="xref py py-data docutils literal notranslate"><span class="pre">AF_INET6</span></code></a> para forçar o soquete a usar IPv4 ou IPv6. Se não for definido, <em>family</em> será determinado a partir do nome do servidor (por padrão será <code class="xref py py-data docutils literal notranslate"><span class="pre">AF_UNSPEC</span></code>).</p></li>
<li><p><em>flags</em> é uma máscara de bits para <a class="reference internal" href="#asyncio.loop.getaddrinfo" title="asyncio.loop.getaddrinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getaddrinfo()</span></code></a>.</p></li>
<li><p><em>sock</em> pode opcionalmente ser especificado para usar um objeto soquete pré-existente. Se especificado, <em>host</em> e <em>port</em> não devem ser especificados.</p></li>
<li><p><em>backlog</em> é o número máximo de conexões enfileiradas pasadas para <a class="reference internal" href="socket.html#socket.socket.listen" title="socket.socket.listen"><code class="xref py py-meth docutils literal notranslate"><span class="pre">listen()</span></code></a> (padrão é 100).</p></li>
<li><p><em>ssl</em> pode ser definido para uma instância de <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> para habilitar TLS sobre as conexões aceitas.</p></li>
<li><p><em>reuse_address</em> diz ao kernel para reusar um soquete local em estado <code class="docutils literal notranslate"><span class="pre">TIME_WAIT</span></code>, serm aguardar pela expiração natural do seu tempo limite. Se não especificado, será automaticamente definida como <code class="docutils literal notranslate"><span class="pre">True</span></code> no Unix.</p></li>
<li><p><em>reuse_port</em> diz ao kernel para permitir que este endpoint seja vinculado a mesma porta que outros endpoints existentes estão vinculados, contanto que todos eles definam este sinalizador quando forem criados. Esta opção não é suportada no Windows.</p></li>
<li><p><em>ssl_handshake_timeout</em> é (para um servidor TLS) o tempo em segundos para aguardar pelo aperto de mão TLS ser concluído, antes de abortar a conexão. <code class="docutils literal notranslate"><span class="pre">60.0</span></code> segundos se <code class="docutils literal notranslate"><span class="pre">None</span></code> (valor padrão).</p></li>
<li><p>Definir <em>start_serving</em> para <code class="docutils literal notranslate"><span class="pre">True</span></code> (o valor padrão) faz o servidor criado começar a aceitar conexões imediatamente. Quando definido para <code class="docutils literal notranslate"><span class="pre">False</span></code>, o usuário deve aguardar com <a class="reference internal" href="#asyncio.Server.start_serving" title="asyncio.Server.start_serving"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Server.start_serving()</span></code></a> ou <a class="reference internal" href="#asyncio.Server.serve_forever" title="asyncio.Server.serve_forever"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Server.serve_forever()</span></code></a> para fazer o servidor começar a aceitar conexões.</p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.5: </span>Adicionado suporte para SSL/TLS na <a class="reference internal" href="#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProactorEventLoop</span></code></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.5.1: </span>O parâmetro <em>host</em> pode ser uma sequência de strings.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.6: </span>Added <em>ssl_handshake_timeout</em> and <em>start_serving</em> parameters.
The socket option <code class="xref py py-data docutils literal notranslate"><span class="pre">TCP_NODELAY</span></code> is set by default
for all TCP connections.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver também</p>
<p>A função <a class="reference internal" href="asyncio-stream.html#asyncio.start_server" title="asyncio.start_server"><code class="xref py py-func docutils literal notranslate"><span class="pre">start_server()</span></code></a> é uma API alternativa de alto nível que retorna um par de <a class="reference internal" href="asyncio-stream.html#asyncio.StreamReader" title="asyncio.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a> e <a class="reference internal" href="asyncio-stream.html#asyncio.StreamWriter" title="asyncio.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a> que pode ser usado em um código async/await.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.create_unix_server">
<em class="property">coroutine </em><code class="sig-prename descclassname">loop.</code><code class="sig-name descname">create_unix_server</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">protocol_factory</span></em>, <em class="sig-param"><span class="n">path</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">sock</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">backlog</span><span class="o">=</span><span class="default_value">100</span></em>, <em class="sig-param"><span class="n">ssl</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ssl_handshake_timeout</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">start_serving</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.create_unix_server" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Similar a <a class="reference internal" href="#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_server()</span></code></a>, mas trabalha com a família de soquete <a class="reference internal" href="socket.html#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-data docutils literal notranslate"><span class="pre">AF_UNIX</span></code></a>.</p>
<p><em>path</em> é o nome de um soquete de domínio Unix, e é obrigatório, a não ser que um argumento <em>sock</em> seja fornecido. Soquetes Unix abstratos, <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, e caminhos <a class="reference internal" href="pathlib.html#pathlib.Path" title="pathlib.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code></a> são suportados.</p>
<p>Veja a documentação do método <a class="reference internal" href="#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_server()</span></code></a> para informações sobre argumentos para este método.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Disponibilidade</span></a>: Unix.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.7: </span>Added the <em>ssl_handshake_timeout</em> and <em>start_serving</em> parameters.
The <em>path</em> parameter can now be a <a class="reference internal" href="pathlib.html#pathlib.Path" title="pathlib.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code></a> object.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.connect_accepted_socket">
<em class="property">coroutine </em><code class="sig-prename descclassname">loop.</code><code class="sig-name descname">connect_accepted_socket</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">protocol_factory</span></em>, <em class="sig-param"><span class="n">sock</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">ssl</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ssl_handshake_timeout</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.connect_accepted_socket" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Envolve uma conexão já aceita em um par transporte/protocolo.</p>
<p>Este método pode ser usado por servidores que aceitam conexões fora do asyncio, mas que usam asyncio para manipulá-las.</p>
<p>Parâmetros:</p>
<ul class="simple">
<li><p><em>protocol_factory</em> deve ser algo chamável, retornando uma implementação de <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">protocolo</span></a>.</p></li>
<li><p><em>sock</em> é um objeto soquete pré-existente retornado a partir de <a class="reference internal" href="socket.html#socket.socket.accept" title="socket.socket.accept"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.accept</span></code></a>.</p></li>
<li><p><em>ssl</em> pode ser definido para um <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> para habilitar SSL sobre as conexões aceitas.</p></li>
<li><p><em>ssl_handshake_timeout</em> é (para uma conexão SSL) o tempo em segundos para aguardar pelo aperto de mão SSL ser concluído, antes de abortar a conexão. <code class="docutils literal notranslate"><span class="pre">60.0</span></code> segundos se <code class="docutils literal notranslate"><span class="pre">None</span></code> (valor padrão).</p></li>
</ul>
<p>Retorna um par <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.5.3.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.7: </span>Added the <em>ssl_handshake_timeout</em> parameter.</p>
</div>
</dd></dl>

</section>
<section id="transferring-files">
<h3><a class="toc-backref" href="#id7">Transferindo arquivos</a><a class="headerlink" href="#transferring-files" title="Link permanente para este título">¶</a></h3>
<dl class="py method">
<dt id="asyncio.loop.sendfile">
<em class="property">coroutine </em><code class="sig-prename descclassname">loop.</code><code class="sig-name descname">sendfile</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">transport</span></em>, <em class="sig-param"><span class="n">file</span></em>, <em class="sig-param"><span class="n">offset</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">count</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">fallback</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.sendfile" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Envia um <em>file</em> sobre um <em>transport</em>. Retorna o número total de bytes enviados.</p>
<p>O método usa <a class="reference internal" href="os.html#os.sendfile" title="os.sendfile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">os.sendfile()</span></code></a> de alto desempenho, se disponível.</p>
<p><em>file</em> deve ser um objeto arquivo regular aberto em modo binário.</p>
<p><em>offset</em> indica a partir de onde deve iniciar a leitura do arquivo. Se especificado, <em>count</em> é o número total de bytes para transmitir, ao contrário de transmitir o arquivo até que EOF seja atingido. A posição do arquivo é sempre atualizada, mesmo quando este método levanta um erro, e <a class="reference internal" href="io.html#io.IOBase.tell" title="io.IOBase.tell"><code class="xref py py-meth docutils literal notranslate"><span class="pre">file.tell()</span></code></a> pode ser usado para obter o número atual de bytes enviados.</p>
<p><em>fallback</em> definido para <code class="docutils literal notranslate"><span class="pre">True</span></code> faz o asyncio manualmente ler e enviar o arquivo quando a plataforma não suporta a chamada de sistema sendfile (por exemplo Windows ou soquete SSL no Unix).</p>
<p>Levanta <a class="reference internal" href="asyncio-exceptions.html#asyncio.SendfileNotAvailableError" title="asyncio.SendfileNotAvailableError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SendfileNotAvailableError</span></code></a> se o sistema não suporta a chamada de sistema <em>sendfile</em> e <em>fallback</em> é <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.7.</span></p>
</div>
</dd></dl>

</section>
<section id="tls-upgrade">
<h3><a class="toc-backref" href="#id8">Atualizando TLS</a><a class="headerlink" href="#tls-upgrade" title="Link permanente para este título">¶</a></h3>
<dl class="py method">
<dt id="asyncio.loop.start_tls">
<em class="property">coroutine </em><code class="sig-prename descclassname">loop.</code><code class="sig-name descname">start_tls</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">transport</span></em>, <em class="sig-param"><span class="n">protocol</span></em>, <em class="sig-param"><span class="n">sslcontext</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">server_side</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">server_hostname</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ssl_handshake_timeout</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.start_tls" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Atualiza um conexão baseada em transporte existente para TLS.</p>
<p>Retorna uma nova instância de transporte, que o <em>protocol</em> deve começar a usar imediatamente após o <em>await</em>. A instância de <em>transport</em> passada para o método <em>start_tls</em> nunca deve ser usada novamente.</p>
<p>Parâmetros:</p>
<ul class="simple">
<li><p>instâncias de <em>transport</em> e <em>protocol</em>, que métodos como <a class="reference internal" href="#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_server()</span></code></a> e <a class="reference internal" href="#asyncio.loop.create_connection" title="asyncio.loop.create_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_connection()</span></code></a> retornam.</p></li>
<li><p><em>sslcontext</em>: uma instância configurada de <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a>.</p></li>
<li><p><em>server_side</em> informe <code class="docutils literal notranslate"><span class="pre">True</span></code> quando uma conexão no lado do servidor estiver sendo atualizada (como a que é criada por <a class="reference internal" href="#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_server()</span></code></a>).</p></li>
<li><p><em>server_hostname</em>: define ou substitui o nome do host no qual o servidor alvo do certificado será comparado.</p></li>
<li><p><em>ssl_handshake_timeout</em> é (para uma conexão TLS) o tempo em segundos para aguardar pelo encerramento do aperto de mão TLS, antes de abortar a conexão. <code class="docutils literal notranslate"><span class="pre">60.0</span></code> segundos se for``None`` (valor padrão).</p></li>
</ul>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.7.</span></p>
</div>
</dd></dl>

</section>
<section id="watching-file-descriptors">
<h3><a class="toc-backref" href="#id9">Observando descritores de arquivo</a><a class="headerlink" href="#watching-file-descriptors" title="Link permanente para este título">¶</a></h3>
<dl class="py method">
<dt id="asyncio.loop.add_reader">
<code class="sig-prename descclassname">loop.</code><code class="sig-name descname">add_reader</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fd</span></em>, <em class="sig-param"><span class="n">callback</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.add_reader" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Começa a monitorar o descritor de arquivo <em>fd</em> para disponibilidade de leitura e invoca a <em>callback</em> com os argumentos especificados assim que <em>fd</em> esteja disponível para leitura.</p>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.remove_reader">
<code class="sig-prename descclassname">loop.</code><code class="sig-name descname">remove_reader</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fd</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.remove_reader" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Para de monitorar o descritor de arquivo <em>fd</em> para disponibilidade de leitura.</p>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.add_writer">
<code class="sig-prename descclassname">loop.</code><code class="sig-name descname">add_writer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fd</span></em>, <em class="sig-param"><span class="n">callback</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.add_writer" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Começa a monitorar o descritor de arquivo <em>fd</em> para disponibilidade de escrita e invoca a <em>callback</em> com os argumentos especificados assim que <em>fd</em> esteja disponível para escrita.</p>
<p>Use <a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.partial()</span></code></a> <a class="reference internal" href="#asyncio-pass-keywords"><span class="std std-ref">para passar argumentos nomeados</span></a> para a <em>callback</em>.</p>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.remove_writer">
<code class="sig-prename descclassname">loop.</code><code class="sig-name descname">remove_writer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fd</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.remove_writer" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Para de monitorar o descritor de arquivo <em>fd</em> para disponibilidade de escrita.</p>
</dd></dl>

<p>Veja também a seção de <a class="reference internal" href="asyncio-platforms.html#asyncio-platform-support"><span class="std std-ref">Suporte a Plataformas</span></a> para algumas limitações desses métodos.</p>
</section>
<section id="working-with-socket-objects-directly">
<h3><a class="toc-backref" href="#id10">Trabalhando com objetos soquete diretamente</a><a class="headerlink" href="#working-with-socket-objects-directly" title="Link permanente para este título">¶</a></h3>
<p>Em geral, implementações de protocolo que usam APIs baseadas em transporte, tais como <a class="reference internal" href="#asyncio.loop.create_connection" title="asyncio.loop.create_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_connection()</span></code></a> e <a class="reference internal" href="#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_server()</span></code></a> são mais rápidas que implementações que trabalham com soquetes diretamente. Entretanto, existem alguns casos de uso quando o desempenho não é crítica, e trabalhar com objetos <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket</span></code></a> diretamente é mais conveniente.</p>
<dl class="py method">
<dt id="asyncio.loop.sock_recv">
<em class="property">coroutine </em><code class="sig-prename descclassname">loop.</code><code class="sig-name descname">sock_recv</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sock</span></em>, <em class="sig-param"><span class="n">nbytes</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.sock_recv" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Recebe até <em>nbytes</em> do <em>sock</em>. Versão assíncrona de <a class="reference internal" href="socket.html#socket.socket.recv" title="socket.socket.recv"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.recv()</span></code></a>.</p>
<p>Retorna os dados recebidos como um objeto de bytes.</p>
<p><em>sock</em> deve ser um soquete não bloqueante.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.7: </span>Apesar deste método sempre ter sido documentado como um método de corrotina, versões anteriores ao Python 3.7 retornavam um <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">Future</span></code></a>. Desde o Python 3.7 este é um método <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.sock_recv_into">
<em class="property">coroutine </em><code class="sig-prename descclassname">loop.</code><code class="sig-name descname">sock_recv_into</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sock</span></em>, <em class="sig-param"><span class="n">buf</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.sock_recv_into" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Dados recebidos do <em>sock</em> no buffer <em>buf</em>. Modelado baseado no método bloqueante <a class="reference internal" href="socket.html#socket.socket.recv_into" title="socket.socket.recv_into"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.recv_into()</span></code></a>.</p>
<p>Retorna o número de bytes escritos no buffer.</p>
<p><em>sock</em> deve ser um soquete não bloqueante.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.7.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.sock_sendall">
<em class="property">coroutine </em><code class="sig-prename descclassname">loop.</code><code class="sig-name descname">sock_sendall</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sock</span></em>, <em class="sig-param"><span class="n">data</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.sock_sendall" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Envia <em>data</em> para o soquete <em>sock</em>. Versão assíncrona de <a class="reference internal" href="socket.html#socket.socket.sendall" title="socket.socket.sendall"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.sendall()</span></code></a>.</p>
<p>Este método continua a enviar para o soquete até que todos os dados em <em>data</em> tenham sido enviados ou um erro ocorra. <code class="docutils literal notranslate"><span class="pre">None</span></code> é retornado em caso de sucesso. Ao ocorrer um erro, uma exceção é levantada. Adicionalmente, não existe nenhuma forma de determinar quantos dados, se algum, foram processados com sucesso pelo destinatário na conexão.</p>
<p><em>sock</em> deve ser um soquete não bloqueante.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.7: </span>Apesar deste método sempre ter sido documentado como um método de corrotina, antes do Python 3.7 ele retornava um <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">Future</span></code></a>. A partir do Python 3.7, este é um método <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.sock_connect">
<em class="property">coroutine </em><code class="sig-prename descclassname">loop.</code><code class="sig-name descname">sock_connect</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sock</span></em>, <em class="sig-param"><span class="n">address</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.sock_connect" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Conecta o <em>sock</em> em um endereço <em>address</em> remoto.</p>
<p>Versão assíncrona de <a class="reference internal" href="socket.html#socket.socket.connect" title="socket.socket.connect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.connect()</span></code></a>.</p>
<p><em>sock</em> deve ser um soquete não bloqueante.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.5.2: </span><code class="docutils literal notranslate"><span class="pre">address</span></code> não precisa mais ser resolvido. <code class="docutils literal notranslate"><span class="pre">sock_connect</span></code> irá tentar verificar se <em>address</em> já está resolvido chamando <a class="reference internal" href="socket.html#socket.inet_pton" title="socket.inet_pton"><code class="xref py py-func docutils literal notranslate"><span class="pre">socket.inet_pton()</span></code></a>. Se não estiver, <a class="reference internal" href="#asyncio.loop.getaddrinfo" title="asyncio.loop.getaddrinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.getaddrinfo()</span></code></a> será usado para resolver <em>address</em>.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver também</p>
<p><a class="reference internal" href="#asyncio.loop.create_connection" title="asyncio.loop.create_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_connection()</span></code></a> e  <a class="reference internal" href="asyncio-stream.html#asyncio.open_connection" title="asyncio.open_connection"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.open_connection()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.sock_accept">
<em class="property">coroutine </em><code class="sig-prename descclassname">loop.</code><code class="sig-name descname">sock_accept</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sock</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.sock_accept" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Aceita uma conexão. Modelado baseado no método bloqueante <a class="reference internal" href="socket.html#socket.socket.accept" title="socket.socket.accept"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.accept()</span></code></a>.</p>
<p>O soquete deve estar vinculado a um endereço e escutando por conexões. O valor de retorno é um par <code class="docutils literal notranslate"><span class="pre">(conn,</span> <span class="pre">address)</span></code> onde <em>conn</em> é um <em>novo</em> objeto de soquete usável para enviar e receber dados na conexão, e <em>address</em> é o endereço vinculado ao soquete no outro extremo da conexão.</p>
<p><em>sock</em> deve ser um soquete não bloqueante.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.7: </span>Apesar deste método sempre ter sido documentado como um método de corrotina, antes do Python 3.7 ele retornava um <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">Future</span></code></a>. Desde o Python 3.7, este é um método <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code>.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver também</p>
<p><a class="reference internal" href="#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_server()</span></code></a> e <a class="reference internal" href="asyncio-stream.html#asyncio.start_server" title="asyncio.start_server"><code class="xref py py-func docutils literal notranslate"><span class="pre">start_server()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.sock_sendfile">
<em class="property">coroutine </em><code class="sig-prename descclassname">loop.</code><code class="sig-name descname">sock_sendfile</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sock</span></em>, <em class="sig-param"><span class="n">file</span></em>, <em class="sig-param"><span class="n">offset</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">count</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">fallback</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.sock_sendfile" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Envia um arquivo usando <a class="reference internal" href="os.html#os.sendfile" title="os.sendfile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">os.sendfile</span></code></a> de alto desempenho se possível. Retorna o número total de bytes enviados.</p>
<p>Versão assíncrona de <a class="reference internal" href="socket.html#socket.socket.sendfile" title="socket.socket.sendfile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.sendfile()</span></code></a>.</p>
<p><em>sock</em> deve ser um <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket</span></code></a> <a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-const docutils literal notranslate"><span class="pre">socket.SOCK_STREAM</span></code></a> não bloqueante.</p>
<p><em>file</em> deve ser um objeto arquivo regular aberto em modo binário.</p>
<p><em>offset</em> indica a partir de onde deve iniciar a leitura do arquivo. Se especificado, <em>count</em> é o número total de bytes para transmitir, ao contrário de transmitir o arquivo até que EOF seja atingido. A posição do arquivo é sempre atualizada, mesmo quando este método levanta um erro, e <a class="reference internal" href="io.html#io.IOBase.tell" title="io.IOBase.tell"><code class="xref py py-meth docutils literal notranslate"><span class="pre">file.tell()</span></code></a> pode ser usado para obter o número atual de bytes enviados.</p>
<p><em>fallback</em>, quando definido para <code class="docutils literal notranslate"><span class="pre">True</span></code>, faz asyncio ler e enviar manualmente o arquivo, quando a plataforma não suporta a chamada de sistema sendfile (por exemplo Windows ou soquete SSL no Unix).</p>
<p>Levanta <a class="reference internal" href="asyncio-exceptions.html#asyncio.SendfileNotAvailableError" title="asyncio.SendfileNotAvailableError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SendfileNotAvailableError</span></code></a> se o sistema não suporta chamadas de sistema <em>sendfile</em> e <em>fallback</em> é <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<p><em>sock</em> deve ser um soquete não bloqueante.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.7.</span></p>
</div>
</dd></dl>

</section>
<section id="dns">
<h3><a class="toc-backref" href="#id11">DNS</a><a class="headerlink" href="#dns" title="Link permanente para este título">¶</a></h3>
<dl class="py method">
<dt id="asyncio.loop.getaddrinfo">
<em class="property">coroutine </em><code class="sig-prename descclassname">loop.</code><code class="sig-name descname">getaddrinfo</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">host</span></em>, <em class="sig-param"><span class="n">port</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">family</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">type</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">proto</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">flags</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.getaddrinfo" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Versão assíncrona de <a class="reference internal" href="socket.html#socket.getaddrinfo" title="socket.getaddrinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.getaddrinfo()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.getnameinfo">
<em class="property">coroutine </em><code class="sig-prename descclassname">loop.</code><code class="sig-name descname">getnameinfo</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sockaddr</span></em>, <em class="sig-param"><span class="n">flags</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.getnameinfo" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Versão assíncrona de <a class="reference internal" href="socket.html#socket.getnameinfo" title="socket.getnameinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.getnameinfo()</span></code></a>.</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.7: </span>Ambos os métodos <em>getaddrinfo</em> e <em>getnameinfo</em> sempre foram documentados para retornar uma corrotina, mas antes do Python 3.7 eles estavam, na verdade, retornando objetos <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Future</span></code></a>. A partir do Python 3.7, ambos os métodos são corrotinas.</p>
</div>
</section>
<section id="working-with-pipes">
<h3><a class="toc-backref" href="#id12">Trabalhando com encadeamentos</a><a class="headerlink" href="#working-with-pipes" title="Link permanente para este título">¶</a></h3>
<dl class="py method">
<dt id="asyncio.loop.connect_read_pipe">
<em class="property">coroutine </em><code class="sig-prename descclassname">loop.</code><code class="sig-name descname">connect_read_pipe</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">protocol_factory</span></em>, <em class="sig-param"><span class="n">pipe</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.connect_read_pipe" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Registra o extremo da leitura de um <em>pipe</em> no laço de eventos.</p>
<p><em>protocol_factory</em> deve ser um chamável que retorne uma implementação do <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">protocolo asyncio</span></a>.</p>
<p><em>pipe</em> é um <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">objeto arquivo ou similar</span></a>.</p>
<p>Retorna um par <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code>, onde <em>transport</em> suporta a interface <a class="reference internal" href="asyncio-protocol.html#asyncio.ReadTransport" title="asyncio.ReadTransport"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReadTransport</span></code></a> e <em>protocol</em> é um objeto instanciado pelo <em>protocol_factory</em>.</p>
<p>Com o <a class="reference internal" href="#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">SelectorEventLoop</span></code></a> do laço de eventos, o <em>pipe</em> é definido para modo não bloqueante.</p>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.connect_write_pipe">
<em class="property">coroutine </em><code class="sig-prename descclassname">loop.</code><code class="sig-name descname">connect_write_pipe</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">protocol_factory</span></em>, <em class="sig-param"><span class="n">pipe</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.connect_write_pipe" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Registra o extremo de escrita do <em>pipe</em> no laço de eventos.</p>
<p><em>protocol_factory</em> deve ser um chamável que retorne uma implementação do <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">protocolo asyncio</span></a>.</p>
<p><em>pipe</em> é um <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">objeto arquivo ou similar</span></a>.</p>
<p>Retorna um part <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code>, onde <em>transport</em> suporta a interface <a class="reference internal" href="asyncio-protocol.html#asyncio.WriteTransport" title="asyncio.WriteTransport"><code class="xref py py-class docutils literal notranslate"><span class="pre">WriteTransport</span></code></a> e <em>protocol</em> é um objeto instanciado pelo <em>protocol_factory</em>.</p>
<p>Com o <a class="reference internal" href="#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">SelectorEventLoop</span></code></a> do laço de eventos, o <em>pipe</em> é definido para modo não bloqueante.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Nota</p>
<p><a class="reference internal" href="#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">SelectorEventLoop</span></code></a> não suporta os métodos acima no Windows. Use <a class="reference internal" href="#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProactorEventLoop</span></code></a> ao invés para Windows.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver também</p>
<p>Os métodos <a class="reference internal" href="#asyncio.loop.subprocess_exec" title="asyncio.loop.subprocess_exec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.subprocess_exec()</span></code></a> e <a class="reference internal" href="#asyncio.loop.subprocess_shell" title="asyncio.loop.subprocess_shell"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.subprocess_shell()</span></code></a>.</p>
</div>
</section>
<section id="unix-signals">
<h3><a class="toc-backref" href="#id13">Sinais Unix</a><a class="headerlink" href="#unix-signals" title="Link permanente para este título">¶</a></h3>
<dl class="py method">
<dt id="asyncio.loop.add_signal_handler">
<code class="sig-prename descclassname">loop.</code><code class="sig-name descname">add_signal_handler</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">signum</span></em>, <em class="sig-param"><span class="n">callback</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.add_signal_handler" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Define <em>callback</em> como o tratador para o sinal <em>signum</em>.</p>
<p>A função de retorno será invocada pelo <em>loop</em>, juntamente com outras funções de retorno enfileiradas e corrotinas executáveis daquele laço de eventos. Ao contrário de tratadores de sinal registrados usando <a class="reference internal" href="signal.html#signal.signal" title="signal.signal"><code class="xref py py-func docutils literal notranslate"><span class="pre">signal.signal()</span></code></a>, uma função de retorno registrada com esta função tem autorização para interagir com o laço de eventos.</p>
<p>Levanta <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> se o número do sinal é inválido ou impossível de capturar. Levanta <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> se existe um problema definindo o tratador.</p>
<p>Use <a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.partial()</span></code></a> <a class="reference internal" href="#asyncio-pass-keywords"><span class="std std-ref">para passar argumentos nomeados</span></a> para a <em>callback</em>.</p>
<p>Assim como <a class="reference internal" href="signal.html#signal.signal" title="signal.signal"><code class="xref py py-func docutils literal notranslate"><span class="pre">signal.signal()</span></code></a>, esta função deve ser invocada na thread principal.</p>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.remove_signal_handler">
<code class="sig-prename descclassname">loop.</code><code class="sig-name descname">remove_signal_handler</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sig</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.remove_signal_handler" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Remove o tratador para o sinal <em>sig</em>.</p>
<p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> se o tratador de sinal foi removido, ou <code class="docutils literal notranslate"><span class="pre">False</span></code> se nenhum tratador foi definido para o sinal fornecido.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Disponibilidade</span></a>: Unix.</p>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">Ver também</p>
<p>O módulo <a class="reference internal" href="signal.html#module-signal" title="signal: Set handlers for asynchronous events."><code class="xref py py-mod docutils literal notranslate"><span class="pre">signal</span></code></a>.</p>
</div>
</section>
<section id="executing-code-in-thread-or-process-pools">
<h3><a class="toc-backref" href="#id14">Executando código em conjuntos de threads ou processos</a><a class="headerlink" href="#executing-code-in-thread-or-process-pools" title="Link permanente para este título">¶</a></h3>
<dl class="py method">
<dt id="asyncio.loop.run_in_executor">
<em class="property">awaitable </em><code class="sig-prename descclassname">loop.</code><code class="sig-name descname">run_in_executor</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">executor</span></em>, <em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.run_in_executor" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Providencia para a <em>func</em> ser chamada no executor especificado.</p>
<p>O argumento <em>executor</em> deve ser uma instância <a class="reference internal" href="concurrent.futures.html#concurrent.futures.Executor" title="concurrent.futures.Executor"><code class="xref py py-class docutils literal notranslate"><span class="pre">concurrent.futures.Executor</span></code></a>. O executor padrão é usado se <em>executor</em> for <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>Exemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">concurrent.futures</span>

<span class="k">def</span> <span class="nf">blocking_io</span><span class="p">():</span>
    <span class="c1"># File operations (such as logging) can block the</span>
    <span class="c1"># event loop: run them in a thread pool.</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;/dev/urandom&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">cpu_bound</span><span class="p">():</span>
    <span class="c1"># CPU-bound operations will block the event loop:</span>
    <span class="c1"># in general it is preferable to run them in a</span>
    <span class="c1"># process pool.</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span> <span class="o">**</span> <span class="mi">7</span><span class="p">))</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>

    <span class="c1">## Options:</span>

    <span class="c1"># 1. Run in the default loop&#39;s executor:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">run_in_executor</span><span class="p">(</span>
        <span class="kc">None</span><span class="p">,</span> <span class="n">blocking_io</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;default thread pool&#39;</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>

    <span class="c1"># 2. Run in a custom thread pool:</span>
    <span class="k">with</span> <span class="n">concurrent</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">ThreadPoolExecutor</span><span class="p">()</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">run_in_executor</span><span class="p">(</span>
            <span class="n">pool</span><span class="p">,</span> <span class="n">blocking_io</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;custom thread pool&#39;</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>

    <span class="c1"># 3. Run in a custom process pool:</span>
    <span class="k">with</span> <span class="n">concurrent</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">ProcessPoolExecutor</span><span class="p">()</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">run_in_executor</span><span class="p">(</span>
            <span class="n">pool</span><span class="p">,</span> <span class="n">cpu_bound</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;custom process pool&#39;</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</pre></div>
</div>
<p>Este método retorna um objeto <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Future</span></code></a>.</p>
<p>Use <a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.partial()</span></code></a> <a class="reference internal" href="#asyncio-pass-keywords"><span class="std std-ref">para passar argumentos nomeados</span></a> para <em>func</em>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.5.3: </span><a class="reference internal" href="#asyncio.loop.run_in_executor" title="asyncio.loop.run_in_executor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.run_in_executor()</span></code></a> não configura mais o atributo <code class="docutils literal notranslate"><span class="pre">max_workers</span></code> do executor do conjunto de thread que ele cria, ao invés disso ele deixa para o executor do conjunto de thread (<a class="reference internal" href="concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" title="concurrent.futures.ThreadPoolExecutor"><code class="xref py py-class docutils literal notranslate"><span class="pre">ThreadPoolExecutor</span></code></a>) para setar o valor padrão.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.set_default_executor">
<code class="sig-prename descclassname">loop.</code><code class="sig-name descname">set_default_executor</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">executor</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.set_default_executor" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Define <em>executor</em> como o executor padrão usado por <a class="reference internal" href="#asyncio.loop.run_in_executor" title="asyncio.loop.run_in_executor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run_in_executor()</span></code></a>. <em>executor</em> deve ser uma instância de <a class="reference internal" href="concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" title="concurrent.futures.ThreadPoolExecutor"><code class="xref py py-class docutils literal notranslate"><span class="pre">ThreadPoolExecutor</span></code></a>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde a versão 3.8: </span>Usar um executor que não é uma instância de <a class="reference internal" href="concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" title="concurrent.futures.ThreadPoolExecutor"><code class="xref py py-class docutils literal notranslate"><span class="pre">ThreadPoolExecutor</span></code></a> foi descontinuado, e irá disparar um erro no Python 3.9.</p>
</div>
<p><em>executor</em> deve ser uma instância de <a class="reference internal" href="concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" title="concurrent.futures.ThreadPoolExecutor"><code class="xref py py-class docutils literal notranslate"><span class="pre">concurrent.futures.ThreadPoolExecutor</span></code></a>.</p>
</dd></dl>

</section>
<section id="error-handling-api">
<h3><a class="toc-backref" href="#id15">Tratando erros da API</a><a class="headerlink" href="#error-handling-api" title="Link permanente para este título">¶</a></h3>
<p>Permite customizar como exceções são tratadas no laço de eventos.</p>
<dl class="py method">
<dt id="asyncio.loop.set_exception_handler">
<code class="sig-prename descclassname">loop.</code><code class="sig-name descname">set_exception_handler</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">handler</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.set_exception_handler" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Define <em>handler</em> como o novo tratador de exceções do laço de eventos.</p>
<p>Se <em>handler</em> for <code class="docutils literal notranslate"><span class="pre">None</span></code>, o tratador de exceções padrão será definido. Caso contrário, <em>handler</em> deve ser um chamável com a assinatura combinando <code class="docutils literal notranslate"><span class="pre">(loop,</span> <span class="pre">context)</span></code>, onde <code class="docutils literal notranslate"><span class="pre">loop</span></code> é a referência para o laço de eventos ativo, e <code class="docutils literal notranslate"><span class="pre">context</span></code> é um objeto <code class="docutils literal notranslate"><span class="pre">dict</span></code> contendo os detalhes da exceção (veja a documentação <a class="reference internal" href="#asyncio.loop.call_exception_handler" title="asyncio.loop.call_exception_handler"><code class="xref py py-meth docutils literal notranslate"><span class="pre">call_exception_handler()</span></code></a> para detalhes a respeito do contexto).</p>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.get_exception_handler">
<code class="sig-prename descclassname">loop.</code><code class="sig-name descname">get_exception_handler</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.get_exception_handler" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna o tratador de exceção atual, ou <code class="docutils literal notranslate"><span class="pre">None</span></code> se nenhum tratador de exceção customizado foi definido.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.5.2.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.default_exception_handler">
<code class="sig-prename descclassname">loop.</code><code class="sig-name descname">default_exception_handler</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">context</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.default_exception_handler" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Tratador de exceção padrão.</p>
<p>Isso é chamado quando uma exceção ocorre e nenhum tratador de exceção foi definido. Isso pode ser chamado por um tratador de exceção customizado que quer passar adiante para o comportamento do tratador padrão.</p>
<p>parâmetro <em>context</em> tem o mesmo significado que em <a class="reference internal" href="#asyncio.loop.call_exception_handler" title="asyncio.loop.call_exception_handler"><code class="xref py py-meth docutils literal notranslate"><span class="pre">call_exception_handler()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.call_exception_handler">
<code class="sig-prename descclassname">loop.</code><code class="sig-name descname">call_exception_handler</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">context</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.call_exception_handler" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Chama o tratador de exceção do laço de eventos atual.</p>
<p><em>context</em> é um objeto <code class="docutils literal notranslate"><span class="pre">dict</span></code> contendo as seguintes chaves (novas chaves podem ser introduzidas em versões futuras do Python):</p>
<ul class="simple">
<li><p>‘message’: Mensagem de erro;</p></li>
<li><p>‘exception’ (opcional): Objeto Exception;</p></li>
<li><p>‘future’ (opcional): instância de <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Future</span></code></a>;</p></li>
<li><p>‘task’ (opcional): instância de <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Task</span></code></a>;</p></li>
<li><p>‘handle’ (opcional): instância de <a class="reference internal" href="#asyncio.Handle" title="asyncio.Handle"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Handle</span></code></a>;</p></li>
<li><p>‘protocol’ (opcional): instância de <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">Protocol</span></a>;</p></li>
<li><p>‘transport’ (opcional): instância de <a class="reference internal" href="asyncio-protocol.html#asyncio-transport"><span class="std std-ref">Transport</span></a>;</p></li>
<li><p>‘socket’ (opcional): instância de <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a>;</p></li>
<li><dl class="simple">
<dt>‘asyncgen’ (opcional): Gerador assíncrono que causou</dt><dd><p>a exceção.</p>
</dd>
</dl>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Este método não deve ser substituído em subclasses de laços de evento. Para tratamento de exceções customizadas, use o método <a class="reference internal" href="#asyncio.loop.set_exception_handler" title="asyncio.loop.set_exception_handler"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_exception_handler()</span></code></a>.</p>
</div>
</dd></dl>

</section>
<section id="enabling-debug-mode">
<h3><a class="toc-backref" href="#id16">Habilitando o modo de debug</a><a class="headerlink" href="#enabling-debug-mode" title="Link permanente para este título">¶</a></h3>
<dl class="py method">
<dt id="asyncio.loop.get_debug">
<code class="sig-prename descclassname">loop.</code><code class="sig-name descname">get_debug</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.get_debug" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Obtém o modo de debug (<a class="reference internal" href="functions.html#bool" title="bool"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a>) do laço de eventos.</p>
<p>O valor padrão é <code class="docutils literal notranslate"><span class="pre">True</span></code> se a variável de ambiente <span class="target" id="index-17"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONASYNCIODEBUG"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONASYNCIODEBUG</span></code></a> estiver definida para uma string não vazia, <code class="docutils literal notranslate"><span class="pre">False</span></code> caso contrário.</p>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.set_debug">
<code class="sig-prename descclassname">loop.</code><code class="sig-name descname">set_debug</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">enabled</span><span class="p">:</span> <span class="n"><a class="reference internal" href="functions.html#bool" title="bool">bool</a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.set_debug" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Define o modo de debug do laço de eventos.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.7: </span>O novo <a class="reference internal" href="devmode.html#devmode"><span class="std std-ref">Modo de Desenvolvimento do Python</span></a> agora também pode ser usado para habilitar o modo de debug.</p>
</div>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">Ver também</p>
<p>O <a class="reference internal" href="asyncio-dev.html#asyncio-debug-mode"><span class="std std-ref">modo de debug de asyncio</span></a>.</p>
</div>
</section>
<section id="running-subprocesses">
<h3><a class="toc-backref" href="#id17">Executando Subprocessos</a><a class="headerlink" href="#running-subprocesses" title="Link permanente para este título">¶</a></h3>
<p>Métodos descritos nestas sub-seções são de baixo nível. Em código async/await regular, considere usar as funções convenientes de alto nível <a class="reference internal" href="asyncio-subprocess.html#asyncio.create_subprocess_shell" title="asyncio.create_subprocess_shell"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.create_subprocess_shell()</span></code></a> e <a class="reference internal" href="asyncio-subprocess.html#asyncio.create_subprocess_exec" title="asyncio.create_subprocess_exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.create_subprocess_exec()</span></code></a> ao invés.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>On Windows, the default event loop <a class="reference internal" href="#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProactorEventLoop</span></code></a> supports
subprocesses, whereas <a class="reference internal" href="#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">SelectorEventLoop</span></code></a> does not. See
<a class="reference internal" href="asyncio-platforms.html#asyncio-windows-subprocess"><span class="std std-ref">Subprocess Support on Windows</span></a> for
details.</p>
</div>
<dl class="py method">
<dt id="asyncio.loop.subprocess_exec">
<em class="property">coroutine </em><code class="sig-prename descclassname">loop.</code><code class="sig-name descname">subprocess_exec</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">protocol_factory</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="n">stdin</span><span class="o">=</span><span class="default_value">subprocess.PIPE</span></em>, <em class="sig-param"><span class="n">stdout</span><span class="o">=</span><span class="default_value">subprocess.PIPE</span></em>, <em class="sig-param"><span class="n">stderr</span><span class="o">=</span><span class="default_value">subprocess.PIPE</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.subprocess_exec" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Cria um subprocesso a partir de um ou mais argumentos de string especificados por <em>args</em>.</p>
<p><em>args</em> deve ser uma lista de strings representada por:</p>
<ul class="simple">
<li><p><a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>;</p></li>
<li><p>ou <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, encodados na <a class="reference internal" href="os.html#filesystem-encoding"><span class="std std-ref">codificação do sistema de arquivos</span></a>.</p></li>
</ul>
<p>A primeira string especifica o programa executável, e as strings remanescentes especificam os argumentos. Juntas, argumentos em string formam o <code class="docutils literal notranslate"><span class="pre">argv</span></code> do programa.</p>
<p>Isto é similar a classe <a class="reference internal" href="subprocess.html#subprocess.Popen" title="subprocess.Popen"><code class="xref py py-class docutils literal notranslate"><span class="pre">subprocess.Popen</span></code></a> da biblioteca padrão ser chamada com <code class="docutils literal notranslate"><span class="pre">shell=False</span></code> e a lista de strings ser passada como o primeiro argumento; entretanto, onde <a class="reference internal" href="subprocess.html#subprocess.Popen" title="subprocess.Popen"><code class="xref py py-class docutils literal notranslate"><span class="pre">Popen</span></code></a> recebe apenas um argumento no qual é uma lista de strings, <em>subprocess_exec</em> recebe múltiplos argumentos string.</p>
<p>O <em>protocol_factory</em> deve ser um chamável que retorne uma subclasse da classe <a class="reference internal" href="asyncio-protocol.html#asyncio.SubprocessProtocol" title="asyncio.SubprocessProtocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.SubprocessProtocol</span></code></a>.</p>
<p>Outros parâmetros:</p>
<ul>
<li><p><em>stdin</em> pode ser qualquer um destes:</p>
<ul class="simple">
<li><p>um objeto arquivo ou similar representando um encadeamento para ser conectado ao stream de entrada padrão do subprocesso usando <a class="reference internal" href="#asyncio.loop.connect_write_pipe" title="asyncio.loop.connect_write_pipe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connect_write_pipe()</span></code></a></p></li>
<li><p>a constante <a class="reference internal" href="subprocess.html#subprocess.PIPE" title="subprocess.PIPE"><code class="xref py py-const docutils literal notranslate"><span class="pre">subprocess.PIPE</span></code></a> (padrão), a qual criará um novo encadeamento e conectar a ele,</p></li>
<li><p>o valor <code class="docutils literal notranslate"><span class="pre">None</span></code>, o qual fará o subprocesso herdar o descritor de arquivo deste processo</p></li>
<li><p>a constante <a class="reference internal" href="subprocess.html#subprocess.DEVNULL" title="subprocess.DEVNULL"><code class="xref py py-const docutils literal notranslate"><span class="pre">subprocess.DEVNULL</span></code></a>, a qual indica que o arquivo especial <a class="reference internal" href="os.html#os.devnull" title="os.devnull"><code class="xref py py-data docutils literal notranslate"><span class="pre">os.devnull</span></code></a> será usado</p></li>
</ul>
</li>
<li><p><em>stdout</em> pode ser qualquer um destes:</p>
<ul class="simple">
<li><p>um objeto arquivo ou similar representando um encadeamento para ser conectado ao stream de saída padrão do subprocesso usando <a class="reference internal" href="#asyncio.loop.connect_write_pipe" title="asyncio.loop.connect_write_pipe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connect_write_pipe()</span></code></a></p></li>
<li><p>a constante <a class="reference internal" href="subprocess.html#subprocess.PIPE" title="subprocess.PIPE"><code class="xref py py-const docutils literal notranslate"><span class="pre">subprocess.PIPE</span></code></a> (padrão), a qual criará um novo encadeamento e conectar a ele,</p></li>
<li><p>o valor <code class="docutils literal notranslate"><span class="pre">None</span></code>, o qual fará o subprocesso herdar o descritor de arquivo deste processo</p></li>
<li><p>a constante <a class="reference internal" href="subprocess.html#subprocess.DEVNULL" title="subprocess.DEVNULL"><code class="xref py py-const docutils literal notranslate"><span class="pre">subprocess.DEVNULL</span></code></a>, a qual indica que o arquivo especial <a class="reference internal" href="os.html#os.devnull" title="os.devnull"><code class="xref py py-data docutils literal notranslate"><span class="pre">os.devnull</span></code></a> será usado</p></li>
</ul>
</li>
<li><p><em>stderr</em> pode ser qualquer um destes:</p>
<ul class="simple">
<li><p>um objeto arquivo ou similar representando um encadeamento para ser conectado ao stream de erro padrão do subprocesso usando <a class="reference internal" href="#asyncio.loop.connect_write_pipe" title="asyncio.loop.connect_write_pipe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connect_write_pipe()</span></code></a></p></li>
<li><p>a constante <a class="reference internal" href="subprocess.html#subprocess.PIPE" title="subprocess.PIPE"><code class="xref py py-const docutils literal notranslate"><span class="pre">subprocess.PIPE</span></code></a> (padrão), a qual criará um novo encadeamento e conectar a ele,</p></li>
<li><p>o valor <code class="docutils literal notranslate"><span class="pre">None</span></code>, o qual fará o subprocesso herdar o descritor de arquivo deste processo</p></li>
<li><p>a constante <a class="reference internal" href="subprocess.html#subprocess.DEVNULL" title="subprocess.DEVNULL"><code class="xref py py-const docutils literal notranslate"><span class="pre">subprocess.DEVNULL</span></code></a>, a qual indica que o arquivo especial <a class="reference internal" href="os.html#os.devnull" title="os.devnull"><code class="xref py py-data docutils literal notranslate"><span class="pre">os.devnull</span></code></a> será usado</p></li>
<li><p>a constante <a class="reference internal" href="subprocess.html#subprocess.STDOUT" title="subprocess.STDOUT"><code class="xref py py-const docutils literal notranslate"><span class="pre">subprocess.STDOUT</span></code></a>, a qual irá conectar o stream de erro padrão ao stream de saída padrão do processo</p></li>
</ul>
</li>
<li><p>Todos os outros argumentos nomeados são passados para <a class="reference internal" href="subprocess.html#subprocess.Popen" title="subprocess.Popen"><code class="xref py py-class docutils literal notranslate"><span class="pre">subprocess.Popen</span></code></a> sem interpretação, exceto <em>bufsize</em>, <em>universal_newlines</em>, <em>shell</em>, <em>text</em>, <em>encoding</em> e <em>errors</em>, os quais não devem ser especificados de forma alguma.</p>
<p>A API de subprocesso <code class="docutils literal notranslate"><span class="pre">asyncio</span></code> não suporta decodificar os streams como texto. <a class="reference internal" href="stdtypes.html#bytes.decode" title="bytes.decode"><code class="xref py py-func docutils literal notranslate"><span class="pre">bytes.decode()</span></code></a> pode ser usado para converter os bytes retornados do stream para texto.</p>
</li>
</ul>
<p>Veja o construtor da classe <a class="reference internal" href="subprocess.html#subprocess.Popen" title="subprocess.Popen"><code class="xref py py-class docutils literal notranslate"><span class="pre">subprocess.Popen</span></code></a> para documentação sobre outros argumentos.</p>
<p>Retorna um par <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code>, onde <em>transport</em> conforma com a classe base <a class="reference internal" href="asyncio-protocol.html#asyncio.SubprocessTransport" title="asyncio.SubprocessTransport"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.SubprocessTransport</span></code></a> e <em>protocol</em> é um objeto instanciado pelo <em>protocol_factory</em>.</p>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.subprocess_shell">
<em class="property">coroutine </em><code class="sig-prename descclassname">loop.</code><code class="sig-name descname">subprocess_shell</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">protocol_factory</span></em>, <em class="sig-param"><span class="n">cmd</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">stdin</span><span class="o">=</span><span class="default_value">subprocess.PIPE</span></em>, <em class="sig-param"><span class="n">stdout</span><span class="o">=</span><span class="default_value">subprocess.PIPE</span></em>, <em class="sig-param"><span class="n">stderr</span><span class="o">=</span><span class="default_value">subprocess.PIPE</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.subprocess_shell" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Cria um subprocesso a partir do <em>cmd</em>, o qual pode ser um <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> ou uma string de <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> codificada na <a class="reference internal" href="os.html#filesystem-encoding"><span class="std std-ref">codificação do sistema de arquivos</span></a>, usando a sintaxe “shell” da plataforma.</p>
<p>Isto é similar a classe <a class="reference internal" href="subprocess.html#subprocess.Popen" title="subprocess.Popen"><code class="xref py py-class docutils literal notranslate"><span class="pre">subprocess.Popen</span></code></a> da biblioteca padrão sendo chanada com <code class="docutils literal notranslate"><span class="pre">shell=True</span></code>.</p>
<p>O argumento <em>protocol_factory</em> deve ser um chamável que retorna uma subclasse da classe <a class="reference internal" href="asyncio-protocol.html#asyncio.SubprocessProtocol" title="asyncio.SubprocessProtocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">SubprocessProtocol</span></code></a>.</p>
<p>Veja <a class="reference internal" href="#asyncio.loop.subprocess_exec" title="asyncio.loop.subprocess_exec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subprocess_exec()</span></code></a> para mais detalhes sobre os argumentos remanescentes.</p>
<p>Retorna um par <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code>, onde <em>transport</em> conforma com a classe base <a class="reference internal" href="asyncio-protocol.html#asyncio.SubprocessTransport" title="asyncio.SubprocessTransport"><code class="xref py py-class docutils literal notranslate"><span class="pre">SubprocessTransport</span></code></a> e <em>protocol</em> é um objeto instanciado pelo <em>protocol_factory</em>.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>É responsabilidade da aplicação garantir que todos os espaços em branco e caracteres especiais sejam tratados apropriadamente para evitar vulnerabilidades de <a class="reference external" href="https://en.wikipedia.org/wiki/Shell_injection#Shell_injection">injeção shell</a> . A função <a class="reference internal" href="shlex.html#shlex.quote" title="shlex.quote"><code class="xref py py-func docutils literal notranslate"><span class="pre">shlex.quote()</span></code></a> pode ser usada para escapar espaços em branco e caracteres especiais apropriadamente em strings que serão usadas para construir comandos shell.</p>
</div>
</section>
</section>
<section id="callback-handles">
<h2>Tratadores de função de retorno<a class="headerlink" href="#callback-handles" title="Link permanente para este título">¶</a></h2>
<dl class="py class">
<dt id="asyncio.Handle">
<em class="property">class </em><code class="sig-prename descclassname">asyncio.</code><code class="sig-name descname">Handle</code><a class="headerlink" href="#asyncio.Handle" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Um objeto empacotador de função de retorno retornado por <a class="reference internal" href="#asyncio.loop.call_soon" title="asyncio.loop.call_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_soon()</span></code></a>, <a class="reference internal" href="#asyncio.loop.call_soon_threadsafe" title="asyncio.loop.call_soon_threadsafe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_soon_threadsafe()</span></code></a>.</p>
<dl class="py method">
<dt id="asyncio.Handle.cancel">
<code class="sig-name descname">cancel</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Handle.cancel" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Cancela a função de retorno. Se a função de retorno já tiver sido cancelada ou executada, este método não tem efeito.</p>
</dd></dl>

<dl class="py method">
<dt id="asyncio.Handle.cancelled">
<code class="sig-name descname">cancelled</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Handle.cancelled" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> se a função de retorno foi cancelada.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.7.</span></p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="asyncio.TimerHandle">
<em class="property">class </em><code class="sig-prename descclassname">asyncio.</code><code class="sig-name descname">TimerHandle</code><a class="headerlink" href="#asyncio.TimerHandle" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Um objeto empacotador de função de retorno retornado por <a class="reference internal" href="#asyncio.loop.call_later" title="asyncio.loop.call_later"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_later()</span></code></a>, e <a class="reference internal" href="#asyncio.loop.call_at" title="asyncio.loop.call_at"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_at()</span></code></a>.</p>
<p>Esta classe é uma subclasse de <a class="reference internal" href="#asyncio.Handle" title="asyncio.Handle"><code class="xref py py-class docutils literal notranslate"><span class="pre">Handle</span></code></a>.</p>
<dl class="py method">
<dt id="asyncio.TimerHandle.when">
<code class="sig-name descname">when</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.TimerHandle.when" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna o tempo de uma função de retorno agendada como <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> segundos.</p>
<p>O tempo é um timestamp absoluto, usando a mesma referência de tempo que <a class="reference internal" href="#asyncio.loop.time" title="asyncio.loop.time"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.time()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.7.</span></p>
</div>
</dd></dl>

</dd></dl>

</section>
<section id="server-objects">
<h2>Objetos Server<a class="headerlink" href="#server-objects" title="Link permanente para este título">¶</a></h2>
<p>Objetos Server são criados pelas funções <a class="reference internal" href="#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_server()</span></code></a>, <a class="reference internal" href="#asyncio.loop.create_unix_server" title="asyncio.loop.create_unix_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_unix_server()</span></code></a>, <a class="reference internal" href="asyncio-stream.html#asyncio.start_server" title="asyncio.start_server"><code class="xref py py-func docutils literal notranslate"><span class="pre">start_server()</span></code></a>, e <a class="reference internal" href="asyncio-stream.html#asyncio.start_unix_server" title="asyncio.start_unix_server"><code class="xref py py-func docutils literal notranslate"><span class="pre">start_unix_server()</span></code></a>.</p>
<p>Não instancie a classe diretamente</p>
<dl class="py class">
<dt id="asyncio.Server">
<em class="property">class </em><code class="sig-prename descclassname">asyncio.</code><code class="sig-name descname">Server</code><a class="headerlink" href="#asyncio.Server" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Objetos <em>Server</em> são gerenciadores de contexto assíncronos. Quando usados em uma instrução <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code>, é garantido que o objeto Server está fechado e não está aceitando novas conexões quando a instrução <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> estiver completa:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">srv</span> <span class="o">=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">create_server</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>

<span class="k">async</span> <span class="k">with</span> <span class="n">srv</span><span class="p">:</span>
    <span class="c1"># some code</span>

<span class="c1"># At this point, srv is closed and no longer accepts new connections.</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.7: </span>Objeto Server é um gerenciador de contexto assíncrono desde o Python 3.7.</p>
</div>
<dl class="py method">
<dt id="asyncio.Server.close">
<code class="sig-name descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Server.close" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Para de servir: fecha soquetes que estavam ouvindo e define o atributo <a class="reference internal" href="#asyncio.Server.sockets" title="asyncio.Server.sockets"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sockets</span></code></a> para <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>Os soquetes que representam conexões de clientes existentes que estão chegando são deixados em aberto.</p>
<p>O servidor é fechado de forma assíncrona, use a corrotina <a class="reference internal" href="#asyncio.Server.wait_closed" title="asyncio.Server.wait_closed"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait_closed()</span></code></a> para aguartar até que o servidor esteja fechado.</p>
</dd></dl>

<dl class="py method">
<dt id="asyncio.Server.get_loop">
<code class="sig-name descname">get_loop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Server.get_loop" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna o laço de eventos associado com o objeto server.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.7.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="asyncio.Server.start_serving">
<em class="property">coroutine </em><code class="sig-name descname">start_serving</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Server.start_serving" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Começa a aceitar conexões.</p>
<p>Este método é  method is idempotente, então ele pode ser cancelado quando o servidor já estiver servindo.</p>
<p>O parâmetro somente-nomeado <em>start_serving</em> para <a class="reference internal" href="#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_server()</span></code></a> e <a class="reference internal" href="asyncio-stream.html#asyncio.start_server" title="asyncio.start_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">asyncio.start_server()</span></code></a> permite criar um objeto Server que não está aceitando conexões inicialmente. Neste caso <code class="docutils literal notranslate"><span class="pre">Server.start_serving()</span></code>, ou <a class="reference internal" href="#asyncio.Server.serve_forever" title="asyncio.Server.serve_forever"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Server.serve_forever()</span></code></a> podem ser usados para fazer o Server começar a aceitar conexões.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.7.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="asyncio.Server.serve_forever">
<em class="property">coroutine </em><code class="sig-name descname">serve_forever</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Server.serve_forever" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Começa a aceitar conexões até que a corrotina seja cancelada. Cancelamento da task <code class="docutils literal notranslate"><span class="pre">serve_forever</span></code> causa o fechamento do servidor.</p>
<p>Este método pode ser chamado se o servidor já estiver aceitando conexões. Apenas uma task``serve_forever`` pode existir para cada objeto <em>Server</em>.</p>
<p>Exemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">client_connected</span><span class="p">(</span><span class="n">reader</span><span class="p">,</span> <span class="n">writer</span><span class="p">):</span>
    <span class="c1"># Communicate with the client with</span>
    <span class="c1"># reader/writer streams.  For example:</span>
    <span class="k">await</span> <span class="n">reader</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">):</span>
    <span class="n">srv</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">start_server</span><span class="p">(</span>
        <span class="n">client_connected</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">srv</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">(</span><span class="s1">&#39;127.0.0.1&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.7.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="asyncio.Server.is_serving">
<code class="sig-name descname">is_serving</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Server.is_serving" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> se o servidor estiver aceitando novas conexões.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.7.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="asyncio.Server.wait_closed">
<em class="property">coroutine </em><code class="sig-name descname">wait_closed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Server.wait_closed" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Aguarda até o método <a class="reference internal" href="#asyncio.Server.close" title="asyncio.Server.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> completar.</p>
</dd></dl>

<dl class="py attribute">
<dt id="asyncio.Server.sockets">
<code class="sig-name descname">sockets</code><a class="headerlink" href="#asyncio.Server.sockets" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Lista de objetos <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a> que o servidor está escutando.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.7: </span>Antes do Python 3.7 <code class="docutils literal notranslate"><span class="pre">Server.sockets</span></code> era usado para retornar uma lista interna de soquetes do server diretamente. No uma cópia dessa lista é retornada.</p>
</div>
</dd></dl>

</dd></dl>

</section>
<section id="event-loop-implementations">
<span id="asyncio-event-loops"></span><h2>Implementações do Laço de Eventos<a class="headerlink" href="#event-loop-implementations" title="Link permanente para este título">¶</a></h2>
<p>asyncio vem com duas implementações de laço de eventos diferente: <a class="reference internal" href="#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">SelectorEventLoop</span></code></a> e <a class="reference internal" href="#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProactorEventLoop</span></code></a>.</p>
<p>Por padrão asyncio está configurado para usar <a class="reference internal" href="#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">SelectorEventLoop</span></code></a> no Unix e <a class="reference internal" href="#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProactorEventLoop</span></code></a> no Windows.</p>
<dl class="py class">
<dt id="asyncio.SelectorEventLoop">
<em class="property">class </em><code class="sig-prename descclassname">asyncio.</code><code class="sig-name descname">SelectorEventLoop</code><a class="headerlink" href="#asyncio.SelectorEventLoop" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Um laço de eventos baseado no módulo <a class="reference internal" href="selectors.html#module-selectors" title="selectors: High-level I/O multiplexing."><code class="xref py py-mod docutils literal notranslate"><span class="pre">selectors</span></code></a>.</p>
<p>Usa o <em>seletor</em> mais eficiente disponível para a plataforma fornecida. Também é possível configurar manualmente a implementação exata do seletor a ser utilizada:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">selectors</span>

<span class="n">selector</span> <span class="o">=</span> <span class="n">selectors</span><span class="o">.</span><span class="n">SelectSelector</span><span class="p">()</span>
<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">SelectorEventLoop</span><span class="p">(</span><span class="n">selector</span><span class="p">)</span>
<span class="n">asyncio</span><span class="o">.</span><span class="n">set_event_loop</span><span class="p">(</span><span class="n">loop</span><span class="p">)</span>
</pre></div>
</div>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Disponibilidade</span></a>: Unix, Windows.</p>
</dd></dl>

<dl class="py class">
<dt id="asyncio.ProactorEventLoop">
<em class="property">class </em><code class="sig-prename descclassname">asyncio.</code><code class="sig-name descname">ProactorEventLoop</code><a class="headerlink" href="#asyncio.ProactorEventLoop" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Um laço de eventos para Windows que usa “Conclusão de Portas I/O” (IOCP).</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Disponibilidade</span></a>: Windows.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver também</p>
<p><a class="reference external" href="https://docs.microsoft.com/en-ca/windows/desktop/FileIO/i-o-completion-ports">Documentação da MSDN sobre conclusão de portas I/O</a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt id="asyncio.AbstractEventLoop">
<em class="property">class </em><code class="sig-prename descclassname">asyncio.</code><code class="sig-name descname">AbstractEventLoop</code><a class="headerlink" href="#asyncio.AbstractEventLoop" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Classe base abstrata para laços de eventos compatíveis com asyncio.</p>
<p>A seção <a class="reference internal" href="#asyncio-event-loop"><span class="std std-ref">Métodos de laço de eventos</span></a> lista todos os métodos que uma implementação alternativa de <code class="docutils literal notranslate"><span class="pre">AbstractEventLoop</span></code> deve definir.</p>
</dd></dl>

</section>
<section id="examples">
<h2>Exemplos<a class="headerlink" href="#examples" title="Link permanente para este título">¶</a></h2>
<p>Perceba que todos os exemplos nesta seção <strong>propositalmente</strong> mostram como usar as APIs de baixo nível do laço de eventos, tais como <a class="reference internal" href="#asyncio.loop.run_forever" title="asyncio.loop.run_forever"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.run_forever()</span></code></a> e <a class="reference internal" href="#asyncio.loop.call_soon" title="asyncio.loop.call_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_soon()</span></code></a>. Aplicações asyncio modernas raramente precisam ser escritas desta forma; considere usar as funções de alto nível como <a class="reference internal" href="asyncio-task.html#asyncio.run" title="asyncio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.run()</span></code></a>.</p>
<section id="hello-world-with-call-soon">
<span id="asyncio-example-lowlevel-helloworld"></span><h3>Hello World com call_soon()<a class="headerlink" href="#hello-world-with-call-soon" title="Link permanente para este título">¶</a></h3>
<p>Um exemplo usando o método <a class="reference internal" href="#asyncio.loop.call_soon" title="asyncio.loop.call_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_soon()</span></code></a> para agendar uma função de retorno. A função de retorno exibe <code class="docutils literal notranslate"><span class="pre">&quot;Hello</span> <span class="pre">World&quot;</span></code> e então para o laço de eventos:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="k">def</span> <span class="nf">hello_world</span><span class="p">(</span><span class="n">loop</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A callback to print &#39;Hello World&#39; and stop the event loop&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Hello World&#39;</span><span class="p">)</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>

<span class="c1"># Schedule a call to hello_world()</span>
<span class="n">loop</span><span class="o">.</span><span class="n">call_soon</span><span class="p">(</span><span class="n">hello_world</span><span class="p">,</span> <span class="n">loop</span><span class="p">)</span>

<span class="c1"># Blocking call interrupted by loop.stop()</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver também</p>
<p>Um exemplo similar a <a class="reference internal" href="asyncio-task.html#coroutine"><span class="std std-ref">Hello World</span></a> criado com uma corrotina e a função <a class="reference internal" href="asyncio-task.html#asyncio.run" title="asyncio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">run()</span></code></a>.</p>
</div>
</section>
<section id="display-the-current-date-with-call-later">
<span id="asyncio-example-call-later"></span><h3>Exibe a data atual com call_later()<a class="headerlink" href="#display-the-current-date-with-call-later" title="Link permanente para este título">¶</a></h3>
<p>Um exemplo de uma função de retorno mostrando a data atual a cada segundo. A função de retorno usa o método <a class="reference internal" href="#asyncio.loop.call_later" title="asyncio.loop.call_later"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_later()</span></code></a> para reagendar a si mesma depois de 5 segundos, e então para o laço de eventos:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">datetime</span>

<span class="k">def</span> <span class="nf">display_date</span><span class="p">(</span><span class="n">end_time</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">())</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">loop</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">end_time</span><span class="p">:</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">call_later</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">display_date</span><span class="p">,</span> <span class="n">end_time</span><span class="p">,</span> <span class="n">loop</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>

<span class="c1"># Schedule the first call to display_date()</span>
<span class="n">end_time</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">+</span> <span class="mf">5.0</span>
<span class="n">loop</span><span class="o">.</span><span class="n">call_soon</span><span class="p">(</span><span class="n">display_date</span><span class="p">,</span> <span class="n">end_time</span><span class="p">,</span> <span class="n">loop</span><span class="p">)</span>

<span class="c1"># Blocking call interrupted by loop.stop()</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver também</p>
<p>Um exemplo similar a <a class="reference internal" href="asyncio-task.html#asyncio-example-sleep"><span class="std std-ref">data atual</span></a> criado com uma corrotina e a função <a class="reference internal" href="asyncio-task.html#asyncio.run" title="asyncio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">run()</span></code></a>.</p>
</div>
</section>
<section id="watch-a-file-descriptor-for-read-events">
<span id="asyncio-example-watch-fd"></span><h3>Observa um descritor de arquivo por eventos de leitura<a class="headerlink" href="#watch-a-file-descriptor-for-read-events" title="Link permanente para este título">¶</a></h3>
<p>Aguarda até que um descritor de arquivo tenha recebido alguns dados usando o método <a class="reference internal" href="#asyncio.loop.add_reader" title="asyncio.loop.add_reader"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.add_reader()</span></code></a> e então fecha o laço de eventos:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">from</span> <span class="nn">socket</span> <span class="kn">import</span> <span class="n">socketpair</span>

<span class="c1"># Create a pair of connected file descriptors</span>
<span class="n">rsock</span><span class="p">,</span> <span class="n">wsock</span> <span class="o">=</span> <span class="n">socketpair</span><span class="p">()</span>

<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">reader</span><span class="p">():</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">rsock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Received:&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">decode</span><span class="p">())</span>

    <span class="c1"># We are done: unregister the file descriptor</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">remove_reader</span><span class="p">(</span><span class="n">rsock</span><span class="p">)</span>

    <span class="c1"># Stop the event loop</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

<span class="c1"># Register the file descriptor for read event</span>
<span class="n">loop</span><span class="o">.</span><span class="n">add_reader</span><span class="p">(</span><span class="n">rsock</span><span class="p">,</span> <span class="n">reader</span><span class="p">)</span>

<span class="c1"># Simulate the reception of data from the network</span>
<span class="n">loop</span><span class="o">.</span><span class="n">call_soon</span><span class="p">(</span><span class="n">wsock</span><span class="o">.</span><span class="n">send</span><span class="p">,</span> <span class="s1">&#39;abc&#39;</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>

<span class="k">try</span><span class="p">:</span>
    <span class="c1"># Run the event loop</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="c1"># We are done. Close sockets and the event loop.</span>
    <span class="n">rsock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">wsock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver também</p>
<ul class="simple">
<li><p>Um <a class="reference internal" href="asyncio-protocol.html#asyncio-example-create-connection"><span class="std std-ref">exemplo</span></a> similar usando transportes, protocolos, e o método <a class="reference internal" href="#asyncio.loop.create_connection" title="asyncio.loop.create_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_connection()</span></code></a>.</p></li>
<li><p>Outro <a class="reference internal" href="asyncio-stream.html#asyncio-example-create-connection-streams"><span class="std std-ref">exemplo</span></a> similar usando a função de alto nível <a class="reference internal" href="asyncio-stream.html#asyncio.open_connection" title="asyncio.open_connection"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.open_connection()</span></code></a> e streams.</p></li>
</ul>
</div>
</section>
<section id="set-signal-handlers-for-sigint-and-sigterm">
<span id="asyncio-example-unix-signals"></span><h3>Define tratadores de sinais para SIGINT e SIGTERM<a class="headerlink" href="#set-signal-handlers-for-sigint-and-sigterm" title="Link permanente para este título">¶</a></h3>
<p>(Este exemplo de <code class="docutils literal notranslate"><span class="pre">signals</span></code> apenas funciona no Unix.)</p>
<p>Registra tratadores para sinais <code class="xref py py-data docutils literal notranslate"><span class="pre">SIGINT</span></code> e <code class="xref py py-data docutils literal notranslate"><span class="pre">SIGTERM</span></code> usando o método <a class="reference internal" href="#asyncio.loop.add_signal_handler" title="asyncio.loop.add_signal_handler"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.add_signal_handler()</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">signal</span>

<span class="k">def</span> <span class="nf">ask_exit</span><span class="p">(</span><span class="n">signame</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;got signal </span><span class="si">%s</span><span class="s2">: exit&quot;</span> <span class="o">%</span> <span class="n">signame</span><span class="p">)</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">signame</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;SIGINT&#39;</span><span class="p">,</span> <span class="s1">&#39;SIGTERM&#39;</span><span class="p">}:</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">add_signal_handler</span><span class="p">(</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">signame</span><span class="p">),</span>
            <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">ask_exit</span><span class="p">,</span> <span class="n">signame</span><span class="p">,</span> <span class="n">loop</span><span class="p">))</span>

    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">3600</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Event loop running for 1 hour, press Ctrl+C to interrupt.&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;pid </span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">()</span><span class="si">}</span><span class="s2">: send SIGINT or SIGTERM to exit.&quot;</span><span class="p">)</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</pre></div>
</div>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Tabela de Conteúdo</a></h3>
  <ul>
<li><a class="reference internal" href="#">Laço de Eventos</a><ul>
<li><a class="reference internal" href="#event-loop-methods">Métodos do laço de eventos</a><ul>
<li><a class="reference internal" href="#running-and-stopping-the-loop">Executar e interromper o laço</a></li>
<li><a class="reference internal" href="#scheduling-callbacks">Agendando funções de retorno</a></li>
<li><a class="reference internal" href="#scheduling-delayed-callbacks">Agendando funções de retorno atrasadas</a></li>
<li><a class="reference internal" href="#creating-futures-and-tasks">Criando Futures e Tasks</a></li>
<li><a class="reference internal" href="#opening-network-connections">Abrindo conexões de rede</a></li>
<li><a class="reference internal" href="#creating-network-servers">Criando servidores de rede</a></li>
<li><a class="reference internal" href="#transferring-files">Transferindo arquivos</a></li>
<li><a class="reference internal" href="#tls-upgrade">Atualizando TLS</a></li>
<li><a class="reference internal" href="#watching-file-descriptors">Observando descritores de arquivo</a></li>
<li><a class="reference internal" href="#working-with-socket-objects-directly">Trabalhando com objetos soquete diretamente</a></li>
<li><a class="reference internal" href="#dns">DNS</a></li>
<li><a class="reference internal" href="#working-with-pipes">Trabalhando com encadeamentos</a></li>
<li><a class="reference internal" href="#unix-signals">Sinais Unix</a></li>
<li><a class="reference internal" href="#executing-code-in-thread-or-process-pools">Executando código em conjuntos de threads ou processos</a></li>
<li><a class="reference internal" href="#error-handling-api">Tratando erros da API</a></li>
<li><a class="reference internal" href="#enabling-debug-mode">Habilitando o modo de debug</a></li>
<li><a class="reference internal" href="#running-subprocesses">Executando Subprocessos</a></li>
</ul>
</li>
<li><a class="reference internal" href="#callback-handles">Tratadores de função de retorno</a></li>
<li><a class="reference internal" href="#server-objects">Objetos Server</a></li>
<li><a class="reference internal" href="#event-loop-implementations">Implementações do Laço de Eventos</a></li>
<li><a class="reference internal" href="#examples">Exemplos</a><ul>
<li><a class="reference internal" href="#hello-world-with-call-soon">Hello World com call_soon()</a></li>
<li><a class="reference internal" href="#display-the-current-date-with-call-later">Exibe a data atual com call_later()</a></li>
<li><a class="reference internal" href="#watch-a-file-descriptor-for-read-events">Observa um descritor de arquivo por eventos de leitura</a></li>
<li><a class="reference internal" href="#set-signal-handlers-for-sigint-and-sigterm">Define tratadores de sinais para SIGINT e SIGTERM</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Tópico anterior</h4>
  <p class="topless"><a href="asyncio-exceptions.html"
                        title="capítulo anterior">Exceções</a></p>
  <h4>Próximo tópico</h4>
  <p class="topless"><a href="asyncio-future.html"
                        title="próximo capítulo">Futuros</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Relatar um erro</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.10/Doc/library/asyncio-eventloop.rst"
            rel="nofollow">Exibir código-fonte
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegação</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice geral"
             >índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="asyncio-future.html" title="Futuros"
             >próximo</a> |</li>
        <li class="right" >
          <a href="asyncio-exceptions.html" title="Exceções"
             >anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.10.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >A Biblioteca Padrão do Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="ipc.html" >Comunicação em Rede e Interprocesso</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="asyncio.html" ><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code> — E/S assíncrona</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Laço de Eventos</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Busca rápida" aria-label="Busca rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Direitos autorais</a> 2001-2022, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    Última atualização em jun. 04, 2022.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.4.3.
    </div>

  </body>
</html>