
<!DOCTYPE html>

<html lang="pt_BR">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17: http://docutils.sourceforge.net/" />

    <title>decimal — Aritmética de ponto fixo decimal e ponto flutuante &#8212; documentação Python 3.10.4</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pydoctheme.css?2022.1" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Pesquisar dentro de documentação Python 3.10.4"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="Sobre esses documentos" href="../about.html" />
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Buscar" href="../search.html" />
    <link rel="copyright" title="Direitos autorais" href="../copyright.html" />
    <link rel="next" title="fractions — Rational numbers" href="fractions.html" />
    <link rel="prev" title="cmath — Funções matemáticas para números complexos" href="cmath.html" />
    <link rel="canonical" href="https://docs.python.org/3/library/decimal.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <label for="menuToggler" class="toggler__label">
        <span></span>
    </label>
    <nav class="nav-content" role="navigation">
         <a href="https://www.python.org/" class="nav-logo">
             <img src="../_static/py.svg" alt="Logo"/>
         </a>
        <div class="version_switcher_placeholder"></div>
        <form role="search" class="search" action="../search.html" method="get">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                <path fill-rule="nonzero"
                        d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="#444"></path>
            </svg>
            <input type="text" name="q" aria-label="Busca rápida"/>
            <input type="submit" value="Ir"/>
        </form>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
  <h3><a href="../contents.html">Tabela de Conteúdo</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">decimal</span></code> — Aritmética de ponto fixo decimal e ponto flutuante</a><ul>
<li><a class="reference internal" href="#quick-start-tutorial">Tutorial de início rápido</a></li>
<li><a class="reference internal" href="#decimal-objects">Objetos de Decimal</a><ul>
<li><a class="reference internal" href="#logical-operands">Operandos lógicos</a></li>
</ul>
</li>
<li><a class="reference internal" href="#context-objects">Objetos de contexto</a></li>
<li><a class="reference internal" href="#constants">Constantes</a></li>
<li><a class="reference internal" href="#rounding-modes">Modos de arredondamento</a></li>
<li><a class="reference internal" href="#signals">Sinais</a></li>
<li><a class="reference internal" href="#floating-point-notes">Observações sobre ponto flutuante</a><ul>
<li><a class="reference internal" href="#mitigating-round-off-error-with-increased-precision">Atenuando o erro de arredondamento com maior precisão</a></li>
<li><a class="reference internal" href="#special-values">Valores especiais</a></li>
</ul>
</li>
<li><a class="reference internal" href="#working-with-threads">Trabalhando com threads</a></li>
<li><a class="reference internal" href="#recipes">Receitas</a></li>
<li><a class="reference internal" href="#decimal-faq">Perguntas Frequentes sobre Decimal</a></li>
</ul>
</li>
</ul>

  <h4>Tópico anterior</h4>
  <p class="topless"><a href="cmath.html"
                        title="capítulo anterior"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cmath</span></code> — Funções matemáticas para números complexos</a></p>
  <h4>Próximo tópico</h4>
  <p class="topless"><a href="fractions.html"
                        title="próximo capítulo"><code class="xref py py-mod docutils literal notranslate"><span class="pre">fractions</span></code> — Rational numbers</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Relatar um erro</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.10/Doc/library/decimal.rst"
            rel="nofollow">Exibir código-fonte
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegação</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice geral"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="fractions.html" title="fractions — Rational numbers"
             accesskey="N">próximo</a> |</li>
        <li class="right" >
          <a href="cmath.html" title="cmath — Funções matemáticas para números complexos"
             accesskey="P">anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.10.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >A Biblioteca Padrão do Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="numeric.html" accesskey="U">Módulos Matemáticos e Numéricos</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">decimal</span></code> — Aritmética de ponto fixo decimal e ponto flutuante</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Busca rápida" aria-label="Busca rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="module-decimal">
<span id="decimal-decimal-fixed-point-and-floating-point-arithmetic"></span><h1><a class="reference internal" href="#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic  Specification."><code class="xref py py-mod docutils literal notranslate"><span class="pre">decimal</span></code></a> — Aritmética de ponto fixo decimal e ponto flutuante<a class="headerlink" href="#module-decimal" title="Link permanente para este título">¶</a></h1>
<p><strong>Código-fonte:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.10/Lib/decimal.py">Lib/decimal.py</a></p>
<hr class="docutils" />
<p>O módulo <a class="reference internal" href="#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic  Specification."><code class="xref py py-mod docutils literal notranslate"><span class="pre">decimal</span></code></a> fornece suporte a aritmética rápida de ponto flutuante decimal corretamente arredondado. Oferece várias vantagens sobre o tipo de dados <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>:</p>
<ul>
<li><p>Decimal “é baseado em um modelo de ponto flutuante que foi projetado com as pessoas em mente e necessariamente tem um princípio orientador primordial – os computadores devem fornecer uma aritmética que funcione da mesma maneira que a aritmética que as pessoas aprendem na escola”. – trecho da especificação aritmética decimal.</p></li>
<li><p>Os números decimais podem ser representados exatamente. Por outro lado, números como <code class="xref py py-const docutils literal notranslate"><span class="pre">1.1</span></code> e <code class="xref py py-const docutils literal notranslate"><span class="pre">2.2</span></code> não possuem representações exatas em ponto flutuante binário. Os usuários finais normalmente não esperam que <code class="docutils literal notranslate"><span class="pre">1.1</span> <span class="pre">+</span> <span class="pre">2.2</span></code> sejam exibidos como <code class="xref py py-const docutils literal notranslate"><span class="pre">3.3000000000000003</span></code>, como acontece com o ponto flutuante binário.</p></li>
<li><p>A exatidão transita para a aritmética. No ponto flutuante decimal, <code class="docutils literal notranslate"><span class="pre">0.1</span> <span class="pre">+</span> <span class="pre">0.1</span> <span class="pre">+</span> <span class="pre">0.1</span> <span class="pre">-</span> <span class="pre">0.3</span></code> é exatamente igual a zero. No ponto flutuante binário, o resultado é <code class="xref py py-const docutils literal notranslate"><span class="pre">5.5511151231257827e-017</span></code>. Embora próximas de zero, as diferenças impedem o teste de igualdade confiável e as diferenças podem se acumular. Por esse motivo, o decimal é preferido em aplicativos de contabilidade que possuem invariáveis estritos de igualdade.</p></li>
<li><p>O módulo decimal incorpora uma noção de casas significativas para que <code class="docutils literal notranslate"><span class="pre">1.30</span> <span class="pre">+</span> <span class="pre">1.20</span></code> seja <code class="xref py py-const docutils literal notranslate"><span class="pre">2.50</span></code>. O zero à direita é mantido para indicar significância. Esta é a apresentação habitual para aplicações monetárias. Para multiplicação, a abordagem “livro escolar” usa todas as figuras nos multiplicandos. Por exemplo, <code class="docutils literal notranslate"><span class="pre">1.3</span> <span class="pre">*</span> <span class="pre">1.2</span></code> é igual a <code class="xref py py-const docutils literal notranslate"><span class="pre">1.56</span></code> enquanto <code class="docutils literal notranslate"><span class="pre">1.30</span> <span class="pre">*</span> <span class="pre">1.20</span></code> é igual a <code class="xref py py-const docutils literal notranslate"><span class="pre">1.5600</span></code>.</p></li>
<li><p>Diferentemente do ponto flutuante binário baseado em hardware, o módulo decimal possui uma precisão alterável pelo usuário (padrão de 28 casas), que pode ser tão grande quanto necessário para um determinado problema:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">decimal</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.142857&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">28</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.1428571428571428571428571429&#39;)</span>
</pre></div>
</div>
</li>
<li><p>O ponto flutuante binário e decimal é implementado em termos de padrões publicados. Enquanto o tipo ponto flutuante embutido expõe apenas uma parte modesta de seus recursos, o módulo decimal expõe todas as partes necessárias do padrão. Quando necessário, o programador tem controle total sobre o arredondamento e o manuseio do sinal. Isso inclui uma opção para impor aritmética exata usando exceções para bloquear quaisquer operações inexatas.</p></li>
<li><p>O módulo decimal foi projetado para dar suporte, “sem prejuízo, a aritmética decimal não arredondada exata (às vezes chamada aritmética de ponto fixo) e aritmética arredondada de ponto flutuante”. – trecho da especificação aritmética decimal.</p></li>
</ul>
<p>O design do módulo é centrado em torno de três conceitos: o número decimal, o contexto da aritmética e os sinais.</p>
<p>Um número decimal é imutável. Possui um sinal, dígitos de coeficiente e um expoente. Para preservar a significância, os dígitos do coeficiente não truncam zeros à direita. Os decimais também incluem valores especiais, tais como <code class="xref py py-const docutils literal notranslate"><span class="pre">Infinity</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">-Infinity</span></code> e <code class="xref py py-const docutils literal notranslate"><span class="pre">NaN</span></code>. O padrão também diferencia <code class="xref py py-const docutils literal notranslate"><span class="pre">-0</span></code> de <code class="xref py py-const docutils literal notranslate"><span class="pre">+0</span></code>.</p>
<p>O contexto da aritmética é um ambiente que especifica precisão, regras de arredondamento, limites de expoentes, sinalizadores indicando os resultados das operações e ativadores de interceptação que determinam se os sinais são tratados como exceções. As opções de arredondamento incluem <a class="reference internal" href="#decimal.ROUND_CEILING" title="decimal.ROUND_CEILING"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_CEILING</span></code></a>, <a class="reference internal" href="#decimal.ROUND_DOWN" title="decimal.ROUND_DOWN"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_DOWN</span></code></a>, <a class="reference internal" href="#decimal.ROUND_FLOOR" title="decimal.ROUND_FLOOR"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_FLOOR</span></code></a>, <a class="reference internal" href="#decimal.ROUND_HALF_DOWN" title="decimal.ROUND_HALF_DOWN"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_HALF_DOWN</span></code></a>, <a class="reference internal" href="#decimal.ROUND_HALF_EVEN" title="decimal.ROUND_HALF_EVEN"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_HALF_EVEN</span></code></a>, <a class="reference internal" href="#decimal.ROUND_HALF_UP" title="decimal.ROUND_HALF_UP"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_HALF_UP</span></code></a>, <a class="reference internal" href="#decimal.ROUND_UP" title="decimal.ROUND_UP"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_UP</span></code></a> e <a class="reference internal" href="#decimal.ROUND_05UP" title="decimal.ROUND_05UP"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_05UP</span></code></a>.</p>
<p>Sinais são grupos de condições excepcionais que surgem durante o curso da computação. Dependendo das necessidades do aplicativo, os sinais podem ser ignorados, considerados informativos ou tratados como exceções. Os sinais no módulo decimal são: <a class="reference internal" href="#decimal.Clamped" title="decimal.Clamped"><code class="xref py py-const docutils literal notranslate"><span class="pre">Clamped</span></code></a>, <a class="reference internal" href="#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-const docutils literal notranslate"><span class="pre">InvalidOperation</span></code></a>, <a class="reference internal" href="#decimal.DivisionByZero" title="decimal.DivisionByZero"><code class="xref py py-const docutils literal notranslate"><span class="pre">DivisionByZero</span></code></a>, <a class="reference internal" href="#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-const docutils literal notranslate"><span class="pre">Inexact</span></code></a>, <a class="reference internal" href="#decimal.Rounded" title="decimal.Rounded"><code class="xref py py-const docutils literal notranslate"><span class="pre">Rounded</span></code></a>, <a class="reference internal" href="#decimal.Subnormal" title="decimal.Subnormal"><code class="xref py py-const docutils literal notranslate"><span class="pre">Subnormal</span></code></a>, <a class="reference internal" href="#decimal.Overflow" title="decimal.Overflow"><code class="xref py py-const docutils literal notranslate"><span class="pre">Overflow</span></code></a>, <a class="reference internal" href="#decimal.Underflow" title="decimal.Underflow"><code class="xref py py-const docutils literal notranslate"><span class="pre">Underflow</span></code></a> e <a class="reference internal" href="#decimal.FloatOperation" title="decimal.FloatOperation"><code class="xref py py-const docutils literal notranslate"><span class="pre">FloatOperation</span></code></a>.</p>
<p>Para cada sinal, há um sinalizador e um ativador de interceptação. Quando um sinal é encontrado, seu sinalizador é definido como um e, se o ativador de interceptação estiver definido como um, uma exceção será gerada. Os sinalizadores são fixos; portanto, o usuário precisa redefini-los antes de monitorar um cálculo.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver também</p>
<ul class="simple">
<li><p>A especificação geral aritmética decimal da IBM, <a class="reference external" href="http://speleotrove.com/decimal/decarith.html">The General Decimal Arithmetic Specification</a>.</p></li>
</ul>
</div>
<section id="quick-start-tutorial">
<span id="decimal-tutorial"></span><h2>Tutorial de início rápido<a class="headerlink" href="#quick-start-tutorial" title="Link permanente para este título">¶</a></h2>
<p>O início usual do uso de decimais é importar o módulo, exibir o contexto atual com <a class="reference internal" href="#decimal.getcontext" title="decimal.getcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">getcontext()</span></code></a> e, se necessário, definir novos valores para precisão, arredondamento ou armadilhas ativados:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">decimal</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span>
<span class="go">Context(prec=28, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999,</span>
<span class="go">        capitals=1, clamp=0, flags=[], traps=[Overflow, DivisionByZero,</span>
<span class="go">        InvalidOperation])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">7</span>       <span class="c1"># Set a new precision</span>
</pre></div>
</div>
<p>Instâncias decimais podem ser construídas a partir de números inteiros, strings, pontos flutuantes ou tuplas. A construção de um número inteiro ou de um ponto flutuante realiza uma conversão exata do valor desse número inteiro ou ponto flutuante. Os números decimais incluem valores especiais como <code class="xref py py-const docutils literal notranslate"><span class="pre">NaN</span></code>, que significa “Não é um número”, <code class="xref py py-const docutils literal notranslate"><span class="pre">Infinity</span></code> positivo e negativo e <code class="xref py py-const docutils literal notranslate"><span class="pre">-0</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">28</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">Decimal(&#39;10&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.14&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;3.14&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mf">3.14</span><span class="p">)</span>
<span class="go">Decimal(&#39;3.140000000000000124344978758017532527446746826171875&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="o">-</span><span class="mi">2</span><span class="p">))</span>
<span class="go">Decimal(&#39;3.14&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">))</span>
<span class="go">Decimal(&#39;1.4142135623730951&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;0.5&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;1.414213562373095048801688724&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;NaN&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;NaN&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;-Infinity&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;-Infinity&#39;)</span>
</pre></div>
</div>
<p>Se o sinal <a class="reference internal" href="#decimal.FloatOperation" title="decimal.FloatOperation"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FloatOperation</span></code></a> for capturado na armadilha, a mistura acidental de decimais e pontos flutuantes em construtores ou comparações de ordenação levanta uma exceção:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">getcontext</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">traps</span><span class="p">[</span><span class="n">FloatOperation</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mf">3.14</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">decimal.FloatOperation</span>: <span class="n">[&lt;class &#39;decimal.FloatOperation&#39;&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.5&#39;</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">3.7</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">decimal.FloatOperation</span>: <span class="n">[&lt;class &#39;decimal.FloatOperation&#39;&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.5&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="mf">3.5</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.3.</span></p>
</div>
<p>O significado de um novo decimal é determinado apenas pelo número de dígitos inseridos. A precisão e o arredondamento do contexto só entram em jogo durante operações aritméticas.</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.0&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;3.0&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.1415926535&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;3.1415926535&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.1415926535&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;2.7182818285&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;5.85987&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">rounding</span> <span class="o">=</span> <span class="n">ROUND_UP</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.1415926535&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;2.7182818285&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;5.85988&#39;)</span>
</pre></div>
</div>
<p>Se os limites internos da versão C forem excedidos, a construção de um decimal levanta <a class="reference internal" href="#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-class docutils literal notranslate"><span class="pre">InvalidOperation</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s2">&quot;1e9999999999999999999&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">decimal.InvalidOperation</span>: <span class="n">[&lt;class &#39;decimal.InvalidOperation&#39;&gt;]</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.3.</span></p>
</div>
<p>Os decimais interagem bem com grande parte do resto do Python. Aqui está um pequeno circo voador de ponto flutuante decimal:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">Decimal</span><span class="p">,</span> <span class="s1">&#39;1.34 1.87 3.45 2.35 1.00 0.03 9.25&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">max</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">Decimal(&#39;9.25&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">min</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.03&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">[Decimal(&#39;0.03&#39;), Decimal(&#39;1.00&#39;), Decimal(&#39;1.34&#39;), Decimal(&#39;1.87&#39;),</span>
<span class="go"> Decimal(&#39;2.35&#39;), Decimal(&#39;3.45&#39;), Decimal(&#39;9.25&#39;)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">Decimal(&#39;19.29&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">&#39;1.34&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">1.34</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">round</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">Decimal(&#39;1.3&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">*</span> <span class="mi">5</span>
<span class="go">Decimal(&#39;6.70&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">*</span> <span class="n">b</span>
<span class="go">Decimal(&#39;2.5058&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">%</span> <span class="n">a</span>
<span class="go">Decimal(&#39;0.77&#39;)</span>
</pre></div>
</div>
<p>E algumas funções matemáticas também estão disponíveis no Decimal:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">28</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sqrt</span><span class="p">()</span>
<span class="go">Decimal(&#39;1.414213562373095048801688724&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">exp</span><span class="p">()</span>
<span class="go">Decimal(&#39;2.718281828459045235360287471&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;10&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">ln</span><span class="p">()</span>
<span class="go">Decimal(&#39;2.302585092994045684017991455&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;10&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">log10</span><span class="p">()</span>
<span class="go">Decimal(&#39;1&#39;)</span>
</pre></div>
</div>
<p>O método <code class="xref py py-meth docutils literal notranslate"><span class="pre">quantize()</span></code> arredonda um número para um expoente fixo. Esse método é útil para aplicações monetárias que geralmente arredondam os resultados para um número fixo de locais:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;7.325&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;.01&#39;</span><span class="p">),</span> <span class="n">rounding</span><span class="o">=</span><span class="n">ROUND_DOWN</span><span class="p">)</span>
<span class="go">Decimal(&#39;7.32&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;7.325&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;1.&#39;</span><span class="p">),</span> <span class="n">rounding</span><span class="o">=</span><span class="n">ROUND_UP</span><span class="p">)</span>
<span class="go">Decimal(&#39;8&#39;)</span>
</pre></div>
</div>
<p>Como mostrado acima, a função <a class="reference internal" href="#decimal.getcontext" title="decimal.getcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">getcontext()</span></code></a> acessa o contexto atual e permite que as configurações sejam alteradas. Essa abordagem atende às necessidades da maioria das aplicações.</p>
<p>Para trabalhos mais avançados, pode ser útil criar contextos alternativos usando o construtor Context(). Para ativar uma alternativa, use a função <a class="reference internal" href="#decimal.setcontext" title="decimal.setcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">setcontext()</span></code></a>.</p>
<p>De acordo com o padrão, o módulo <a class="reference internal" href="#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic  Specification."><code class="xref py py-mod docutils literal notranslate"><span class="pre">decimal</span></code></a> fornece dois contextos padrão prontos para uso, <a class="reference internal" href="#decimal.BasicContext" title="decimal.BasicContext"><code class="xref py py-const docutils literal notranslate"><span class="pre">BasicContext</span></code></a> e <a class="reference internal" href="#decimal.ExtendedContext" title="decimal.ExtendedContext"><code class="xref py py-const docutils literal notranslate"><span class="pre">ExtendedContext</span></code></a>. O primeiro é especialmente útil para depuração porque muitas das armadilhas estão ativadas:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">myothercontext</span> <span class="o">=</span> <span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">rounding</span><span class="o">=</span><span class="n">ROUND_HALF_DOWN</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">setcontext</span><span class="p">(</span><span class="n">myothercontext</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.142857142857142857142857142857142857142857142857142857142857&#39;)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">ExtendedContext</span>
<span class="go">Context(prec=9, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999,</span>
<span class="go">        capitals=1, clamp=0, flags=[], traps=[])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">setcontext</span><span class="p">(</span><span class="n">ExtendedContext</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.142857143&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">Decimal(&#39;Infinity&#39;)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">setcontext</span><span class="p">(</span><span class="n">BasicContext</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;pyshell#143&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">-toplevel-</span>
    <span class="n">Decimal</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gr">DivisionByZero</span>: <span class="n">x / 0</span>
</pre></div>
</div>
<p>Os contextos também possuem sinalizadores para monitorar condições excepcionais encontradas durante os cálculos. Os sinalizadores permanecem definidos até que sejam explicitamente limpos, portanto, é melhor limpar os sinalizadores antes de cada conjunto de cálculos monitorados usando o método <code class="xref py py-meth docutils literal notranslate"><span class="pre">clear_flags()</span></code>.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">setcontext</span><span class="p">(</span><span class="n">ExtendedContext</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">clear_flags</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">355</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">113</span><span class="p">)</span>
<span class="go">Decimal(&#39;3.14159292&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span>
<span class="go">Context(prec=9, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999,</span>
<span class="go">        capitals=1, clamp=0, flags=[Inexact, Rounded], traps=[])</span>
</pre></div>
</div>
<p>A entrada <em>flags</em> mostra que a aproximação racional de <code class="xref py py-const docutils literal notranslate"><span class="pre">Pi</span></code> foi arredondada (dígitos além da precisão do contexto foram descartados) e que o resultado é inexato (alguns dos dígitos descartados eram diferentes de zero).</p>
<p>As armadilhas individuais são definidas usando o dicionário no campo <code class="xref py py-attr docutils literal notranslate"><span class="pre">traps</span></code> de um contexto:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">setcontext</span><span class="p">(</span><span class="n">ExtendedContext</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">Decimal(&#39;Infinity&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">traps</span><span class="p">[</span><span class="n">DivisionByZero</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;pyshell#112&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">-toplevel-</span>
    <span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gr">DivisionByZero</span>: <span class="n">x / 0</span>
</pre></div>
</div>
<p>A maioria dos programas ajusta o contexto atual apenas uma vez, no início do programa. E, em muitas aplicações, os dados são convertidos para <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> com uma única conversão dentro de um loop. Com o conjunto de contextos e decimais criados, a maior parte do programa manipula os dados de maneira diferente do que com outros tipos numéricos do Python.</p>
</section>
<section id="decimal-objects">
<span id="decimal-decimal"></span><h2>Objetos de Decimal<a class="headerlink" href="#decimal-objects" title="Link permanente para este título">¶</a></h2>
<dl class="py class">
<dt id="decimal.Decimal">
<em class="property">class </em><code class="sig-prename descclassname">decimal.</code><code class="sig-name descname">Decimal</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">value</span><span class="o">=</span><span class="default_value">'0'</span></em>, <em class="sig-param"><span class="n">context</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Constrói um novo objeto de <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> com base em <em>value</em>.</p>
<p><em>value</em> pode ser um inteiro, string, tupla, <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> ou outro objeto de <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a>. Se nenhum <em>value</em> for fornecido, retornará <code class="docutils literal notranslate"><span class="pre">Decimal('0')</span></code>. Se <em>value</em> for uma string, ele deverá estar em conformidade com a sintaxe da string numérica decimal após caracteres de espaço em branco à esquerda e à direita, bem como sublinhados em toda parte, serem removidos:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">sign</span>           <span class="p">:</span><span class="o">:=</span>  <span class="s1">&#39;+&#39;</span> <span class="o">|</span> <span class="s1">&#39;-&#39;</span>
<span class="n">digit</span>          <span class="p">:</span><span class="o">:=</span>  <span class="s1">&#39;0&#39;</span> <span class="o">|</span> <span class="s1">&#39;1&#39;</span> <span class="o">|</span> <span class="s1">&#39;2&#39;</span> <span class="o">|</span> <span class="s1">&#39;3&#39;</span> <span class="o">|</span> <span class="s1">&#39;4&#39;</span> <span class="o">|</span> <span class="s1">&#39;5&#39;</span> <span class="o">|</span> <span class="s1">&#39;6&#39;</span> <span class="o">|</span> <span class="s1">&#39;7&#39;</span> <span class="o">|</span> <span class="s1">&#39;8&#39;</span> <span class="o">|</span> <span class="s1">&#39;9&#39;</span>
<span class="n">indicator</span>      <span class="p">:</span><span class="o">:=</span>  <span class="s1">&#39;e&#39;</span> <span class="o">|</span> <span class="s1">&#39;E&#39;</span>
<span class="n">digits</span>         <span class="p">:</span><span class="o">:=</span>  <span class="n">digit</span> <span class="p">[</span><span class="n">digit</span><span class="p">]</span><span class="o">...</span>
<span class="n">decimal</span><span class="o">-</span><span class="n">part</span>   <span class="p">:</span><span class="o">:=</span>  <span class="n">digits</span> <span class="s1">&#39;.&#39;</span> <span class="p">[</span><span class="n">digits</span><span class="p">]</span> <span class="o">|</span> <span class="p">[</span><span class="s1">&#39;.&#39;</span><span class="p">]</span> <span class="n">digits</span>
<span class="n">exponent</span><span class="o">-</span><span class="n">part</span>  <span class="p">:</span><span class="o">:=</span>  <span class="n">indicator</span> <span class="p">[</span><span class="n">sign</span><span class="p">]</span> <span class="n">digits</span>
<span class="n">infinity</span>       <span class="p">:</span><span class="o">:=</span>  <span class="s1">&#39;Infinity&#39;</span> <span class="o">|</span> <span class="s1">&#39;Inf&#39;</span>
<span class="n">nan</span>            <span class="p">:</span><span class="o">:=</span>  <span class="s1">&#39;NaN&#39;</span> <span class="p">[</span><span class="n">digits</span><span class="p">]</span> <span class="o">|</span> <span class="s1">&#39;sNaN&#39;</span> <span class="p">[</span><span class="n">digits</span><span class="p">]</span>
<span class="n">numeric</span><span class="o">-</span><span class="n">value</span>  <span class="p">:</span><span class="o">:=</span>  <span class="n">decimal</span><span class="o">-</span><span class="n">part</span> <span class="p">[</span><span class="n">exponent</span><span class="o">-</span><span class="n">part</span><span class="p">]</span> <span class="o">|</span> <span class="n">infinity</span>
<span class="n">numeric</span><span class="o">-</span><span class="n">string</span> <span class="p">:</span><span class="o">:=</span>  <span class="p">[</span><span class="n">sign</span><span class="p">]</span> <span class="n">numeric</span><span class="o">-</span><span class="n">value</span> <span class="o">|</span> <span class="p">[</span><span class="n">sign</span><span class="p">]</span> <span class="n">nan</span>
</pre></div>
</div>
<p>Outros dígitos decimais Unicode também são permitidos onde <code class="docutils literal notranslate"><span class="pre">digit</span></code> aparece acima. Isso inclui dígitos decimais de vários outros alfabetos (por exemplo, dígitos em árabes-índicos e devanágaris), além dos dígitos de largura total <code class="docutils literal notranslate"><span class="pre">'\uff10'</span></code> a <code class="docutils literal notranslate"><span class="pre">'\uff19'</span></code>.</p>
<p>Se <em>value</em> for um <a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>, ele deverá ter três componentes, um sinal (<code class="xref py py-const docutils literal notranslate"><span class="pre">0</span></code> para positivo ou <code class="xref py py-const docutils literal notranslate"><span class="pre">1</span></code> para negativo), um <a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> de dígitos e um expoente inteiro. Por exemplo, <code class="docutils literal notranslate"><span class="pre">Decimal((0,</span> <span class="pre">(1,</span> <span class="pre">4,</span> <span class="pre">1,</span> <span class="pre">4),</span> <span class="pre">-3))</span></code> returna <code class="docutils literal notranslate"><span class="pre">Decimal('1.414')</span></code>.</p>
<p>Se <em>value</em> é um <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>, o valor do ponto flutuante binário é convertido sem perdas no seu equivalente decimal exato. Essa conversão geralmente requer 53 ou mais dígitos de precisão. Por exemplo, <code class="docutils literal notranslate"><span class="pre">Decimal(float('1.1'))</span></code> converte para <code class="docutils literal notranslate"><span class="pre">Decimal('1.100000000000000088817841970012523233890533447265625')</span></code>.</p>
<p>A precisão <em>context</em> não afeta quantos dígitos estão armazenados. Isso é determinado exclusivamente pelo número de dígitos em <em>value</em>. Por exemplo, <code class="docutils literal notranslate"><span class="pre">Decimal('3.00000')</span></code> registra todos os cinco zeros, mesmo que a precisão do contexto seja apenas três.</p>
<p>O objetivo do argumento <em>context</em> é determinar o que fazer se <em>value</em> for uma string malformada. Se o contexto capturar <a class="reference internal" href="#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-const docutils literal notranslate"><span class="pre">InvalidOperation</span></code></a>, uma exceção será levantada; caso contrário, o construtor retornará um novo decimal com o valor de <code class="xref py py-const docutils literal notranslate"><span class="pre">NaN</span></code>.</p>
<p>Uma vez construídos, objetos de <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> são imutáveis.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.2: </span>O argumento para o construtor agora pode ser uma instância de <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.3: </span>Os argumentos de <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> levantam uma exceção se a armadilha <a class="reference internal" href="#decimal.FloatOperation" title="decimal.FloatOperation"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FloatOperation</span></code></a> estiver definida. Por padrão, a armadilha está desativada.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.6: </span>Sublinhados são permitidos para agrupamento, como nos literais de ponto flutuante e integral no código.</p>
</div>
<p>Objetos decimais de ponto flutuante compartilham muitas propriedades com outros tipos numéricos embutidos, como <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> e <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>. Todas as operações matemáticas usuais e métodos especiais se aplicam. Da mesma forma, objetos decimais podem ser copiados, separados, impressos, usados como chaves de dicionário, usados como elementos de conjunto, comparados, classificados e coagidos a outro tipo (como <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> ou <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>).</p>
<p>Existem algumas pequenas diferenças entre aritmética em objetos decimais e aritmética em números inteiros e flutuantes. Quando o operador de resto <code class="docutils literal notranslate"><span class="pre">%</span></code> é aplicado a objetos decimais, o sinal do resultado é o sinal do <em>dividend</em> em vez do sinal do divisor:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="o">-</span><span class="mi">7</span><span class="p">)</span> <span class="o">%</span> <span class="mi">4</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="o">-</span><span class="mi">7</span><span class="p">)</span> <span class="o">%</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">Decimal(&#39;-3&#39;)</span>
</pre></div>
</div>
<p>O operador de divisão inteira <code class="docutils literal notranslate"><span class="pre">//</span></code> se comporta de maneira análoga, retornando a parte inteira do quociente verdadeiro (truncando em direção a zero) em vez de seu resto, de modo a preservar a identidade usual <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">(x</span> <span class="pre">//</span> <span class="pre">y)</span> <span class="pre">*</span> <span class="pre">y</span> <span class="pre">+</span> <span class="pre">x</span> <span class="pre">%</span> <span class="pre">y</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="o">-</span><span class="mi">7</span> <span class="o">//</span> <span class="mi">4</span>
<span class="go">-2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="o">-</span><span class="mi">7</span><span class="p">)</span> <span class="o">//</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">Decimal(&#39;-1&#39;)</span>
</pre></div>
</div>
<p>Os operadores <code class="docutils literal notranslate"><span class="pre">%</span></code> e <code class="docutils literal notranslate"><span class="pre">//</span></code> implementam as operações de <code class="docutils literal notranslate"><span class="pre">módulo</span></code> e <code class="docutils literal notranslate"><span class="pre">divisão</span> <span class="pre">inteira</span></code> (respectivamente) como descrito na especificação.</p>
<p>Objetos decimais geralmente não podem ser combinados com pontos flutuantes ou instâncias de <a class="reference internal" href="fractions.html#fractions.Fraction" title="fractions.Fraction"><code class="xref py py-class docutils literal notranslate"><span class="pre">fractions.Fraction</span></code></a> em operações aritméticas: uma tentativa de adicionar um <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> a um <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>, por exemplo, vai levantar um <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>. No entanto, é possível usar os operadores de comparação do Python para comparar uma instância de <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> <code class="docutils literal notranslate"><span class="pre">x</span></code> com outro número <code class="docutils literal notranslate"><span class="pre">y</span></code>. Isso evita resultados confusos ao fazer comparações de igualdade entre números de tipos diferentes.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.2: </span>As comparações de tipos mistos entre instâncias de <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> e outros tipos numéricos agora são totalmente suportadas.</p>
</div>
<p>Além das propriedades numéricas padrão, os objetos de ponto flutuante decimal também possuem vários métodos especializados:</p>
<dl class="py method">
<dt id="decimal.Decimal.adjusted">
<code class="sig-name descname">adjusted</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.adjusted" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna o expoente ajustado depois de deslocar os dígitos mais à direita do coeficiente até restar apenas o dígito principal: <code class="docutils literal notranslate"><span class="pre">Decimal('321e+5').adjusted()</span></code> retorna sete. Usado para determinar a posição do dígito mais significativo em relação ao ponto decimal.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Decimal.as_integer_ratio">
<code class="sig-name descname">as_integer_ratio</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.as_integer_ratio" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna um par <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">d)</span></code> de números inteiros que representam a instância dada <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> como uma fração, nos termos mais baixos e com um denominador positivo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;-3.14&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">as_integer_ratio</span><span class="p">()</span>
<span class="go">(-157, 50)</span>
</pre></div>
</div>
<p>A conversão é exata. Levanta OverflowError em infinitos e ValueError em NaNs.</p>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.6.</span></p>
</div>
<dl class="py method">
<dt id="decimal.Decimal.as_tuple">
<code class="sig-name descname">as_tuple</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.as_tuple" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna uma representação de <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">tupla nomeada</span></a> do número: <code class="docutils literal notranslate"><span class="pre">DecimalTuple(sign,</span> <span class="pre">digits,</span> <span class="pre">exponent)</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Decimal.canonical">
<code class="sig-name descname">canonical</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.canonical" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna a codificação canônica do argumento. Atualmente, a codificação de uma instância de <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> é sempre canônica, portanto, esta operação retorna seu argumento inalterado.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Decimal.compare">
<code class="sig-name descname">compare</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">context</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.compare" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Compara os valores de duas instâncias decimais. <a class="reference internal" href="#decimal.Decimal.compare" title="decimal.Decimal.compare"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compare()</span></code></a> retorna uma instância decimal, e se qualquer operando for um NaN, o resultado será um NaN:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="ow">or</span> <span class="n">b</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">NaN</span>  <span class="o">==&gt;</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;NaN&#39;</span><span class="p">)</span>
<span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span>            <span class="o">==&gt;</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;-1&#39;</span><span class="p">)</span>
<span class="n">a</span> <span class="o">==</span> <span class="n">b</span>           <span class="o">==&gt;</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">)</span>
<span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span>            <span class="o">==&gt;</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="decimal.Decimal.compare_signal">
<code class="sig-name descname">compare_signal</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">context</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.compare_signal" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Esta operação é idêntica ao método <a class="reference internal" href="#decimal.Decimal.compare" title="decimal.Decimal.compare"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compare()</span></code></a>, exceto que todos os NaNs sinalizam. Ou seja, se nenhum operando for um NaN sinalizador, qualquer operando NaN silencioso será tratado como se fosse um NaN sinalizador.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Decimal.compare_total">
<code class="sig-name descname">compare_total</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">context</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.compare_total" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Compara dois operandos usando sua representação abstrata em vez de seu valor numérico. Semelhante ao método <a class="reference internal" href="#decimal.Decimal.compare" title="decimal.Decimal.compare"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compare()</span></code></a>, mas o resultado fornece uma ordem total nas instâncias de <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a>. Duas instâncias de <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> com o mesmo valor numérico, mas diferentes representações, se comparam desiguais nesta ordem:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;12.0&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">compare_total</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;12&#39;</span><span class="p">))</span>
<span class="go">Decimal(&#39;-1&#39;)</span>
</pre></div>
</div>
<p>Os NaNs silenciosos e sinalizadores também estão incluídos no pedido total. O resultado dessa função é <code class="docutils literal notranslate"><span class="pre">Decimal('0')</span></code> se os dois operandos tiverem a mesma representação, <code class="docutils literal notranslate"><span class="pre">Decimal('-1')</span></code> se o primeiro operando for menor na ordem total que o segundo e <code class="docutils literal notranslate"><span class="pre">Decimal('1')</span></code> se o primeiro operando for maior na ordem total que o segundo operando. Veja a especificação para detalhes da ordem total.</p>
<p>Esta operação não é afetada pelo contexto e é silenciosa: nenhum sinalizador é alterado e nenhum arredondamento é executado. Como uma exceção, a versão C pode levantar InvalidOperation se o segundo operando não puder ser convertido exatamente.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Decimal.compare_total_mag">
<code class="sig-name descname">compare_total_mag</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">context</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.compare_total_mag" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Compara dois operandos usando sua representação abstrata em vez de seu valor, como em <a class="reference internal" href="#decimal.Decimal.compare_total" title="decimal.Decimal.compare_total"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compare_total()</span></code></a>, mas ignorando o sinal de cada operando. <code class="docutils literal notranslate"><span class="pre">x.compare_total_mag(y)</span></code> é equivalente a <code class="docutils literal notranslate"><span class="pre">x.copy_abs().compare_total(y.copy_abs())</span></code>.</p>
<p>Esta operação não é afetada pelo contexto e é silenciosa: nenhum sinalizador é alterado e nenhum arredondamento é executado. Como uma exceção, a versão C pode levantar InvalidOperation se o segundo operando não puder ser convertido exatamente.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Decimal.conjugate">
<code class="sig-name descname">conjugate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.conjugate" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Apenas retorna a si próprio, sendo esse método apenas para atender à Especificação de Decimal.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Decimal.copy_abs">
<code class="sig-name descname">copy_abs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.copy_abs" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna o valor absoluto do argumento. Esta operação não é afetada pelo contexto e é silenciosa: nenhum sinalizador é alterado e nenhum arredondamento é executado.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Decimal.copy_negate">
<code class="sig-name descname">copy_negate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.copy_negate" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna a negação do argumento. Esta operação não é afetada pelo contexto e é silenciosa: nenhum sinalizador é alterado e nenhum arredondamento é executado.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Decimal.copy_sign">
<code class="sig-name descname">copy_sign</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">context</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.copy_sign" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna uma cópia do primeiro operando com o sinal definido para ser o mesmo que o sinal do segundo operando. Por exemplo:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;2.3&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">copy_sign</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;-1.5&#39;</span><span class="p">))</span>
<span class="go">Decimal(&#39;-2.3&#39;)</span>
</pre></div>
</div>
<p>Esta operação não é afetada pelo contexto e é silenciosa: nenhum sinalizador é alterado e nenhum arredondamento é executado. Como uma exceção, a versão C pode levantar InvalidOperation se o segundo operando não puder ser convertido exatamente.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Decimal.exp">
<code class="sig-name descname">exp</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">context</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.exp" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna o valor da função exponencial (natural) <code class="docutils literal notranslate"><span class="pre">e**x</span></code> no número especificado. O resultado é arredondado corretamente usando o modo de arredondamento <a class="reference internal" href="#decimal.ROUND_HALF_EVEN" title="decimal.ROUND_HALF_EVEN"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_HALF_EVEN</span></code></a>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">exp</span><span class="p">()</span>
<span class="go">Decimal(&#39;2.718281828459045235360287471&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">321</span><span class="p">)</span><span class="o">.</span><span class="n">exp</span><span class="p">()</span>
<span class="go">Decimal(&#39;2.561702493119680037517373933E+139&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="decimal.Decimal.from_float">
<em class="property">classmethod </em><code class="sig-name descname">from_float</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">f</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.from_float" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Alternative constructor that only accepts instances of <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> or
<a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>.</p>
<p>Observe que <cite>Decimal.from_float(0.1)</cite> não é o mesmo que <cite>Decimal(‘0.1’)</cite>. Como 0.1 não é exatamente representável no ponto flutuante binário, o valor é armazenado como o valor representável mais próximo que é <cite>0x1.999999999999ap-4</cite>. Esse valor equivalente em decimal é <cite>0.1000000000000000055511151231257827021181583404541015625</cite>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>A partir do Python 3.2 em diante, uma instância de <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> também pode ser construída diretamente a partir de um <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>.</p>
</div>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="o">.</span><span class="n">from_float</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.1000000000000000055511151231257827021181583404541015625&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="o">.</span><span class="n">from_float</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">))</span>
<span class="go">Decimal(&#39;NaN&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="o">.</span><span class="n">from_float</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">))</span>
<span class="go">Decimal(&#39;Infinity&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="o">.</span><span class="n">from_float</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;-inf&#39;</span><span class="p">))</span>
<span class="go">Decimal(&#39;-Infinity&#39;)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.1.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="decimal.Decimal.fma">
<code class="sig-name descname">fma</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">third</span></em>, <em class="sig-param"><span class="n">context</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.fma" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Multiplicação e adição fundidos. Retorna self*other+third sem arredondamento do produto intermediário self*other.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">fma</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">Decimal(&#39;11&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="decimal.Decimal.is_canonical">
<code class="sig-name descname">is_canonical</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_canonical" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> se o argumento for canônico e <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> caso contrário. Atualmente, uma instância de <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> é sempre canônica, portanto, esta operação sempre retorna <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Decimal.is_finite">
<code class="sig-name descname">is_finite</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_finite" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> se o argumento for um número finito e <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> se o argumento for um infinito ou um NaN.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Decimal.is_infinite">
<code class="sig-name descname">is_infinite</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_infinite" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> se o argumento for infinito positivo ou negativo e <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> caso contrário.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Decimal.is_nan">
<code class="sig-name descname">is_nan</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_nan" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> se o argumento for NaN (silencioso ou sinalizador) e <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> caso contrário.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Decimal.is_normal">
<code class="sig-name descname">is_normal</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">context</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_normal" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> se o argumento for um número finito <em>normal</em>. Retorna <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> se o argumento for zero, subnormal, infinito ou NaN.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Decimal.is_qnan">
<code class="sig-name descname">is_qnan</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_qnan" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> se o argumento for um NaN silencioso, e <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> caso contrário.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Decimal.is_signed">
<code class="sig-name descname">is_signed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_signed" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> se o argumento tiver um sinal negativo e <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> caso contrário. Observe que zeros e NaNs podem carregar sinais.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Decimal.is_snan">
<code class="sig-name descname">is_snan</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_snan" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> se o argumento for um sinal NaN e <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> caso contrário.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Decimal.is_subnormal">
<code class="sig-name descname">is_subnormal</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">context</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_subnormal" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> se o argumento for subnormal e <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> caso contrário.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Decimal.is_zero">
<code class="sig-name descname">is_zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_zero" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> se o argumento for um zero (positivo ou negativo) e <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> caso contrário.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Decimal.ln">
<code class="sig-name descname">ln</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">context</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.ln" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna o logaritmo (base e) natural do operando. O resultado é arredondado corretamente usando o modo de arredondamento <a class="reference internal" href="#decimal.ROUND_HALF_EVEN" title="decimal.ROUND_HALF_EVEN"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_HALF_EVEN</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Decimal.log10">
<code class="sig-name descname">log10</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">context</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.log10" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna o logaritmo da base dez do operando. O resultado é arredondado corretamente usando o modo de arredondamento <a class="reference internal" href="#decimal.ROUND_HALF_EVEN" title="decimal.ROUND_HALF_EVEN"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_HALF_EVEN</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Decimal.logb">
<code class="sig-name descname">logb</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">context</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.logb" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Para um número diferente de zero, retorna o expoente ajustado de seu operando como uma instância de <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a>. Se o operando é zero, <code class="docutils literal notranslate"><span class="pre">Decimal('-Infinity')</span></code> é retornado e o sinalizador <a class="reference internal" href="#decimal.DivisionByZero" title="decimal.DivisionByZero"><code class="xref py py-const docutils literal notranslate"><span class="pre">DivisionByZero</span></code></a> é levantado. Se o operando for um infinito, <code class="docutils literal notranslate"><span class="pre">Decimal('Infinity')</span></code> será retornado.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Decimal.logical_and">
<code class="sig-name descname">logical_and</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">context</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.logical_and" title="Link permanente para esta definição">¶</a></dt>
<dd><p><a class="reference internal" href="#decimal.Decimal.logical_and" title="decimal.Decimal.logical_and"><code class="xref py py-meth docutils literal notranslate"><span class="pre">logical_and()</span></code></a> é uma operação lógica que leva dois <em>operandos lógicos</em> (consulte <a class="reference internal" href="#logical-operands-label"><span class="std std-ref">Operandos lógicos</span></a>). O resultado é o <code class="docutils literal notranslate"><span class="pre">and</span></code> dígito a dígito dos dois operandos.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Decimal.logical_invert">
<code class="sig-name descname">logical_invert</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">context</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.logical_invert" title="Link permanente para esta definição">¶</a></dt>
<dd><p><a class="reference internal" href="#decimal.Decimal.logical_invert" title="decimal.Decimal.logical_invert"><code class="xref py py-meth docutils literal notranslate"><span class="pre">logical_invert()</span></code></a> é uma operação lógica. O resultado é a inversão dígito a dígito do operando.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Decimal.logical_or">
<code class="sig-name descname">logical_or</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">context</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.logical_or" title="Link permanente para esta definição">¶</a></dt>
<dd><p><a class="reference internal" href="#decimal.Decimal.logical_or" title="decimal.Decimal.logical_or"><code class="xref py py-meth docutils literal notranslate"><span class="pre">logical_or()</span></code></a> é uma operação lógica que leva dois <em>operandos lógicos</em> (consulte <a class="reference internal" href="#logical-operands-label"><span class="std std-ref">Operandos lógicos</span></a>). O resultado é o <code class="docutils literal notranslate"><span class="pre">or</span></code> dígito a dígito dos dois operandos.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Decimal.logical_xor">
<code class="sig-name descname">logical_xor</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">context</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.logical_xor" title="Link permanente para esta definição">¶</a></dt>
<dd><p><a class="reference internal" href="#decimal.Decimal.logical_xor" title="decimal.Decimal.logical_xor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">logical_xor()</span></code></a> é uma operação lógica que leva dois <em>operandos lógicos</em> (consulte <a class="reference internal" href="#logical-operands-label"><span class="std std-ref">Operandos lógicos</span></a>). O resultado é o “ou exclusivo” dígito a dígito ou dos dois operandos.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Decimal.max">
<code class="sig-name descname">max</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">context</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.max" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Como <code class="docutils literal notranslate"><span class="pre">max(self,</span> <span class="pre">other)</span></code>, exceto que a regra de arredondamento de contexto é aplicada antes de retornar e que os valores <code class="xref py py-const docutils literal notranslate"><span class="pre">NaN</span></code> são sinalizados ou ignorados (dependendo do contexto e se estão sinalizando ou silenciosos).</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Decimal.max_mag">
<code class="sig-name descname">max_mag</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">context</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.max_mag" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Semelhante ao método <a class="reference internal" href="#decimal.Decimal.max" title="decimal.Decimal.max"><code class="xref py py-meth docutils literal notranslate"><span class="pre">max()</span></code></a>, mas a comparação é feita usando os valores absolutos dos operandos.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Decimal.min">
<code class="sig-name descname">min</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">context</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.min" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Como <code class="docutils literal notranslate"><span class="pre">min(self,</span> <span class="pre">other)</span></code>, exceto que a regra de arredondamento de contexto é aplicada antes de retornar e que os valores <code class="xref py py-const docutils literal notranslate"><span class="pre">NaN</span></code> são sinalizados ou ignorados (dependendo do contexto e se estão sinalizando ou silenciosos).</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Decimal.min_mag">
<code class="sig-name descname">min_mag</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">context</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.min_mag" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Semelhante ao método <a class="reference internal" href="#decimal.Decimal.min" title="decimal.Decimal.min"><code class="xref py py-meth docutils literal notranslate"><span class="pre">min()</span></code></a>, mas a comparação é feita usando os valores absolutos dos operandos.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Decimal.next_minus">
<code class="sig-name descname">next_minus</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">context</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.next_minus" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna o maior número representável no contexto fornecido (ou no contexto atual da thread, se nenhum contexto for fornecido) que seja menor que o operando especificado.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Decimal.next_plus">
<code class="sig-name descname">next_plus</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">context</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.next_plus" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna o menor número representável no contexto fornecido (ou no contexto atual da thread, se nenhum contexto for fornecido) que seja maior que o operando fornecido.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Decimal.next_toward">
<code class="sig-name descname">next_toward</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">context</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.next_toward" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Se os dois operandos forem desiguais, retorna o número mais próximo ao primeiro operando na direção do segundo operando. Se os dois operandos forem numericamente iguais, retorna uma cópia do primeiro operando com o sinal configurado para ser o mesmo que o sinal do segundo operando.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Decimal.normalize">
<code class="sig-name descname">normalize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">context</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.normalize" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Normaliza o número eliminando os zeros à direita e convertendo qualquer resultado igual a <code class="xref py py-const docutils literal notranslate"><span class="pre">Decimal('0')</span></code> para <code class="xref py py-const docutils literal notranslate"><span class="pre">Decimal('0e0')</span></code>. Usado para produzir valores canônicos para atributos de uma classe de equivalência. Por exemplo, <code class="docutils literal notranslate"><span class="pre">Decimal('32.100')</span></code> e <code class="docutils literal notranslate"><span class="pre">Decimal('0.321000e+2')</span></code> normalizam com o valor equivalente <code class="docutils literal notranslate"><span class="pre">Decimal('32.1')</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Decimal.number_class">
<code class="sig-name descname">number_class</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">context</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.number_class" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna uma string descrevendo a <em>classe</em> do operando. O valor retornado é uma das dez sequências a seguir.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;-Infinity&quot;</span></code>, indicando que o operando é infinito negativo.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;-Normal&quot;</span></code>, indicando que o operando é um número normal negativo.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;-Subnormal&quot;</span></code>, indicando que o operando é negativo e subnormal.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;-Zero&quot;</span></code>, indicando que o operando é um zero negativo.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;+Zero&quot;</span></code>, indicando que o operando é um zero positivo.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;+Subnormal&quot;</span></code>, indicando que o operando é positivo e subnormal.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;+Normal&quot;</span></code>, indicando que o operando é um número normal positivo.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;+Infinity&quot;</span></code>, indicando que o operando é infinito positivo.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;NaN&quot;</span></code>, indicando que o operando é um NaN (“Not a Number”) silencioso.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;sNaN&quot;</span></code>, indicando que o operando é um NaN sinalizador.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt id="decimal.Decimal.quantize">
<code class="sig-name descname">quantize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">exp</span></em>, <em class="sig-param"><span class="n">rounding</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">context</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.quantize" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna um valor igual ao primeiro operando após o arredondamento e com o expoente do segundo operando.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;1.41421356&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;1.000&#39;</span><span class="p">))</span>
<span class="go">Decimal(&#39;1.414&#39;)</span>
</pre></div>
</div>
<p>Diferentemente de outras operações, se o comprimento do coeficiente após a operação de quantização for maior que a precisão, então <a class="reference internal" href="#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-const docutils literal notranslate"><span class="pre">InvalidOperation</span></code></a> é sinalizado. Isso garante que, a menos que haja uma condição de erro, o expoente quantizado é sempre igual ao do operando do lado direito.</p>
<p>Também, diferentemente de outras operações, a quantização nunca sinaliza Underflow, mesmo que o resultado seja subnormal e inexato.</p>
<p>Se o expoente do segundo operando for maior que o do primeiro, o arredondamento poderá ser necessário. Nesse caso, o modo de arredondamento é determinado pelo argumento <code class="docutils literal notranslate"><span class="pre">rounding</span></code>, se fornecido, ou pelo argumento <code class="docutils literal notranslate"><span class="pre">context</span></code> fornecido; se nenhum argumento for fornecido, o modo de arredondamento do contexto da thread atual será usado.</p>
<p>Um erro é retornado sempre que o expoente resultante for maior que <code class="xref py py-attr docutils literal notranslate"><span class="pre">Emax</span></code> ou menor que <code class="xref py py-attr docutils literal notranslate"><span class="pre">Etiny</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Decimal.radix">
<code class="sig-name descname">radix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.radix" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">Decimal(10)</span></code>, a raiz (base) na qual a classe <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> faz toda a sua aritmética. Incluído para compatibilidade com a especificação.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Decimal.remainder_near">
<code class="sig-name descname">remainder_near</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">context</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.remainder_near" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna o resto da divisão de <em>self</em> por <em>other</em>. Isso é diferente de <code class="docutils literal notranslate"><span class="pre">self</span> <span class="pre">%</span> <span class="pre">other</span></code>, pois o sinal do resto é escolhido para minimizar seu valor absoluto. Mais precisamente, o valor de retorno é <code class="docutils literal notranslate"><span class="pre">self</span> <span class="pre">-</span> <span class="pre">n</span> <span class="pre">*</span> <span class="pre">other</span></code>, onde <code class="docutils literal notranslate"><span class="pre">n</span></code> é o número inteiro mais próximo do valor exato de <code class="docutils literal notranslate"><span class="pre">self</span> <span class="pre">/</span> <span class="pre">other</span></code>, e se dois números inteiros estiverem igualmente próximos, o par será é escolhido.</p>
<p>Se o resultado for zero, seu sinal será o sinal de <em>self</em>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">18</span><span class="p">)</span><span class="o">.</span><span class="n">remainder_near</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">Decimal(&#39;-2&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span><span class="o">.</span><span class="n">remainder_near</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">Decimal(&#39;5&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">35</span><span class="p">)</span><span class="o">.</span><span class="n">remainder_near</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">Decimal(&#39;-5&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="decimal.Decimal.rotate">
<code class="sig-name descname">rotate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">context</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.rotate" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna o resultado da rotação dos dígitos do primeiro operando em uma quantidade especificada pelo segundo operando. O segundo operando deve ser um número inteiro no intervalo - precisão através da precisão. O valor absoluto do segundo operando fornece o número de locais a serem rotacionados. Se o segundo operando for positivo, a rotação será para a esquerda; caso contrário, a rotação será para a direita. O coeficiente do primeiro operando é preenchido à esquerda com zeros na precisão do comprimento, se necessário. O sinal e o expoente do primeiro operando não são alterados.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Decimal.same_quantum">
<code class="sig-name descname">same_quantum</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">context</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.same_quantum" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Testa se “self” e “other” têm o mesmo expoente ou se ambos são <code class="xref py py-const docutils literal notranslate"><span class="pre">NaN</span></code>.</p>
<p>Esta operação não é afetada pelo contexto e é silenciosa: nenhum sinalizador é alterado e nenhum arredondamento é executado. Como uma exceção, a versão C pode levantar InvalidOperation se o segundo operando não puder ser convertido exatamente.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Decimal.scaleb">
<code class="sig-name descname">scaleb</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">context</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.scaleb" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna o primeiro operando com o expoente ajustado pelo segundo. Da mesma forma, retorna o primeiro operando multiplicado por <code class="docutils literal notranslate"><span class="pre">10**other</span></code>. O segundo operando deve ser um número inteiro.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Decimal.shift">
<code class="sig-name descname">shift</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">context</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.shift" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna o resultado da troca dos dígitos do primeiro operando em uma quantidade especificada pelo segundo operando. O segundo operando deve ser um número inteiro no intervalo - precisão através da precisão. O valor absoluto do segundo operando fornece o número de locais a serem deslocados. Se o segundo operando for positivo, o deslocamento será para a esquerda; caso contrário, a mudança é para a direita. Os dígitos deslocados para o coeficiente são zeros. O sinal e o expoente do primeiro operando não são alterados.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Decimal.sqrt">
<code class="sig-name descname">sqrt</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">context</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.sqrt" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna a raiz quadrada do argumento para a precisão total.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Decimal.to_eng_string">
<code class="sig-name descname">to_eng_string</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">context</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.to_eng_string" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Converte em uma string, usando notação de engenharia, se for necessário um expoente.</p>
<p>A notação de engenharia possui um expoente que é múltiplo de 3. Isso pode deixar até 3 dígitos à esquerda da casa decimal e pode exigir a adição de um ou dois zeros à direita.</p>
<p>Por exemplo, isso converte <code class="docutils literal notranslate"><span class="pre">Decimal('123E+1')</span></code> para <code class="docutils literal notranslate"><span class="pre">Decimal('1.23E+3')</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Decimal.to_integral">
<code class="sig-name descname">to_integral</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">rounding</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">context</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.to_integral" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Idêntico ao método <a class="reference internal" href="#decimal.Decimal.to_integral_value" title="decimal.Decimal.to_integral_value"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_integral_value()</span></code></a>. O nome <code class="docutils literal notranslate"><span class="pre">to_integral</span></code> foi mantido para compatibilidade com versões mais antigas.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Decimal.to_integral_exact">
<code class="sig-name descname">to_integral_exact</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">rounding</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">context</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.to_integral_exact" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Arredonda para o número inteiro mais próximo, sinalizando <a class="reference internal" href="#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-const docutils literal notranslate"><span class="pre">Inexact</span></code></a> ou <a class="reference internal" href="#decimal.Rounded" title="decimal.Rounded"><code class="xref py py-const docutils literal notranslate"><span class="pre">Rounded</span></code></a>, conforme apropriado, se o arredondamento ocorrer. O modo de arredondamento é determinado pelo parâmetro <code class="docutils literal notranslate"><span class="pre">rouding</span></code>, se fornecido, ou pelo <code class="docutils literal notranslate"><span class="pre">context</span></code> especificado. Se nenhum parâmetro for fornecido, o modo de arredondamento do contexto atual será usado.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Decimal.to_integral_value">
<code class="sig-name descname">to_integral_value</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">rounding</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">context</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.to_integral_value" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Arredonda para o número inteiro mais próximo sem sinalizar <a class="reference internal" href="#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-const docutils literal notranslate"><span class="pre">Inexact</span></code></a> ou <code class="xref py py-const docutils literal notranslate"><span class="pre">Rounding</span></code>. Se fornecido, aplica <em>rounding</em>; caso contrário, usa o método de arredondamento no <em>context</em> especificado ou no contexto atual.</p>
</dd></dl>

</dd></dl>

<section id="logical-operands">
<span id="logical-operands-label"></span><h3>Operandos lógicos<a class="headerlink" href="#logical-operands" title="Link permanente para este título">¶</a></h3>
<p>Os métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">logical_and()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">logical_invert()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">logical_or()</span></code> e <code class="xref py py-meth docutils literal notranslate"><span class="pre">logical_xor()</span></code> esperam que seus argumentos sejam <em>operandos lógicos</em>. Um <em>operando lógico</em> é uma instância de <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> cujo expoente e sinal são zero e cujos dígitos são todos <code class="xref py py-const docutils literal notranslate"><span class="pre">0</span></code> ou <code class="xref py py-const docutils literal notranslate"><span class="pre">1</span></code>.</p>
</section>
</section>
<section id="context-objects">
<span id="decimal-context"></span><h2>Objetos de contexto<a class="headerlink" href="#context-objects" title="Link permanente para este título">¶</a></h2>
<p>Contextos são ambientes para operações aritméticas. Eles governam a precisão, estabelecem regras para arredondamento, determinam quais sinais são tratados como exceções e limitam o intervalo dos expoentes.</p>
<p>Cada thread possui seu próprio contexto atual que é acessado ou alterado usando as funções <a class="reference internal" href="#decimal.getcontext" title="decimal.getcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">getcontext()</span></code></a> e <a class="reference internal" href="#decimal.setcontext" title="decimal.setcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">setcontext()</span></code></a>:</p>
<dl class="py function">
<dt id="decimal.getcontext">
<code class="sig-prename descclassname">decimal.</code><code class="sig-name descname">getcontext</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.getcontext" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna o contexto atual para a thread ativa.</p>
</dd></dl>

<dl class="py function">
<dt id="decimal.setcontext">
<code class="sig-prename descclassname">decimal.</code><code class="sig-name descname">setcontext</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">c</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.setcontext" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Define o contexto atual para a thread ativa como <em>C</em>.</p>
</dd></dl>

<p>Você também pode usar a instrução <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> e a função <a class="reference internal" href="#decimal.localcontext" title="decimal.localcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">localcontext()</span></code></a> para alterar temporariamente o contexto ativo.</p>
<dl class="py function">
<dt id="decimal.localcontext">
<code class="sig-prename descclassname">decimal.</code><code class="sig-name descname">localcontext</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ctx</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.localcontext" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna um gerenciador de contexto que vai definir o contexto atual da thread ativa para uma cópia de <em>ctx</em> na entrada da instrução “with” e restaurar o contexto anterior ao sair da instrução “with”. Se nenhum contexto for especificado, uma cópia do contexto atual será usada.</p>
<p>Por exemplo, o código a seguir define a precisão decimal atual para 42 casas, executa um cálculo e restaura automaticamente o contexto anterior:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">decimal</span> <span class="kn">import</span> <span class="n">localcontext</span>

<span class="k">with</span> <span class="n">localcontext</span><span class="p">()</span> <span class="k">as</span> <span class="n">ctx</span><span class="p">:</span>
    <span class="n">ctx</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">42</span>   <span class="c1"># Perform a high precision calculation</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">calculate_something</span><span class="p">()</span>
<span class="n">s</span> <span class="o">=</span> <span class="o">+</span><span class="n">s</span>  <span class="c1"># Round the final result back to the default precision</span>
</pre></div>
</div>
</dd></dl>

<p>Novos contextos também podem ser criados usando o construtor <a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a> descrito abaixo. Além disso, o módulo fornece três contextos pré-criados:</p>
<dl class="py class">
<dt id="decimal.BasicContext">
<em class="property">class </em><code class="sig-prename descclassname">decimal.</code><code class="sig-name descname">BasicContext</code><a class="headerlink" href="#decimal.BasicContext" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Este é um contexto padrão definido pela Especificação Aritmética Decimal Geral. A precisão está definida como nove. O arredondamento está definido como <a class="reference internal" href="#decimal.ROUND_HALF_UP" title="decimal.ROUND_HALF_UP"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_HALF_UP</span></code></a>. Todos os sinalizadores estão limpos. Todos as armadilhas estão ativadas (tratadas como exceções), exceto por <a class="reference internal" href="#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-const docutils literal notranslate"><span class="pre">Inexact</span></code></a>, <a class="reference internal" href="#decimal.Rounded" title="decimal.Rounded"><code class="xref py py-const docutils literal notranslate"><span class="pre">Rounded</span></code></a> e <a class="reference internal" href="#decimal.Subnormal" title="decimal.Subnormal"><code class="xref py py-const docutils literal notranslate"><span class="pre">Subnormal</span></code></a>.</p>
<p>Como muitas das armadilhas estão ativadas, esse contexto é útil para depuração.</p>
</dd></dl>

<dl class="py class">
<dt id="decimal.ExtendedContext">
<em class="property">class </em><code class="sig-prename descclassname">decimal.</code><code class="sig-name descname">ExtendedContext</code><a class="headerlink" href="#decimal.ExtendedContext" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Este é um contexto padrão definido pela Especificação Aritmética Decimal Geral. A precisão está definida como nove. O arredondamento está definido como <a class="reference internal" href="#decimal.ROUND_HALF_EVEN" title="decimal.ROUND_HALF_EVEN"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_HALF_EVEN</span></code></a>. Todos os sinalizadores estão limpos. Nenhuma armadilha está ativada (de forma que exceções não são levantadas durante os cálculos).</p>
<p>Como as armadilhas estão desativadas, esse contexto é útil para aplicativos que preferem ter o valor de resultado de <code class="xref py py-const docutils literal notranslate"><span class="pre">NaN</span></code> ou <code class="xref py py-const docutils literal notranslate"><span class="pre">Infinity</span></code> em vez de levantar exceções. Isso permite que uma aplicação conclua uma execução na presença de condições que interromperiam o programa.</p>
</dd></dl>

<dl class="py class">
<dt id="decimal.DefaultContext">
<em class="property">class </em><code class="sig-prename descclassname">decimal.</code><code class="sig-name descname">DefaultContext</code><a class="headerlink" href="#decimal.DefaultContext" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Este contexto é usado pelo construtor <a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a> como um protótipo para novos contextos. Alterar um campo (tal como precisão) tem o efeito de alterar o padrão para novos contextos criados pelo construtor <a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a>.</p>
<p>Esse contexto é mais útil em ambientes multithread. A alteração de um dos campos antes do início das threads tem o efeito de definir os padrões para todo o sistema. Não é recomendável alterar os campos após o início das threads, pois exigiria sincronização de threads para evitar condições de corrida.</p>
<p>Em ambientes de thread única, é preferível não usar esse contexto. Em vez disso, basta criar contextos explicitamente, conforme descrito abaixo.</p>
<p>Os valores padrão são <code class="xref py py-attr docutils literal notranslate"><span class="pre">prec</span></code>=<code class="xref py py-const docutils literal notranslate"><span class="pre">28</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">rounding</span></code>=<a class="reference internal" href="#decimal.ROUND_HALF_EVEN" title="decimal.ROUND_HALF_EVEN"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_HALF_EVEN</span></code></a> e armadilhas ativadas para <a class="reference internal" href="#decimal.Overflow" title="decimal.Overflow"><code class="xref py py-class docutils literal notranslate"><span class="pre">Overflow</span></code></a>, <a class="reference internal" href="#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-class docutils literal notranslate"><span class="pre">InvalidOperation</span></code></a> e <a class="reference internal" href="#decimal.DivisionByZero" title="decimal.DivisionByZero"><code class="xref py py-class docutils literal notranslate"><span class="pre">DivisionByZero</span></code></a>.</p>
</dd></dl>

<p>Além dos três contextos fornecidos, novos contextos podem ser criados com o construtor <a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a>.</p>
<dl class="py class">
<dt id="decimal.Context">
<em class="property">class </em><code class="sig-prename descclassname">decimal.</code><code class="sig-name descname">Context</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">prec</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">rounding</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">Emin</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">Emax</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">capitals</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">clamp</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">flags</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">traps</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Cria um novo contexto. Se um campo não for especificado ou for <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>, os valores padrão serão copiados de <a class="reference internal" href="#decimal.DefaultContext" title="decimal.DefaultContext"><code class="xref py py-const docutils literal notranslate"><span class="pre">DefaultContext</span></code></a>. Se o campo <em>flags</em> não for especificado ou for <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>, todos os sinalizadores serão limpados.</p>
<p><em>prec</em> é um número inteiro no intervalo [<code class="xref py py-const docutils literal notranslate"><span class="pre">1</span></code>, <a class="reference internal" href="#decimal.MAX_PREC" title="decimal.MAX_PREC"><code class="xref py py-const docutils literal notranslate"><span class="pre">MAX_PREC</span></code></a>] que define a precisão das operações aritméticas no contexto.</p>
<p>A opção <em>rounding</em> é uma das constantes listadas na seção <a class="reference internal" href="#rounding-modes">Modos de arredondamento</a>.</p>
<p>Os campos <em>traps</em> e <em>flags</em> listam todos os sinais a serem configurados. Geralmente, novos contextos devem apenas definir armadilhas e deixar os sinalizadores limpos.</p>
<p>Os campos <em>Emin</em> e <em>Emax</em> são números inteiros que especificam os limites externos permitidos para expoentes. <em>Emin</em> deve estar no intervalo [<a class="reference internal" href="#decimal.MIN_EMIN" title="decimal.MIN_EMIN"><code class="xref py py-const docutils literal notranslate"><span class="pre">MIN_EMIN</span></code></a>, <code class="xref py py-const docutils literal notranslate"><span class="pre">0</span></code>], <em>Emax</em> no intervalo [<code class="xref py py-const docutils literal notranslate"><span class="pre">0</span></code>, <a class="reference internal" href="#decimal.MAX_EMAX" title="decimal.MAX_EMAX"><code class="xref py py-const docutils literal notranslate"><span class="pre">MAX_EMAX</span></code></a>].</p>
<p>O campo <em>capitals</em> é <code class="xref py py-const docutils literal notranslate"><span class="pre">0</span></code> ou <code class="xref py py-const docutils literal notranslate"><span class="pre">1</span></code> (o padrão). Se definido como <code class="xref py py-const docutils literal notranslate"><span class="pre">1</span></code>, os expoentes serão impressos com um <code class="xref py py-const docutils literal notranslate"><span class="pre">E</span></code> maiúsculo; caso contrário, um <code class="xref py py-const docutils literal notranslate"><span class="pre">e</span></code> minúscula é usado: <code class="xref py py-const docutils literal notranslate"><span class="pre">Decimal('6.02e+23')</span></code>.</p>
<p>O campo <em>clamp</em> é <code class="xref py py-const docutils literal notranslate"><span class="pre">0</span></code> (o padrão) ou <code class="xref py py-const docutils literal notranslate"><span class="pre">1</span></code>. Se definido como <code class="xref py py-const docutils literal notranslate"><span class="pre">1</span></code>, o expoente <code class="docutils literal notranslate"><span class="pre">e</span></code> de uma instância de <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> representável nesse contexto é estritamente limitado ao intervalo <code class="docutils literal notranslate"><span class="pre">Emin</span> <span class="pre">-</span> <span class="pre">prec</span> <span class="pre">+</span> <span class="pre">1</span> <span class="pre">&lt;=</span> <span class="pre">e</span> <span class="pre">&lt;=</span> <span class="pre">Emax</span> <span class="pre">-</span> <span class="pre">prec</span> <span class="pre">+</span> <span class="pre">1</span></code>. Se <em>clamp</em> for <code class="xref py py-const docutils literal notranslate"><span class="pre">0</span></code>, uma condição mais fraca será mantida: o expoente ajustado da instância de <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> é no máximo <code class="docutils literal notranslate"><span class="pre">Emax</span></code>. Quando <em>clamp</em> é <code class="xref py py-const docutils literal notranslate"><span class="pre">1</span></code>, um grande número normal terá, sempre que possível, seu expoente reduzido e um número correspondente de zeros adicionado ao seu coeficiente, para ajustar as restrições do expoente; isso preserva o valor do número, mas perde informações sobre zeros à direita significativos. Por exemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">Emax</span><span class="o">=</span><span class="mi">999</span><span class="p">,</span> <span class="n">clamp</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">create_decimal</span><span class="p">(</span><span class="s1">&#39;1.23e999&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;1.23000E+999&#39;)</span>
</pre></div>
</div>
<p>Um valor de <em>clamp</em> de <code class="xref py py-const docutils literal notranslate"><span class="pre">1</span></code> permite compatibilidade com os formatos de intercâmbio decimal de largura fixa especificados na IEEE 754.</p>
<p>A classe <a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a> define vários métodos de uso geral, bem como um grande número de métodos para fazer aritmética diretamente em um determinado contexto. Além disso, para cada um dos métodos de <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> descritos acima (com exceção dos métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">adjusted()</span></code> e <code class="xref py py-meth docutils literal notranslate"><span class="pre">as_tuple()</span></code>) existe um método correspondente em <a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a>. Por exemplo, para uma instância <code class="docutils literal notranslate"><span class="pre">C</span></code> de <a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a> e uma instância <code class="docutils literal notranslate"><span class="pre">x</span></code> de <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a>, <code class="docutils literal notranslate"><span class="pre">C.exp(x)</span></code> é equivalente a <code class="docutils literal notranslate"><span class="pre">x.exp(context=C)</span></code>. Cada método de <a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a> aceita um número inteiro do Python (uma instância de <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) em qualquer lugar em que uma instância de Decimal seja aceita.</p>
<dl class="py method">
<dt id="decimal.Context.clear_flags">
<code class="sig-name descname">clear_flags</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.clear_flags" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Redefine todos os sinalizadores para <code class="xref py py-const docutils literal notranslate"><span class="pre">0</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.clear_traps">
<code class="sig-name descname">clear_traps</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.clear_traps" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Redefine todas as armadilhas para <code class="xref py py-const docutils literal notranslate"><span class="pre">0</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.3.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.copy" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna uma duplicata do contexto.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.copy_decimal">
<code class="sig-name descname">copy_decimal</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">num</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.copy_decimal" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna uma cópia da instância de Decimal <em>num</em>.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.create_decimal">
<code class="sig-name descname">create_decimal</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">num</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.create_decimal" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Cria uma nova instância decimal a partir de <em>num</em>, mas usando <em>self</em> como contexto. Diferentemente do construtor de <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a>, a precisão do contexto, o método de arredondamento, os sinalizadores e as armadilhas são aplicadas à conversão.</p>
<p>Isso é útil porque as constantes geralmente são fornecidas com uma precisão maior do que a necessária pela aplicação. Outro benefício é que o arredondamento elimina imediatamente os efeitos indesejados dos dígitos além da precisão atual. No exemplo a seguir, o uso de entradas não arredondadas significa que adicionar zero a uma soma pode alterar o resultado:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.4445&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;1.0023&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;4.45&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.4445&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;1.0023&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;4.44&#39;)</span>
</pre></div>
</div>
<p>Este método implementa a operação “to-number” da especificação IBM. Se o argumento for uma string, nenhum espaço em branco à esquerda ou à direita ou sublinhado serão permitidos.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.create_decimal_from_float">
<code class="sig-name descname">create_decimal_from_float</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">f</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.create_decimal_from_float" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Cria uma nova instância de Decimal a partir de um ponto flutuante <em>f</em>, mas arredondando usando <em>self</em> como contexto. Diferentemente do método da classe <a class="reference internal" href="#decimal.Decimal.from_float" title="decimal.Decimal.from_float"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Decimal.from_float()</span></code></a>, a precisão do contexto, o método de arredondamento, os sinalizadores e as armadilhas são aplicados à conversão.</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">context</span> <span class="o">=</span> <span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">rounding</span><span class="o">=</span><span class="n">ROUND_DOWN</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">context</span><span class="o">.</span><span class="n">create_decimal_from_float</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="go">Decimal(&#39;3.1415&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">context</span> <span class="o">=</span> <span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">traps</span><span class="o">=</span><span class="p">[</span><span class="n">Inexact</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">context</span><span class="o">.</span><span class="n">create_decimal_from_float</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">decimal.Inexact</span>: <span class="n">None</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.1.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.Etiny">
<code class="sig-name descname">Etiny</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.Etiny" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna um valor igual a <code class="docutils literal notranslate"><span class="pre">Emin</span> <span class="pre">-</span> <span class="pre">prec</span> <span class="pre">+</span> <span class="pre">1</span></code>, que é o valor mínimo do expoente para resultados subnormais. Quando ocorre o estouro negativo, o expoente é definido como <a class="reference internal" href="#decimal.Context.Etiny" title="decimal.Context.Etiny"><code class="xref py py-const docutils literal notranslate"><span class="pre">Etiny</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.Etop">
<code class="sig-name descname">Etop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.Etop" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna um valor igual a <code class="docutils literal notranslate"><span class="pre">Emax</span> <span class="pre">-</span> <span class="pre">prec</span> <span class="pre">+</span> <span class="pre">1</span></code>.</p>
</dd></dl>

<p>A abordagem usual para trabalhar com decimais é criar instâncias de <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> e depois aplicar operações aritméticas que ocorrem no contexto atual da thread ativa. Uma abordagem alternativa é usar métodos de contexto para calcular dentro de um contexto específico. Os métodos são semelhantes aos da classe <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> e são contados apenas brevemente aqui.</p>
<dl class="py method">
<dt id="decimal.Context.abs">
<code class="sig-name descname">abs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.abs" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna o valor absoluto de <em>x</em>.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.add">
<code class="sig-name descname">add</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.add" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna a soma de <em>x</em> e <em>y</em>.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.canonical">
<code class="sig-name descname">canonical</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.canonical" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna o mesmo objeto de Decimal <em>x</em>.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.compare">
<code class="sig-name descname">compare</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.compare" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Compara <em>x</em> e <em>y</em> numericamente.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.compare_signal">
<code class="sig-name descname">compare_signal</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.compare_signal" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Compara os valores dos dois operandos numericamente.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.compare_total">
<code class="sig-name descname">compare_total</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.compare_total" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Compara dois operandos usando sua representação abstrata.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.compare_total_mag">
<code class="sig-name descname">compare_total_mag</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.compare_total_mag" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Compara dois operandos usando sua representação abstrata, ignorando o sinal.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.copy_abs">
<code class="sig-name descname">copy_abs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.copy_abs" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna uma cópia de <em>x</em> com o sinal definido para 0.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.copy_negate">
<code class="sig-name descname">copy_negate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.copy_negate" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna uma cópia de <em>x</em> com o sinal invertido.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.copy_sign">
<code class="sig-name descname">copy_sign</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.copy_sign" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Copia o sinal de <em>y</em> para <em>x</em>.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.divide">
<code class="sig-name descname">divide</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.divide" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna <em>x</em> dividido por <em>y</em>.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.divide_int">
<code class="sig-name descname">divide_int</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.divide_int" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna <em>x</em> dividido por <em>y</em>, truncado para um inteiro.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.divmod">
<code class="sig-name descname">divmod</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.divmod" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Divide dois números e retorna a parte inteira do resultado.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.exp">
<code class="sig-name descname">exp</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.exp" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna <cite>e ** x</cite>.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.fma">
<code class="sig-name descname">fma</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">z</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.fma" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna <em>x</em> multiplicado por <em>y</em>, mais <em>z</em>.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.is_canonical">
<code class="sig-name descname">is_canonical</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_canonical" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> se <em>x</em> for canonical; caso contrário, retorna <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.is_finite">
<code class="sig-name descname">is_finite</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_finite" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> se <em>x</em> for finito; caso contrário, retorna <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.is_infinite">
<code class="sig-name descname">is_infinite</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_infinite" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> se <em>x</em> for infinito; caso contrário, retorna <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.is_nan">
<code class="sig-name descname">is_nan</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_nan" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> se <em>x</em> for qNaN ou sNaN; caso contrário, retorna <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.is_normal">
<code class="sig-name descname">is_normal</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_normal" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> se <em>x</em> for um número normal; caso contrário, retorna <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.is_qnan">
<code class="sig-name descname">is_qnan</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_qnan" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> se <em>x</em> for um NaN silencioso; caso contrário, retorna <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.is_signed">
<code class="sig-name descname">is_signed</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_signed" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> se <em>x</em> for negativo; caso contrário, retorna <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.is_snan">
<code class="sig-name descname">is_snan</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_snan" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> se <em>x</em> for um NaN sinalizador; caso contrário, retorna <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.is_subnormal">
<code class="sig-name descname">is_subnormal</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_subnormal" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> se <em>x</em> for subnormal; caso contrário, retorna <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.is_zero">
<code class="sig-name descname">is_zero</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_zero" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> se <em>x</em> for zero; caso contrário, retorna <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.ln">
<code class="sig-name descname">ln</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.ln" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna o logaritmo natural (base e) de <em>x</em>.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.log10">
<code class="sig-name descname">log10</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.log10" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna o logaritmo de base 10 de <em>x</em>.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.logb">
<code class="sig-name descname">logb</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.logb" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna o expoente da magnitude do MSD do operando.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.logical_and">
<code class="sig-name descname">logical_and</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.logical_and" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Aplica a operação lógica <em>e</em> entre cada dígito do operando.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.logical_invert">
<code class="sig-name descname">logical_invert</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.logical_invert" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Inverte todos os dígitos em <em>x</em>.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.logical_or">
<code class="sig-name descname">logical_or</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.logical_or" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Aplica a operação lógica <em>ou</em> entre cada dígito do operando.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.logical_xor">
<code class="sig-name descname">logical_xor</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.logical_xor" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Aplica a operação lógica <em>ou exclusivo</em> entre cada dígito do operando.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.max">
<code class="sig-name descname">max</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.max" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Compara dois valores numericamente e retorna o máximo.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.max_mag">
<code class="sig-name descname">max_mag</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.max_mag" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Compara dois valores numericamente com seu sinal ignorado.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.min">
<code class="sig-name descname">min</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.min" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Compara dois valores numericamente e retorna o mínimo.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.min_mag">
<code class="sig-name descname">min_mag</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.min_mag" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Compara dois valores numericamente com seu sinal ignorado.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.minus">
<code class="sig-name descname">minus</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.minus" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Minus corresponde ao operador de subtração de prefixo unário no Python.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.multiply">
<code class="sig-name descname">multiply</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.multiply" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna o produto de <em>x</em> e <em>y</em>.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.next_minus">
<code class="sig-name descname">next_minus</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.next_minus" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna o maior número representável menor que <em>x</em>.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.next_plus">
<code class="sig-name descname">next_plus</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.next_plus" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna o menor número representável maior que <em>x</em>.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.next_toward">
<code class="sig-name descname">next_toward</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.next_toward" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna o número mais próximo a <em>x</em>, em direção a <em>y</em>.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.normalize">
<code class="sig-name descname">normalize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.normalize" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Reduz <em>x</em> para sua forma mais simples.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.number_class">
<code class="sig-name descname">number_class</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.number_class" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna uma indicação da classe de <em>x</em>.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.plus">
<code class="sig-name descname">plus</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.plus" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Plus corresponde ao operador de soma de prefixo unário no Python. Esta operação aplica a precisão e o arredondamento do contexto, portanto <em>não</em> é uma operação de identidade.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.power">
<code class="sig-name descname">power</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">modulo</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.power" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">x</span></code> à potência de <code class="docutils literal notranslate"><span class="pre">y</span></code>, com a redução de módulo <code class="docutils literal notranslate"><span class="pre">modulo</span></code> se fornecido.</p>
<p>Com dois argumentos, calcula <code class="docutils literal notranslate"><span class="pre">x**y</span></code>. Se <code class="docutils literal notranslate"><span class="pre">x</span></code> for negativo, <code class="docutils literal notranslate"><span class="pre">y</span></code> deve ser inteiro. O resultado será inexato, a menos que <code class="docutils literal notranslate"><span class="pre">y</span></code> seja inteiro e o resultado seja finito e possa ser expresso exatamente em “precisão” dígitos. O modo de arredondamento do contexto é usado. Os resultados são sempre arredondados corretamente na versão Python.</p>
<p><code class="docutils literal notranslate"><span class="pre">Decimal(0)</span> <span class="pre">**</span> <span class="pre">Decimal(0)</span></code> resulta em <code class="docutils literal notranslate"><span class="pre">InvalidOperation</span></code>, e se <code class="docutils literal notranslate"><span class="pre">InvalidOperation</span></code> não for capturado, resulta em <code class="docutils literal notranslate"><span class="pre">Decimal('NaN')</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.3: </span>O módulo C calcula <a class="reference internal" href="#decimal.Context.power" title="decimal.Context.power"><code class="xref py py-meth docutils literal notranslate"><span class="pre">power()</span></code></a> em termos das funções corretamente arredondadas <a class="reference internal" href="#decimal.Context.exp" title="decimal.Context.exp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exp()</span></code></a> e <a class="reference internal" href="#decimal.Context.ln" title="decimal.Context.ln"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ln()</span></code></a>. O resultado é bem definido, mas apenas “quase sempre corretamente arredondado”.</p>
</div>
<p>Com três argumentos, calcula <code class="docutils literal notranslate"><span class="pre">(x**y)</span> <span class="pre">%</span> <span class="pre">modulo</span></code>. Para o formulário de três argumentos, as seguintes restrições nos argumentos são válidas:</p>
<blockquote>
<div><ul class="simple">
<li><p>todos os três argumentos devem ser inteiros</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">y</span></code> não pode ser negativo</p></li>
<li><p>pelo menos um de <code class="docutils literal notranslate"><span class="pre">x</span></code> ou <code class="docutils literal notranslate"><span class="pre">y</span></code> não pode ser negativo</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">modulo</span></code> não pode ser zero e deve ter pelo menos “precisão” dígitos</p></li>
</ul>
</div></blockquote>
<p>O valor resultante de <code class="docutils literal notranslate"><span class="pre">Context.power(x,</span> <span class="pre">y,</span> <span class="pre">modulo)</span></code> é igual ao valor que seria obtido ao computar <code class="docutils literal notranslate"><span class="pre">(x**y)</span> <span class="pre">%</span> <span class="pre">modulo</span></code> com precisão ilimitada, mas é calculado com mais eficiência . O expoente do resultado é zero, independentemente dos expoentes de <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code> e <code class="docutils literal notranslate"><span class="pre">modulo</span></code>. O resultado é sempre exato.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.quantize">
<code class="sig-name descname">quantize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.quantize" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna um valor igual a <em>x</em> (arredondado), com o expoente de <em>y</em>.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.radix">
<code class="sig-name descname">radix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.radix" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Só retorna 10, já que isso é Decimal, :)</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.remainder">
<code class="sig-name descname">remainder</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.remainder" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna o resto da divisão inteira.</p>
<p>O sinal do resultado, se diferente de zero, é o mesmo que o do dividendo original.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.remainder_near">
<code class="sig-name descname">remainder_near</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.remainder_near" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">-</span> <span class="pre">y</span> <span class="pre">*</span> <span class="pre">n</span></code>, onde <em>n</em> é o número inteiro mais próximo do valor exato de <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">/</span> <span class="pre">y</span></code> (se o resultado for 0, seu sinal será o sinal de <em>x</em>).</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.rotate">
<code class="sig-name descname">rotate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.rotate" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna uma cópia re de <em>x</em>, <em>y</em> vezes.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.same_quantum">
<code class="sig-name descname">same_quantum</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.same_quantum" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> se os dois operandos tiverem o mesmo expoente.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.scaleb">
<code class="sig-name descname">scaleb</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.scaleb" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna o primeiro operando após adicionar o segundo valor seu exp.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.shift">
<code class="sig-name descname">shift</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.shift" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna uma cópia deslocada de <em>x</em>, <em>y</em> vezes.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.sqrt">
<code class="sig-name descname">sqrt</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.sqrt" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Raiz quadrada de um número não negativo para precisão do contexto.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.subtract">
<code class="sig-name descname">subtract</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.subtract" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna a diferença entre <em>x</em> e <em>y</em>.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.to_eng_string">
<code class="sig-name descname">to_eng_string</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.to_eng_string" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Converte em uma string, usando notação de engenharia, se for necessário um expoente.</p>
<p>A notação de engenharia possui um expoente que é múltiplo de 3. Isso pode deixar até 3 dígitos à esquerda da casa decimal e pode exigir a adição de um ou dois zeros à direita.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.to_integral_exact">
<code class="sig-name descname">to_integral_exact</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.to_integral_exact" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Arredonda para um número inteiro.</p>
</dd></dl>

<dl class="py method">
<dt id="decimal.Context.to_sci_string">
<code class="sig-name descname">to_sci_string</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.to_sci_string" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Converte um número em uma string usando notação científica.</p>
</dd></dl>

</dd></dl>

</section>
<section id="constants">
<span id="decimal-rounding-modes"></span><h2>Constantes<a class="headerlink" href="#constants" title="Link permanente para este título">¶</a></h2>
<p>As constantes nesta seção são relevantes apenas para o módulo C. Eles também estão incluídos na versão pura do Python para compatibilidade.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 29%" />
<col style="width: 29%" />
<col style="width: 42%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"></th>
<th class="head"><p>32 bits</p></th>
<th class="head"><p>64 bits</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><dl class="py data">
<dt id="decimal.MAX_PREC">
<code class="sig-prename descclassname">decimal.</code><code class="sig-name descname">MAX_PREC</code><a class="headerlink" href="#decimal.MAX_PREC" title="Link permanente para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">425000000</span></code></p></td>
<td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">999999999999999999</span></code></p></td>
</tr>
<tr class="row-odd"><td><dl class="py data">
<dt id="decimal.MAX_EMAX">
<code class="sig-prename descclassname">decimal.</code><code class="sig-name descname">MAX_EMAX</code><a class="headerlink" href="#decimal.MAX_EMAX" title="Link permanente para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">425000000</span></code></p></td>
<td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">999999999999999999</span></code></p></td>
</tr>
<tr class="row-even"><td><dl class="py data">
<dt id="decimal.MIN_EMIN">
<code class="sig-prename descclassname">decimal.</code><code class="sig-name descname">MIN_EMIN</code><a class="headerlink" href="#decimal.MIN_EMIN" title="Link permanente para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">-425000000</span></code></p></td>
<td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">-999999999999999999</span></code></p></td>
</tr>
<tr class="row-odd"><td><dl class="py data">
<dt id="decimal.MIN_ETINY">
<code class="sig-prename descclassname">decimal.</code><code class="sig-name descname">MIN_ETINY</code><a class="headerlink" href="#decimal.MIN_ETINY" title="Link permanente para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">-849999999</span></code></p></td>
<td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">-1999999999999999997</span></code></p></td>
</tr>
</tbody>
</table>
<dl class="py data">
<dt id="decimal.HAVE_THREADS">
<code class="sig-prename descclassname">decimal.</code><code class="sig-name descname">HAVE_THREADS</code><a class="headerlink" href="#decimal.HAVE_THREADS" title="Link permanente para esta definição">¶</a></dt>
<dd><p>O valor é <code class="docutils literal notranslate"><span class="pre">True</span></code>. Descontinuado porque o Python agora sempre tem threads.</p>
</dd></dl>

<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde a versão 3.9.</span></p>
</div>
<dl class="py data">
<dt id="decimal.HAVE_CONTEXTVAR">
<code class="sig-prename descclassname">decimal.</code><code class="sig-name descname">HAVE_CONTEXTVAR</code><a class="headerlink" href="#decimal.HAVE_CONTEXTVAR" title="Link permanente para esta definição">¶</a></dt>
<dd><p>O valor padrão é <code class="docutils literal notranslate"><span class="pre">True</span></code>. Se o Python for <a class="reference internal" href="../using/configure.html#cmdoption-without-decimal-contextvar"><code class="xref std std-option docutils literal notranslate"><span class="pre">configurado</span> <span class="pre">usando</span> <span class="pre">a</span> <span class="pre">opção</span> <span class="pre">--without-decimal-contextvar</span></code></a>, a versão C usará um contexto local de thread em vez de local de corrotina e o valor será <code class="docutils literal notranslate"><span class="pre">False</span></code>. Isso é um pouco mais rápido em alguns cenários de contexto aninhados.</p>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.9: </span>backport realizado para 3.7 e 3.8.</p>
</div>
</section>
<section id="rounding-modes">
<h2>Modos de arredondamento<a class="headerlink" href="#rounding-modes" title="Link permanente para este título">¶</a></h2>
<dl class="py data">
<dt id="decimal.ROUND_CEILING">
<code class="sig-prename descclassname">decimal.</code><code class="sig-name descname">ROUND_CEILING</code><a class="headerlink" href="#decimal.ROUND_CEILING" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Arredonda para <code class="xref py py-const docutils literal notranslate"><span class="pre">Infinity</span></code>.</p>
</dd></dl>

<dl class="py data">
<dt id="decimal.ROUND_DOWN">
<code class="sig-prename descclassname">decimal.</code><code class="sig-name descname">ROUND_DOWN</code><a class="headerlink" href="#decimal.ROUND_DOWN" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Arredonda para zero.</p>
</dd></dl>

<dl class="py data">
<dt id="decimal.ROUND_FLOOR">
<code class="sig-prename descclassname">decimal.</code><code class="sig-name descname">ROUND_FLOOR</code><a class="headerlink" href="#decimal.ROUND_FLOOR" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Arredonda para <code class="xref py py-const docutils literal notranslate"><span class="pre">-Infinity</span></code>.</p>
</dd></dl>

<dl class="py data">
<dt id="decimal.ROUND_HALF_DOWN">
<code class="sig-prename descclassname">decimal.</code><code class="sig-name descname">ROUND_HALF_DOWN</code><a class="headerlink" href="#decimal.ROUND_HALF_DOWN" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Arrendonda para o mais próximo com empates tendendo a zero.</p>
</dd></dl>

<dl class="py data">
<dt id="decimal.ROUND_HALF_EVEN">
<code class="sig-prename descclassname">decimal.</code><code class="sig-name descname">ROUND_HALF_EVEN</code><a class="headerlink" href="#decimal.ROUND_HALF_EVEN" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Arredonda para o mais próximo com empates indo para o mais próximo inteiro par.</p>
</dd></dl>

<dl class="py data">
<dt id="decimal.ROUND_HALF_UP">
<code class="sig-prename descclassname">decimal.</code><code class="sig-name descname">ROUND_HALF_UP</code><a class="headerlink" href="#decimal.ROUND_HALF_UP" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Arrendonda para o mais próximo com empates se afastando de zero.</p>
</dd></dl>

<dl class="py data">
<dt id="decimal.ROUND_UP">
<code class="sig-prename descclassname">decimal.</code><code class="sig-name descname">ROUND_UP</code><a class="headerlink" href="#decimal.ROUND_UP" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Arredonda se afastando de zero.</p>
</dd></dl>

<dl class="py data">
<dt id="decimal.ROUND_05UP">
<code class="sig-prename descclassname">decimal.</code><code class="sig-name descname">ROUND_05UP</code><a class="headerlink" href="#decimal.ROUND_05UP" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Arredonda se afastando de zero se o último dígito após o arredondamento para zero fosse 0 ou 5; caso contrário, arredonda para zero.</p>
</dd></dl>

</section>
<section id="signals">
<span id="decimal-signals"></span><h2>Sinais<a class="headerlink" href="#signals" title="Link permanente para este título">¶</a></h2>
<p>Sinais representam condições que surgem durante o cálculo. Cada um corresponde a um sinalizador de contexto e um ativador de armadilha de contexto.</p>
<p>O sinalizador de contexto é definido sempre que a condição é encontrada. Após o cálculo, os sinalizadores podem ser verificados para fins informativos (por exemplo, para determinar se um cálculo era exato). Depois de verificar os sinalizadores, certifique-se de limpar todos os sinalizadores antes de iniciar o próximo cálculo.</p>
<p>Se o ativador de armadilha de contexto estiver definido para o sinal, a condição fará com que uma exceção Python seja levantada. Por exemplo, se a armadilha <a class="reference internal" href="#decimal.DivisionByZero" title="decimal.DivisionByZero"><code class="xref py py-class docutils literal notranslate"><span class="pre">DivisionByZero</span></code></a> for configurada, uma exceção <a class="reference internal" href="#decimal.DivisionByZero" title="decimal.DivisionByZero"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DivisionByZero</span></code></a> será levantada ao encontrar a condição.</p>
<dl class="py class">
<dt id="decimal.Clamped">
<em class="property">class </em><code class="sig-prename descclassname">decimal.</code><code class="sig-name descname">Clamped</code><a class="headerlink" href="#decimal.Clamped" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Altera um expoente para ajustar as restrições de representação.</p>
<p>Normalmente, <em>clamping</em> ocorre quando um expoente fica fora dos limites do contexto <code class="xref py py-attr docutils literal notranslate"><span class="pre">Emin</span></code> e <code class="xref py py-attr docutils literal notranslate"><span class="pre">Emax</span></code>. Se possível, o expoente é reduzido para caber adicionando zeros ao coeficiente.</p>
</dd></dl>

<dl class="py class">
<dt id="decimal.DecimalException">
<em class="property">class </em><code class="sig-prename descclassname">decimal.</code><code class="sig-name descname">DecimalException</code><a class="headerlink" href="#decimal.DecimalException" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Classe base para outros sinais e uma subclasse de <a class="reference internal" href="exceptions.html#ArithmeticError" title="ArithmeticError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ArithmeticError</span></code></a>.</p>
</dd></dl>

<dl class="py class">
<dt id="decimal.DivisionByZero">
<em class="property">class </em><code class="sig-prename descclassname">decimal.</code><code class="sig-name descname">DivisionByZero</code><a class="headerlink" href="#decimal.DivisionByZero" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Sinaliza a divisão de um número não infinito por zero.</p>
<p>Pode ocorrer com divisão, divisão de módulo ou ao elevar um número a uma potência negativa. Se este sinal não for capturado, retornará <code class="xref py py-const docutils literal notranslate"><span class="pre">Infinity</span></code> ou <code class="xref py py-const docutils literal notranslate"><span class="pre">-Infinity</span></code> com o sinal determinado pelas entradas do cálculo.</p>
</dd></dl>

<dl class="py class">
<dt id="decimal.Inexact">
<em class="property">class </em><code class="sig-prename descclassname">decimal.</code><code class="sig-name descname">Inexact</code><a class="headerlink" href="#decimal.Inexact" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Indica que o arredondamento ocorreu e o resultado não é exato.</p>
<p>Sinaliza quando dígitos diferentes de zero foram descartados durante o arredondamento. O resultado arredondado é retornado. O sinalizador ou armadilha de sinal é usado para detectar quando os resultados são inexatos.</p>
</dd></dl>

<dl class="py class">
<dt id="decimal.InvalidOperation">
<em class="property">class </em><code class="sig-prename descclassname">decimal.</code><code class="sig-name descname">InvalidOperation</code><a class="headerlink" href="#decimal.InvalidOperation" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Uma operação inválida foi realizada.</p>
<p>Indica que uma operação foi solicitada que não faz sentido. Se não for capturado, retorna <code class="xref py py-const docutils literal notranslate"><span class="pre">NaN</span></code>. As possíveis causas incluem:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Infinity</span> <span class="o">-</span> <span class="n">Infinity</span>
<span class="mi">0</span> <span class="o">*</span> <span class="n">Infinity</span>
<span class="n">Infinity</span> <span class="o">/</span> <span class="n">Infinity</span>
<span class="n">x</span> <span class="o">%</span> <span class="mi">0</span>
<span class="n">Infinity</span> <span class="o">%</span> <span class="n">x</span>
<span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span>
<span class="mi">0</span> <span class="o">**</span> <span class="mi">0</span>
<span class="n">x</span> <span class="o">**</span> <span class="p">(</span><span class="n">non</span><span class="o">-</span><span class="n">integer</span><span class="p">)</span>
<span class="n">x</span> <span class="o">**</span> <span class="n">Infinity</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt id="decimal.Overflow">
<em class="property">class </em><code class="sig-prename descclassname">decimal.</code><code class="sig-name descname">Overflow</code><a class="headerlink" href="#decimal.Overflow" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Estouro numérico.</p>
<p>Indica que o expoente é maior que <code class="xref py py-attr docutils literal notranslate"><span class="pre">Emax</span></code> após o arredondamento ocorrer. Se não for capturado, o resultado depende do modo de arredondamento, puxando para dentro para o maior número finito representável ou arredondando para fora para <code class="xref py py-const docutils literal notranslate"><span class="pre">Infinity</span></code>. Nos dois casos, <a class="reference internal" href="#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-class docutils literal notranslate"><span class="pre">Inexact</span></code></a> e <a class="reference internal" href="#decimal.Rounded" title="decimal.Rounded"><code class="xref py py-class docutils literal notranslate"><span class="pre">Rounded</span></code></a> também são sinalizados.</p>
</dd></dl>

<dl class="py class">
<dt id="decimal.Rounded">
<em class="property">class </em><code class="sig-prename descclassname">decimal.</code><code class="sig-name descname">Rounded</code><a class="headerlink" href="#decimal.Rounded" title="Link permanente para esta definição">¶</a></dt>
<dd><p>O arredondamento ocorreu, embora possivelmente nenhuma informação tenha sido perdida.</p>
<p>Sinalizado sempre que o arredondamento descarta dígitos; mesmo que esses dígitos sejam zero (como arredondamento <code class="xref py py-const docutils literal notranslate"><span class="pre">5.00</span></code> a <code class="xref py py-const docutils literal notranslate"><span class="pre">5.0</span></code>). Se não for capturado, retorna o resultado inalterado. Este sinal é usado para detectar a perda de dígitos significativos.</p>
</dd></dl>

<dl class="py class">
<dt id="decimal.Subnormal">
<em class="property">class </em><code class="sig-prename descclassname">decimal.</code><code class="sig-name descname">Subnormal</code><a class="headerlink" href="#decimal.Subnormal" title="Link permanente para esta definição">¶</a></dt>
<dd><p>O expoente foi menor que <code class="xref py py-attr docutils literal notranslate"><span class="pre">Emin</span></code> antes do arredondamento.</p>
<p>Ocorre quando um resultado da operação é subnormal (o expoente é muito pequeno). Se não for capturado, retorna o resultado inalterado.</p>
</dd></dl>

<dl class="py class">
<dt id="decimal.Underflow">
<em class="property">class </em><code class="sig-prename descclassname">decimal.</code><code class="sig-name descname">Underflow</code><a class="headerlink" href="#decimal.Underflow" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Estouro negativo numérico com resultado arredondado para zero.</p>
<p>Ocorre quando um resultado subnormal é empurrado para zero arredondando. <a class="reference internal" href="#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-class docutils literal notranslate"><span class="pre">Inexact</span></code></a> e <a class="reference internal" href="#decimal.Subnormal" title="decimal.Subnormal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Subnormal</span></code></a> também são sinalizados.</p>
</dd></dl>

<dl class="py class">
<dt id="decimal.FloatOperation">
<em class="property">class </em><code class="sig-prename descclassname">decimal.</code><code class="sig-name descname">FloatOperation</code><a class="headerlink" href="#decimal.FloatOperation" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Ativa semânticas mais rigorosas para misturar objetos de float com de Decimal.</p>
<p>Se o sinal não for capturado (padrão), a mistura de tipos float e Decimal será permitida no construtor <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a>, <a class="reference internal" href="#decimal.Context.create_decimal" title="decimal.Context.create_decimal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_decimal()</span></code></a> e em todos os operadores de comparação. Tanto a conversão quanto as comparações são exatas. Qualquer ocorrência de uma operação mista é registrada silenciosamente pela configuração <a class="reference internal" href="#decimal.FloatOperation" title="decimal.FloatOperation"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FloatOperation</span></code></a> nos sinalizadores de contexto. Conversões explícitas com <a class="reference internal" href="#decimal.Decimal.from_float" title="decimal.Decimal.from_float"><code class="xref py py-meth docutils literal notranslate"><span class="pre">from_float()</span></code></a> ou <a class="reference internal" href="#decimal.Context.create_decimal_from_float" title="decimal.Context.create_decimal_from_float"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_decimal_from_float()</span></code></a> não definem o sinalizador.</p>
<p>Caso contrário (o sinal é capturado), apenas comparações de igualdade e conversões explícitas são silenciosas. Todas as outras operações mistas levantam <a class="reference internal" href="#decimal.FloatOperation" title="decimal.FloatOperation"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FloatOperation</span></code></a>.</p>
</dd></dl>

<p>A tabela a seguir resume a hierarquia de sinais:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">exceptions</span><span class="o">.</span><span class="n">ArithmeticError</span><span class="p">(</span><span class="n">exceptions</span><span class="o">.</span><span class="n">Exception</span><span class="p">)</span>
    <span class="n">DecimalException</span>
        <span class="n">Clamped</span>
        <span class="n">DivisionByZero</span><span class="p">(</span><span class="n">DecimalException</span><span class="p">,</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">ZeroDivisionError</span><span class="p">)</span>
        <span class="n">Inexact</span>
            <span class="n">Overflow</span><span class="p">(</span><span class="n">Inexact</span><span class="p">,</span> <span class="n">Rounded</span><span class="p">)</span>
            <span class="n">Underflow</span><span class="p">(</span><span class="n">Inexact</span><span class="p">,</span> <span class="n">Rounded</span><span class="p">,</span> <span class="n">Subnormal</span><span class="p">)</span>
        <span class="n">InvalidOperation</span>
        <span class="n">Rounded</span>
        <span class="n">Subnormal</span>
        <span class="n">FloatOperation</span><span class="p">(</span><span class="n">DecimalException</span><span class="p">,</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">TypeError</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="floating-point-notes">
<span id="decimal-notes"></span><h2>Observações sobre ponto flutuante<a class="headerlink" href="#floating-point-notes" title="Link permanente para este título">¶</a></h2>
<section id="mitigating-round-off-error-with-increased-precision">
<h3>Atenuando o erro de arredondamento com maior precisão<a class="headerlink" href="#mitigating-round-off-error-with-increased-precision" title="Link permanente para este título">¶</a></h3>
<p>O uso do ponto flutuante decimal elimina o erro de representação decimal (possibilitando representar <code class="xref py py-const docutils literal notranslate"><span class="pre">0.1</span></code> de forma exata); no entanto, algumas operações ainda podem sofrer erros de arredondamento quando dígitos diferentes de zero excederem a precisão fixa.</p>
<p>Os efeitos do erro de arredondamento podem ser amplificados pela adição ou subtração de quantidades quase compensadoras, resultando em perda de significância. Knuth fornece dois exemplos instrutivos em que a aritmética de ponto flutuante arredondado com precisão insuficiente causa a quebra das propriedades associativas e distributivas da adição:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="go"># Examples from Seminumerical Algorithms, Section 4.2.2.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">decimal</span> <span class="kn">import</span> <span class="n">Decimal</span><span class="p">,</span> <span class="n">getcontext</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">8</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">11111113</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="o">-</span><span class="mi">11111111</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;7.51111111&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span> <span class="o">+</span> <span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="n">w</span>
<span class="go">Decimal(&#39;9.5111111&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">+</span> <span class="p">(</span><span class="n">v</span> <span class="o">+</span> <span class="n">w</span><span class="p">)</span>
<span class="go">Decimal(&#39;10&#39;)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">20000</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="o">-</span><span class="mi">6</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;6.0000003&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span><span class="o">*</span><span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">u</span><span class="o">*</span><span class="n">w</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.01&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">*</span> <span class="p">(</span><span class="n">v</span><span class="o">+</span><span class="n">w</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.0060000&#39;)</span>
</pre></div>
</div>
<p>O módulo <a class="reference internal" href="#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic  Specification."><code class="xref py py-mod docutils literal notranslate"><span class="pre">decimal</span></code></a> permite restaurar as identidades expandindo a precisão o suficiente para evitar perda de significância:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">11111113</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="o">-</span><span class="mi">11111111</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;7.51111111&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span> <span class="o">+</span> <span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="n">w</span>
<span class="go">Decimal(&#39;9.51111111&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">+</span> <span class="p">(</span><span class="n">v</span> <span class="o">+</span> <span class="n">w</span><span class="p">)</span>
<span class="go">Decimal(&#39;9.51111111&#39;)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">20000</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="o">-</span><span class="mi">6</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;6.0000003&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span><span class="o">*</span><span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">u</span><span class="o">*</span><span class="n">w</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.0060000&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">*</span> <span class="p">(</span><span class="n">v</span><span class="o">+</span><span class="n">w</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.0060000&#39;)</span>
</pre></div>
</div>
</section>
<section id="special-values">
<h3>Valores especiais<a class="headerlink" href="#special-values" title="Link permanente para este título">¶</a></h3>
<p>O sistema numérico para o módulo <a class="reference internal" href="#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic  Specification."><code class="xref py py-mod docutils literal notranslate"><span class="pre">decimal</span></code></a> fornece valores especiais, incluindo <code class="xref py py-const docutils literal notranslate"><span class="pre">NaN</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">sNaN</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">-Infinity</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">Infinity</span></code> e dois zeros, <code class="xref py py-const docutils literal notranslate"><span class="pre">+0</span></code> e <code class="xref py py-const docutils literal notranslate"><span class="pre">-0</span></code>.</p>
<p>Os infinitos podem ser construídos diretamente com: <code class="docutils literal notranslate"><span class="pre">Decimal('Infinity')</span></code>. Além disso, eles podem resultar da divisão por zero quando o sinal <a class="reference internal" href="#decimal.DivisionByZero" title="decimal.DivisionByZero"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DivisionByZero</span></code></a> não é capturado. Da mesma forma, quando o sinal <a class="reference internal" href="#decimal.Overflow" title="decimal.Overflow"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Overflow</span></code></a> não é capturado, o infinito pode resultar do arredondamento além dos limites do maior número representável.</p>
<p>Os infinitos contêm sinais (afins) e podem ser usados em operações aritméticas, onde são tratados como números muito grandes e indeterminados. Por exemplo, adicionar uma constante ao infinito fornece outro resultado infinito.</p>
<p>Algumas operações são indeterminadas e retornam <code class="xref py py-const docutils literal notranslate"><span class="pre">NaN</span></code> ou, se o sinal <a class="reference internal" href="#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-exc docutils literal notranslate"><span class="pre">InvalidOperation</span></code></a> for capturado, levanta uma exceção. Por exemplo, <code class="docutils literal notranslate"><span class="pre">0/0</span></code> retorna <code class="xref py py-const docutils literal notranslate"><span class="pre">NaN</span></code>, que significa “não é um número” em inglês. Esta variação de <code class="xref py py-const docutils literal notranslate"><span class="pre">NaN</span></code> é silenciosa e, uma vez criada, fluirá através de outros cálculos sempre resultando em outra <code class="xref py py-const docutils literal notranslate"><span class="pre">NaN</span></code>. Esse comportamento pode ser útil para uma série de cálculos que ocasionalmente têm entradas ausentes — ele permite que o cálculo continue enquanto sinaliza resultados específicos como inválidos.</p>
<p>Uma variante é <code class="xref py py-const docutils literal notranslate"><span class="pre">sNaN</span></code>, que sinaliza em vez de permanecer em silêncio após cada operação. Esse é um valor de retorno útil quando um resultado inválido precisa interromper um cálculo para tratamento especial.</p>
<p>O comportamento dos operadores de comparação do Python pode ser um pouco surpreendente onde um <code class="xref py py-const docutils literal notranslate"><span class="pre">NaN</span></code> está envolvido. Um teste de igualdade em que um dos operandos é um <code class="xref py py-const docutils literal notranslate"><span class="pre">NaN</span></code> silencioso ou sinalizador sempre retorna <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> (mesmo ao fazer <code class="docutils literal notranslate"><span class="pre">Decimal('NaN')==Decimal('NaN')</span></code>), enquanto um teste de desigualdade sempre retorna <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>. Uma tentativa de comparar dois decimais usando qualquer um dos operadores <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> ou <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code> levantará o sinal <a class="reference internal" href="#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-exc docutils literal notranslate"><span class="pre">InvalidOperation</span></code></a> se um dos operandos for um <code class="xref py py-const docutils literal notranslate"><span class="pre">NaN</span></code> e retorna <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> se esse sinal não for capturado. Observe que a especificação aritmética decimal geral não especifica o comportamento das comparações diretas; estas regras para comparações envolvendo a <code class="xref py py-const docutils literal notranslate"><span class="pre">NaN</span></code> foram retiradas do padrão IEEE 854 (consulte a Tabela 3 na seção 5.7). Para garantir uma rígida conformidade com os padrões, use os métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">compare()</span></code> e <code class="xref py py-meth docutils literal notranslate"><span class="pre">compare-signal()</span></code>.</p>
<p>Os zeros com sinais podem resultar de cálculos insuficientes. Eles mantêm o sinal que teria resultado se o cálculo tivesse sido realizado com maior precisão. Como sua magnitude é zero, os zeros positivos e negativos são tratados como iguais e seu sinal é informacional.</p>
<p>Além dos dois zeros com sinais que são distintos e iguais, existem várias representações de zero com diferentes precisões e ainda com valor equivalente. Isso leva um pouco de tempo para se acostumar. Para um olho acostumado a representações de ponto flutuante normalizadas, não é imediatamente óbvio que o seguinte cálculo retorne um valor igual a zero:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">1</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;Infinity&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;0E-1000026&#39;)</span>
</pre></div>
</div>
</section>
</section>
<section id="working-with-threads">
<span id="decimal-threads"></span><h2>Trabalhando com threads<a class="headerlink" href="#working-with-threads" title="Link permanente para este título">¶</a></h2>
<p>A função <a class="reference internal" href="#decimal.getcontext" title="decimal.getcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">getcontext()</span></code></a> acessa um objeto <a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a> diferente para cada thread. Ter contextos de threads separadas significa que as threads podem fazer alterações (como <code class="docutils literal notranslate"><span class="pre">getcontext().prec=10</span></code>) sem interferir em outras threads.</p>
<p>Da mesma forma, a função <a class="reference internal" href="#decimal.setcontext" title="decimal.setcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">setcontext()</span></code></a> atribui automaticamente seu alvo à thread atual.</p>
<p>Se <a class="reference internal" href="#decimal.setcontext" title="decimal.setcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">setcontext()</span></code></a> não tiver sido chamado antes de <a class="reference internal" href="#decimal.getcontext" title="decimal.getcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">getcontext()</span></code></a>, então <a class="reference internal" href="#decimal.getcontext" title="decimal.getcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">getcontext()</span></code></a> criará automaticamente um novo contexto para uso na thread atual.</p>
<p>O novo contexto é copiado de um contexto protótipo chamado <em>DefaultContext</em>. Para controlar os padrões para que cada thread, use os mesmos valores em todo o aplicativo, modifique diretamente o objeto <em>DefaultContext</em>. Isso deve ser feito <em>antes</em> de qualquer thread ser iniciada, para que não haja uma condição de corrida entre as threads chamando <a class="reference internal" href="#decimal.getcontext" title="decimal.getcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">getcontext()</span></code></a>. Por exemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set applicationwide defaults for all threads about to be launched</span>
<span class="n">DefaultContext</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">12</span>
<span class="n">DefaultContext</span><span class="o">.</span><span class="n">rounding</span> <span class="o">=</span> <span class="n">ROUND_DOWN</span>
<span class="n">DefaultContext</span><span class="o">.</span><span class="n">traps</span> <span class="o">=</span> <span class="n">ExtendedContext</span><span class="o">.</span><span class="n">traps</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">DefaultContext</span><span class="o">.</span><span class="n">traps</span><span class="p">[</span><span class="n">InvalidOperation</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">setcontext</span><span class="p">(</span><span class="n">DefaultContext</span><span class="p">)</span>

<span class="c1"># Afterwards, the threads can be started</span>
<span class="n">t1</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">t2</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">t3</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
 <span class="o">.</span> <span class="o">.</span> <span class="o">.</span>
</pre></div>
</div>
</section>
<section id="recipes">
<span id="decimal-recipes"></span><h2>Receitas<a class="headerlink" href="#recipes" title="Link permanente para este título">¶</a></h2>
<p>Aqui estão algumas receitas que servem como funções utilitárias e que demonstram maneiras de trabalhar com a classe <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">moneyfmt</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">places</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">curr</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="n">dp</span><span class="o">=</span><span class="s1">&#39;.&#39;</span><span class="p">,</span>
             <span class="n">pos</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">neg</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">trailneg</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert Decimal to a money formatted string.</span>

<span class="sd">    places:  required number of places after the decimal point</span>
<span class="sd">    curr:    optional currency symbol before the sign (may be blank)</span>
<span class="sd">    sep:     optional grouping separator (comma, period, space, or blank)</span>
<span class="sd">    dp:      decimal point indicator (comma or period)</span>
<span class="sd">             only specify as blank when places is zero</span>
<span class="sd">    pos:     optional sign for positive numbers: &#39;+&#39;, space or blank</span>
<span class="sd">    neg:     optional sign for negative numbers: &#39;-&#39;, &#39;(&#39;, space or blank</span>
<span class="sd">    trailneg:optional trailing minus indicator:  &#39;-&#39;, &#39;)&#39;, space or blank</span>

<span class="sd">    &gt;&gt;&gt; d = Decimal(&#39;-1234567.8901&#39;)</span>
<span class="sd">    &gt;&gt;&gt; moneyfmt(d, curr=&#39;$&#39;)</span>
<span class="sd">    &#39;-$1,234,567.89&#39;</span>
<span class="sd">    &gt;&gt;&gt; moneyfmt(d, places=0, sep=&#39;.&#39;, dp=&#39;&#39;, neg=&#39;&#39;, trailneg=&#39;-&#39;)</span>
<span class="sd">    &#39;1.234.568-&#39;</span>
<span class="sd">    &gt;&gt;&gt; moneyfmt(d, curr=&#39;$&#39;, neg=&#39;(&#39;, trailneg=&#39;)&#39;)</span>
<span class="sd">    &#39;($1,234,567.89)&#39;</span>
<span class="sd">    &gt;&gt;&gt; moneyfmt(Decimal(123456789), sep=&#39; &#39;)</span>
<span class="sd">    &#39;123 456 789.00&#39;</span>
<span class="sd">    &gt;&gt;&gt; moneyfmt(Decimal(&#39;-0.02&#39;), neg=&#39;&lt;&#39;, trailneg=&#39;&gt;&#39;)</span>
<span class="sd">    &#39;&lt;0.02&gt;&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">**</span> <span class="o">-</span><span class="n">places</span>      <span class="c1"># 2 places --&gt; &#39;0.01&#39;</span>
    <span class="n">sign</span><span class="p">,</span> <span class="n">digits</span><span class="p">,</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">.</span><span class="n">as_tuple</span><span class="p">()</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">digits</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">digits</span><span class="p">))</span>
    <span class="n">build</span><span class="p">,</span> <span class="nb">next</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">,</span> <span class="n">digits</span><span class="o">.</span><span class="n">pop</span>
    <span class="k">if</span> <span class="n">sign</span><span class="p">:</span>
        <span class="n">build</span><span class="p">(</span><span class="n">trailneg</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">places</span><span class="p">):</span>
        <span class="n">build</span><span class="p">(</span><span class="nb">next</span><span class="p">()</span> <span class="k">if</span> <span class="n">digits</span> <span class="k">else</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">places</span><span class="p">:</span>
        <span class="n">build</span><span class="p">(</span><span class="n">dp</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">digits</span><span class="p">:</span>
        <span class="n">build</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">digits</span><span class="p">:</span>
        <span class="n">build</span><span class="p">(</span><span class="nb">next</span><span class="p">())</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">digits</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">build</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
    <span class="n">build</span><span class="p">(</span><span class="n">curr</span><span class="p">)</span>
    <span class="n">build</span><span class="p">(</span><span class="n">neg</span> <span class="k">if</span> <span class="n">sign</span> <span class="k">else</span> <span class="n">pos</span><span class="p">)</span>
    <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">pi</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Compute Pi to the current precision.</span>

<span class="sd">    &gt;&gt;&gt; print(pi())</span>
<span class="sd">    3.141592653589793238462643383</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">+=</span> <span class="mi">2</span>  <span class="c1"># extra digits for intermediate steps</span>
    <span class="n">three</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>      <span class="c1"># substitute &quot;three=3.0&quot; for regular floats</span>
    <span class="n">lasts</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">na</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">da</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">three</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">24</span>
    <span class="k">while</span> <span class="n">s</span> <span class="o">!=</span> <span class="n">lasts</span><span class="p">:</span>
        <span class="n">lasts</span> <span class="o">=</span> <span class="n">s</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">na</span> <span class="o">=</span> <span class="n">n</span><span class="o">+</span><span class="n">na</span><span class="p">,</span> <span class="n">na</span><span class="o">+</span><span class="mi">8</span>
        <span class="n">d</span><span class="p">,</span> <span class="n">da</span> <span class="o">=</span> <span class="n">d</span><span class="o">+</span><span class="n">da</span><span class="p">,</span> <span class="n">da</span><span class="o">+</span><span class="mi">32</span>
        <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="n">d</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">t</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">-=</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="o">+</span><span class="n">s</span>               <span class="c1"># unary plus applies the new precision</span>

<span class="k">def</span> <span class="nf">exp</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return e raised to the power of x.  Result type matches input type.</span>

<span class="sd">    &gt;&gt;&gt; print(exp(Decimal(1)))</span>
<span class="sd">    2.718281828459045235360287471</span>
<span class="sd">    &gt;&gt;&gt; print(exp(Decimal(2)))</span>
<span class="sd">    7.389056098930650227230427461</span>
<span class="sd">    &gt;&gt;&gt; print(exp(2.0))</span>
<span class="sd">    7.38905609893</span>
<span class="sd">    &gt;&gt;&gt; print(exp(2+0j))</span>
<span class="sd">    (7.38905609893+0j)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">+=</span> <span class="mi">2</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">lasts</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">fact</span><span class="p">,</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">s</span> <span class="o">!=</span> <span class="n">lasts</span><span class="p">:</span>
        <span class="n">lasts</span> <span class="o">=</span> <span class="n">s</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">fact</span> <span class="o">*=</span> <span class="n">i</span>
        <span class="n">num</span> <span class="o">*=</span> <span class="n">x</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">num</span> <span class="o">/</span> <span class="n">fact</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">-=</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="o">+</span><span class="n">s</span>

<span class="k">def</span> <span class="nf">cos</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the cosine of x as measured in radians.</span>

<span class="sd">    The Taylor series approximation works best for a small value of x.</span>
<span class="sd">    For larger values, first compute x = x % (2 * pi).</span>

<span class="sd">    &gt;&gt;&gt; print(cos(Decimal(&#39;0.5&#39;)))</span>
<span class="sd">    0.8775825618903727161162815826</span>
<span class="sd">    &gt;&gt;&gt; print(cos(0.5))</span>
<span class="sd">    0.87758256189</span>
<span class="sd">    &gt;&gt;&gt; print(cos(0.5+0j))</span>
<span class="sd">    (0.87758256189+0j)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">+=</span> <span class="mi">2</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">lasts</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">fact</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">sign</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">s</span> <span class="o">!=</span> <span class="n">lasts</span><span class="p">:</span>
        <span class="n">lasts</span> <span class="o">=</span> <span class="n">s</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span>
        <span class="n">fact</span> <span class="o">*=</span> <span class="n">i</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">num</span> <span class="o">*=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
        <span class="n">sign</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">num</span> <span class="o">/</span> <span class="n">fact</span> <span class="o">*</span> <span class="n">sign</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">-=</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="o">+</span><span class="n">s</span>

<span class="k">def</span> <span class="nf">sin</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the sine of x as measured in radians.</span>

<span class="sd">    The Taylor series approximation works best for a small value of x.</span>
<span class="sd">    For larger values, first compute x = x % (2 * pi).</span>

<span class="sd">    &gt;&gt;&gt; print(sin(Decimal(&#39;0.5&#39;)))</span>
<span class="sd">    0.4794255386042030002732879352</span>
<span class="sd">    &gt;&gt;&gt; print(sin(0.5))</span>
<span class="sd">    0.479425538604</span>
<span class="sd">    &gt;&gt;&gt; print(sin(0.5+0j))</span>
<span class="sd">    (0.479425538604+0j)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">+=</span> <span class="mi">2</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">lasts</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">fact</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">sign</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">s</span> <span class="o">!=</span> <span class="n">lasts</span><span class="p">:</span>
        <span class="n">lasts</span> <span class="o">=</span> <span class="n">s</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span>
        <span class="n">fact</span> <span class="o">*=</span> <span class="n">i</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">num</span> <span class="o">*=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
        <span class="n">sign</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">num</span> <span class="o">/</span> <span class="n">fact</span> <span class="o">*</span> <span class="n">sign</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">-=</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="o">+</span><span class="n">s</span>
</pre></div>
</div>
</section>
<section id="decimal-faq">
<span id="id1"></span><h2>Perguntas Frequentes sobre Decimal<a class="headerlink" href="#decimal-faq" title="Link permanente para este título">¶</a></h2>
<p>P. É complicado digitar <code class="docutils literal notranslate"><span class="pre">decimal.Decimal('1234.5')</span></code>. Existe uma maneira de minimizar a digitação ao usar o interpretador interativo?</p>
<p>R. Alguns usuários abreviam o construtor para apenas uma única letra:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span><span class="p">(</span><span class="s1">&#39;1.23&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">D</span><span class="p">(</span><span class="s1">&#39;3.45&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;4.68&#39;)</span>
</pre></div>
</div>
<p>P. Em uma aplicação de ponto fixo com duas casas decimais, algumas entradas têm muitas casas e precisam ser arredondadas. Outros não devem ter dígitos em excesso e precisam ser validados. Quais métodos devem ser usados?</p>
<p>R. O método <code class="xref py py-meth docutils literal notranslate"><span class="pre">quantize()</span></code> arredonda para um número fixo de casas decimais. Se a armadilha <a class="reference internal" href="#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-const docutils literal notranslate"><span class="pre">Inexact</span></code></a> estiver configurada, também será útil para validação:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">TWOPLACES</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">**</span> <span class="o">-</span><span class="mi">2</span>       <span class="c1"># same as Decimal(&#39;0.01&#39;)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Round to two places</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.214&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">TWOPLACES</span><span class="p">)</span>
<span class="go">Decimal(&#39;3.21&#39;)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Validate that a number does not exceed two places</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.21&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">TWOPLACES</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="n">Context</span><span class="p">(</span><span class="n">traps</span><span class="o">=</span><span class="p">[</span><span class="n">Inexact</span><span class="p">]))</span>
<span class="go">Decimal(&#39;3.21&#39;)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.214&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">TWOPLACES</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="n">Context</span><span class="p">(</span><span class="n">traps</span><span class="o">=</span><span class="p">[</span><span class="n">Inexact</span><span class="p">]))</span>
<span class="gt">Traceback (most recent call last):</span>
   <span class="c">...</span>
<span class="gr">Inexact</span>: <span class="n">None</span>
</pre></div>
</div>
<p>P. Depois de validar entradas de duas casas, como mantenho essa invariável em uma aplicação?</p>
<p>R. Algumas operações como adição, subtração e multiplicação por um número inteiro preservam automaticamente o ponto fixo. Outras operações, como divisão e multiplicação não inteira, alteram o número de casas decimais e precisam ser seguidas com uma etapa <code class="xref py py-meth docutils literal notranslate"><span class="pre">quantize()</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;102.72&#39;</span><span class="p">)</span>           <span class="c1"># Initial fixed-point values</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.17&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span>                           <span class="c1"># Addition preserves fixed-point</span>
<span class="go">Decimal(&#39;105.89&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span>
<span class="go">Decimal(&#39;99.55&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">*</span> <span class="mi">42</span>                          <span class="c1"># So does integer multiplication</span>
<span class="go">Decimal(&#39;4314.24&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">TWOPLACES</span><span class="p">)</span>     <span class="c1"># Must quantize non-integer multiplication</span>
<span class="go">Decimal(&#39;325.62&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">b</span> <span class="o">/</span> <span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">TWOPLACES</span><span class="p">)</span>     <span class="c1"># And quantize division</span>
<span class="go">Decimal(&#39;0.03&#39;)</span>
</pre></div>
</div>
<p>No desenvolvimento de aplicativos de ponto fixo, é conveniente definir funções para lidar com a etapa <code class="xref py py-meth docutils literal notranslate"><span class="pre">quantize()</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">mul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fp</span><span class="o">=</span><span class="n">TWOPLACES</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">div</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fp</span><span class="o">=</span><span class="n">TWOPLACES</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mul</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>                       <span class="c1"># Automatically preserve fixed-point</span>
<span class="go">Decimal(&#39;325.62&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">div</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.03&#39;)</span>
</pre></div>
</div>
<p>P. Existem várias maneiras de expressar o mesmo valor. Os números <code class="xref py py-const docutils literal notranslate"><span class="pre">200</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">200.000</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">2E2</span></code> e <code class="xref py py-const docutils literal notranslate"><span class="pre">02E+4</span></code> têm todos o mesmo valor em várias precisões. Existe uma maneira de transformá-los em um único valor canônico reconhecível?</p>
<p>R. O método <code class="xref py py-meth docutils literal notranslate"><span class="pre">normalize()</span></code> mapeia todos os valores equivalentes para um único representativo:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Decimal</span><span class="p">,</span> <span class="s1">&#39;200 200.000 2E2 .02E+4&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>
<span class="go">[Decimal(&#39;2E+2&#39;), Decimal(&#39;2E+2&#39;), Decimal(&#39;2E+2&#39;), Decimal(&#39;2E+2&#39;)]</span>
</pre></div>
</div>
<p>P. Alguns valores decimais sempre são exibidas com notação exponencial. Existe uma maneira de obter uma representação não exponencial?</p>
<p>R. Para alguns valores, a notação exponencial é a única maneira de expressar o número de casas significativas no coeficiente. Por exemplo, expressar <code class="xref py py-const docutils literal notranslate"><span class="pre">5.0E+3</span></code> como <code class="xref py py-const docutils literal notranslate"><span class="pre">5000</span></code> mantém o valor constante, mas não pode mostrar a significância de duas casa do original.</p>
<p>Se uma aplicação não se importa com o rastreamento da significância, é fácil remover o expoente e os zeros à direita, perdendo a significância, mas mantendo o valor inalterado:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">remove_exponent</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="n">d</span><span class="o">.</span><span class="n">to_integral</span><span class="p">()</span> <span class="k">else</span> <span class="n">d</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">remove_exponent</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;5E+3&#39;</span><span class="p">))</span>
<span class="go">Decimal(&#39;5000&#39;)</span>
</pre></div>
</div>
<p>P. Existe uma maneira de converter um float comum em um <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a>?</p>
<p>R. Sim, qualquer número de ponto flutuante binário pode ser expresso exatamente como um Decimal, embora uma conversão exata possa exigir mais precisão do que a intuição sugere:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="go">Decimal(&#39;3.141592653589793115997963468544185161590576171875&#39;)</span>
</pre></div>
</div>
<p>P. Em um cálculo complexo, como posso ter certeza de que não obtive um resultado falso devido à precisão insuficiente ou a anomalias de arredondamento.</p>
<p>R. O módulo decimal facilita o teste de resultados. Uma prática recomendada é executar novamente os cálculos usando maior precisão e com vários modos de arredondamento. Resultados amplamente diferentes indicam precisão insuficiente, problemas no modo de arredondamento, entradas mal condicionadas ou um algoritmo numericamente instável.</p>
<p>P. Notei que a precisão do contexto é aplicada aos resultados das operações, mas não às entradas. Há algo a observar ao misturar valores de diferentes precisões?</p>
<p>R. Sim. O princípio é que todos os valores são considerados exatos, assim como a aritmética desses valores. Somente os resultados são arredondados. A vantagem das entradas é que “o que você vê é o que você obtém”. Uma desvantagem é que os resultados podem parecer estranhos se você esquecer que as entradas não foram arredondadas:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.104&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;2.104&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;5.21&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.104&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;0.000&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;2.104&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;5.20&#39;)</span>
</pre></div>
</div>
<p>A solução é aumentar a precisão ou forçar o arredondamento das entradas usando a operação unária de mais:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">+</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;1.23456789&#39;</span><span class="p">)</span>      <span class="c1"># unary plus triggers rounding</span>
<span class="go">Decimal(&#39;1.23&#39;)</span>
</pre></div>
</div>
<p>Como alternativa, as entradas podem ser arredondadas na criação usando o método <a class="reference internal" href="#decimal.Context.create_decimal" title="decimal.Context.create_decimal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Context.create_decimal()</span></code></a>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">rounding</span><span class="o">=</span><span class="n">ROUND_DOWN</span><span class="p">)</span><span class="o">.</span><span class="n">create_decimal</span><span class="p">(</span><span class="s1">&#39;1.2345678&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;1.2345&#39;)</span>
</pre></div>
</div>
<p>P. A implementação do CPython é rápida para números grandes?</p>
<p>A. Sim. Nas implementações CPython e PyPy3, as versões C/CFFI do módulo decimal integram a biblioteca de alta velocidade <a class="reference external" href="https://www.bytereef.org/mpdecimal/doc/libmpdec/index.html">libmpdec</a> para precisão arbitrária de aritmética de ponto flutuante decimal corretamente arrendondado <a class="footnote-reference brackets" href="#id4" id="id2">1</a>. <code class="docutils literal notranslate"><span class="pre">libmpdec</span></code> usa a <a class="reference external" href="https://pt.wikipedia.org/wiki/Algoritmo_de_Karatsuba">multiplicação de Karatsuba</a> para números com tamanho médio e a <a class="reference external" href="https://en.wikipedia.org/wiki/Discrete_Fourier_transform_(general)#Number-theoryetic_transform">Transformada Numérica de Fourier</a> para números muito grandes.</p>
<p>O contexto deve ser adaptado para uma aritmética exata de precisão arbitrária. <code class="xref py py-attr docutils literal notranslate"><span class="pre">Emin</span></code> e <code class="xref py py-attr docutils literal notranslate"><span class="pre">Emax</span></code> devem sempre ser configurados com os valores máximos, <code class="xref py py-attr docutils literal notranslate"><span class="pre">clamp</span></code> deve sempre ser 0 (o padrão). A configuração de <code class="xref py py-attr docutils literal notranslate"><span class="pre">prec</span></code> requer alguns cuidados.</p>
<p>A abordagem mais fácil para testar a aritmética do bignum é usar o valor máximo para <code class="xref py py-attr docutils literal notranslate"><span class="pre">prec</span></code> também <a class="footnote-reference brackets" href="#id5" id="id3">2</a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">setcontext</span><span class="p">(</span><span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="n">MAX_PREC</span><span class="p">,</span> <span class="n">Emax</span><span class="o">=</span><span class="n">MAX_EMAX</span><span class="p">,</span> <span class="n">Emin</span><span class="o">=</span><span class="n">MIN_EMIN</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">256</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">/</span> <span class="mi">128</span>
<span class="go">Decimal(&#39;904625697166532776746648320380374280103671755200316906558262375061821325312&#39;)</span>
</pre></div>
</div>
<p>Para resultados inexatos, <a class="reference internal" href="#decimal.MAX_PREC" title="decimal.MAX_PREC"><code class="xref py py-attr docutils literal notranslate"><span class="pre">MAX_PREC</span></code></a> é muito grande em plataformas de 64 bits e a memória disponível será insuficiente:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">MemoryError</span>
</pre></div>
</div>
<p>Em sistemas com alocação excessiva (por exemplo, Linux), uma abordagem mais sofisticada é ajustar <code class="xref py py-attr docutils literal notranslate"><span class="pre">prec</span></code> à quantidade de RAM disponível. Suponha que você tenha 8 GB de RAM e espere 10 operandos simultâneos usando no máximo 500 MB cada:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Maximum number of digits for a single operand using 500MB in 8-byte words</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># with 19 digits per word (4-byte and 9 digits for the 32-bit build):</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">maxdigits</span> <span class="o">=</span> <span class="mi">19</span> <span class="o">*</span> <span class="p">((</span><span class="mi">500</span> <span class="o">*</span> <span class="mi">1024</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">//</span> <span class="mi">8</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Check that this works:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="n">maxdigits</span><span class="p">,</span> <span class="n">Emax</span><span class="o">=</span><span class="n">MAX_EMAX</span><span class="p">,</span> <span class="n">Emin</span><span class="o">=</span><span class="n">MIN_EMIN</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">traps</span><span class="p">[</span><span class="n">Inexact</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">setcontext</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Fill the available precision with nines:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">logical_invert</span><span class="p">()</span> <span class="o">*</span> <span class="mi">9</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">getsizeof</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">524288112</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">  decimal.Inexact</span>: <span class="n">[&lt;class &#39;decimal.Inexact&#39;&gt;]</span>
</pre></div>
</div>
<p>Em geral (e especialmente em sistemas sem alocação excessiva), recomenda-se estimar limites ainda mais apertados e definir a armadilha <a class="reference internal" href="#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Inexact</span></code></a> se for esperado que todos os cálculos sejam mais precisos.</p>
<dl class="footnote brackets">
<dt class="label" id="id4"><span class="brackets"><a class="fn-backref" href="#id2">1</a></span></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.3.</span></p>
</div>
</dd>
<dt class="label" id="id5"><span class="brackets"><a class="fn-backref" href="#id3">2</a></span></dt>
<dd><div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.9: </span>Esta abordagem agora funciona para todos os resultados exatos, exceto para potências de números que não sejam inteiros.</p>
</div>
</dd>
</dl>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Tabela de Conteúdo</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">decimal</span></code> — Aritmética de ponto fixo decimal e ponto flutuante</a><ul>
<li><a class="reference internal" href="#quick-start-tutorial">Tutorial de início rápido</a></li>
<li><a class="reference internal" href="#decimal-objects">Objetos de Decimal</a><ul>
<li><a class="reference internal" href="#logical-operands">Operandos lógicos</a></li>
</ul>
</li>
<li><a class="reference internal" href="#context-objects">Objetos de contexto</a></li>
<li><a class="reference internal" href="#constants">Constantes</a></li>
<li><a class="reference internal" href="#rounding-modes">Modos de arredondamento</a></li>
<li><a class="reference internal" href="#signals">Sinais</a></li>
<li><a class="reference internal" href="#floating-point-notes">Observações sobre ponto flutuante</a><ul>
<li><a class="reference internal" href="#mitigating-round-off-error-with-increased-precision">Atenuando o erro de arredondamento com maior precisão</a></li>
<li><a class="reference internal" href="#special-values">Valores especiais</a></li>
</ul>
</li>
<li><a class="reference internal" href="#working-with-threads">Trabalhando com threads</a></li>
<li><a class="reference internal" href="#recipes">Receitas</a></li>
<li><a class="reference internal" href="#decimal-faq">Perguntas Frequentes sobre Decimal</a></li>
</ul>
</li>
</ul>

  <h4>Tópico anterior</h4>
  <p class="topless"><a href="cmath.html"
                        title="capítulo anterior"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cmath</span></code> — Funções matemáticas para números complexos</a></p>
  <h4>Próximo tópico</h4>
  <p class="topless"><a href="fractions.html"
                        title="próximo capítulo"><code class="xref py py-mod docutils literal notranslate"><span class="pre">fractions</span></code> — Rational numbers</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Relatar um erro</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.10/Doc/library/decimal.rst"
            rel="nofollow">Exibir código-fonte
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegação</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice geral"
             >índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="fractions.html" title="fractions — Rational numbers"
             >próximo</a> |</li>
        <li class="right" >
          <a href="cmath.html" title="cmath — Funções matemáticas para números complexos"
             >anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.10.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >A Biblioteca Padrão do Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="numeric.html" >Módulos Matemáticos e Numéricos</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">decimal</span></code> — Aritmética de ponto fixo decimal e ponto flutuante</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Busca rápida" aria-label="Busca rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Direitos autorais</a> 2001-2022, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    Última atualização em jun. 04, 2022.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.4.3.
    </div>

  </body>
</html>