
<!DOCTYPE html>

<html lang="pt_BR">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17: http://docutils.sourceforge.net/" />

    <title>Corrotinas e Tarefas &#8212; documentação Python 3.10.4</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pydoctheme.css?2022.1" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Pesquisar dentro de documentação Python 3.10.4"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="Sobre esses documentos" href="../about.html" />
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Buscar" href="../search.html" />
    <link rel="copyright" title="Direitos autorais" href="../copyright.html" />
    <link rel="next" title="Streams" href="asyncio-stream.html" />
    <link rel="prev" title="asyncio — E/S assíncrona" href="asyncio.html" />
    <link rel="canonical" href="https://docs.python.org/3/library/asyncio-task.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <label for="menuToggler" class="toggler__label">
        <span></span>
    </label>
    <nav class="nav-content" role="navigation">
         <a href="https://www.python.org/" class="nav-logo">
             <img src="../_static/py.svg" alt="Logo"/>
         </a>
        <div class="version_switcher_placeholder"></div>
        <form role="search" class="search" action="../search.html" method="get">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                <path fill-rule="nonzero"
                        d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="#444"></path>
            </svg>
            <input type="text" name="q" aria-label="Busca rápida"/>
            <input type="submit" value="Ir"/>
        </form>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
  <h3><a href="../contents.html">Tabela de Conteúdo</a></h3>
  <ul>
<li><a class="reference internal" href="#">Corrotinas e Tarefas</a><ul>
<li><a class="reference internal" href="#coroutines">Corrotinas</a></li>
<li><a class="reference internal" href="#awaitables">Aguardáveis</a></li>
<li><a class="reference internal" href="#running-an-asyncio-program">Executando um programa asyncio</a></li>
<li><a class="reference internal" href="#creating-tasks">Criando Tarefas</a></li>
<li><a class="reference internal" href="#sleeping">Dormindo</a></li>
<li><a class="reference internal" href="#running-tasks-concurrently">Executando tarefas concorrentemente</a></li>
<li><a class="reference internal" href="#shielding-from-cancellation">Protegendo contra cancelamento</a></li>
<li><a class="reference internal" href="#timeouts">Tempo limite</a></li>
<li><a class="reference internal" href="#waiting-primitives">Primitivas de Espera</a></li>
<li><a class="reference internal" href="#running-in-threads">Executando em Threads</a></li>
<li><a class="reference internal" href="#scheduling-from-other-threads">Agendando a partir de outras Threads</a></li>
<li><a class="reference internal" href="#introspection">Introspecção</a></li>
<li><a class="reference internal" href="#task-object">Objeto Task</a></li>
<li><a class="reference internal" href="#generator-based-coroutines">Corrotinas baseadas em gerador</a></li>
</ul>
</li>
</ul>

  <h4>Tópico anterior</h4>
  <p class="topless"><a href="asyncio.html"
                        title="capítulo anterior"><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code> — E/S assíncrona</a></p>
  <h4>Próximo tópico</h4>
  <p class="topless"><a href="asyncio-stream.html"
                        title="próximo capítulo">Streams</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Relatar um erro</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.10/Doc/library/asyncio-task.rst"
            rel="nofollow">Exibir código-fonte
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegação</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice geral"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="asyncio-stream.html" title="Streams"
             accesskey="N">próximo</a> |</li>
        <li class="right" >
          <a href="asyncio.html" title="asyncio — E/S assíncrona"
             accesskey="P">anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.10.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >A Biblioteca Padrão do Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="ipc.html" >Comunicação em Rede e Interprocesso</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="asyncio.html" accesskey="U"><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code> — E/S assíncrona</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Corrotinas e Tarefas</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Busca rápida" aria-label="Busca rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="coroutines-and-tasks">
<h1>Corrotinas e Tarefas<a class="headerlink" href="#coroutines-and-tasks" title="Link permanente para este título">¶</a></h1>
<p>Esta seção descreve APIs assíncronas de alto nível para trabalhar com corrotinas e tarefas.</p>
<div class="contents local topic" id="sumario">
<ul class="simple">
<li><p><a class="reference internal" href="#coroutines" id="id1">Corrotinas</a></p></li>
<li><p><a class="reference internal" href="#awaitables" id="id2">Aguardáveis</a></p></li>
<li><p><a class="reference internal" href="#running-an-asyncio-program" id="id3">Executando um programa asyncio</a></p></li>
<li><p><a class="reference internal" href="#creating-tasks" id="id4">Criando Tarefas</a></p></li>
<li><p><a class="reference internal" href="#sleeping" id="id5">Dormindo</a></p></li>
<li><p><a class="reference internal" href="#running-tasks-concurrently" id="id6">Executando tarefas concorrentemente</a></p></li>
<li><p><a class="reference internal" href="#shielding-from-cancellation" id="id7">Protegendo contra cancelamento</a></p></li>
<li><p><a class="reference internal" href="#timeouts" id="id8">Tempo limite</a></p></li>
<li><p><a class="reference internal" href="#waiting-primitives" id="id9">Primitivas de Espera</a></p></li>
<li><p><a class="reference internal" href="#running-in-threads" id="id10">Executando em Threads</a></p></li>
<li><p><a class="reference internal" href="#scheduling-from-other-threads" id="id11">Agendando a partir de outras Threads</a></p></li>
<li><p><a class="reference internal" href="#introspection" id="id12">Introspecção</a></p></li>
<li><p><a class="reference internal" href="#task-object" id="id13">Objeto Task</a></p></li>
<li><p><a class="reference internal" href="#generator-based-coroutines" id="id14">Corrotinas baseadas em gerador</a></p></li>
</ul>
</div>
<section id="coroutines">
<span id="coroutine"></span><h2><a class="toc-backref" href="#id1">Corrotinas</a><a class="headerlink" href="#coroutines" title="Link permanente para este título">¶</a></h2>
<p><a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">Coroutines</span></a> declared with the async/await syntax is the
preferred way of writing asyncio applications.  For example, the following
snippet of code prints “hello”, waits 1 second,
and then prints “world”:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;world&#39;</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
<span class="go">hello</span>
<span class="go">world</span>
</pre></div>
</div>
<p>Perceba que simplesmente chamar uma corrotina não irá agendá-la para ser executada:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">main</span><span class="p">()</span>
<span class="go">&lt;coroutine object main at 0x1053bb7c8&gt;</span>
</pre></div>
</div>
<p>Para realmente executar uma corrotina, asyncio fornece três mecanismos principais:</p>
<ul>
<li><p>A função <a class="reference internal" href="#asyncio.run" title="asyncio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.run()</span></code></a> para executar a função “main()” do ponto de entrada no nível mais alto (veja o exemplo acima.)</p></li>
<li><p>Aguardando uma corrotina. O seguinte trecho de código exibirá “hello” após esperar por 1 segundo e, em seguida, exibirá “world” após esperar por <em>outros</em> 2 segundos:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">say_after</span><span class="p">(</span><span class="n">delay</span><span class="p">,</span> <span class="n">what</span><span class="p">):</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">delay</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">what</span><span class="p">)</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;started at </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%X</span><span class="s1">&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">await</span> <span class="n">say_after</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;hello&#39;</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">say_after</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;world&#39;</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;finished at </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%X</span><span class="s1">&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</pre></div>
</div>
<p>Resultado esperado:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">started</span> <span class="n">at</span> <span class="mi">17</span><span class="p">:</span><span class="mi">13</span><span class="p">:</span><span class="mi">52</span>
<span class="n">hello</span>
<span class="n">world</span>
<span class="n">finished</span> <span class="n">at</span> <span class="mi">17</span><span class="p">:</span><span class="mi">13</span><span class="p">:</span><span class="mi">55</span>
</pre></div>
</div>
</li>
<li><p>A função <a class="reference internal" href="#asyncio.create_task" title="asyncio.create_task"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.create_task()</span></code></a> para executar corrotinas concorrentemente como <a class="reference internal" href="#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tasks</span></code></a> asyncio.</p>
<p>Vamos modificar o exemplo acima e executar duas corrotinas <code class="docutils literal notranslate"><span class="pre">say_after</span></code> <em>concorrentemente</em>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">task1</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span>
        <span class="n">say_after</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;hello&#39;</span><span class="p">))</span>

    <span class="n">task2</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span>
        <span class="n">say_after</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;world&#39;</span><span class="p">))</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;started at </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%X</span><span class="s1">&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Wait until both tasks are completed (should take</span>
    <span class="c1"># around 2 seconds.)</span>
    <span class="k">await</span> <span class="n">task1</span>
    <span class="k">await</span> <span class="n">task2</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;finished at </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%X</span><span class="s1">&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Perceba que a saída esperada agora mostra que o trecho de código é executado 1 segundo mais rápido do que antes:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">started</span> <span class="n">at</span> <span class="mi">17</span><span class="p">:</span><span class="mi">14</span><span class="p">:</span><span class="mi">32</span>
<span class="n">hello</span>
<span class="n">world</span>
<span class="n">finished</span> <span class="n">at</span> <span class="mi">17</span><span class="p">:</span><span class="mi">14</span><span class="p">:</span><span class="mi">34</span>
</pre></div>
</div>
</li>
</ul>
</section>
<section id="awaitables">
<span id="asyncio-awaitables"></span><h2><a class="toc-backref" href="#id2">Aguardáveis</a><a class="headerlink" href="#awaitables" title="Link permanente para este título">¶</a></h2>
<p>Dizemos que um objeto é um objeto <strong>aguardável</strong> se ele pode ser usado em uma expressão <a class="reference internal" href="../reference/expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a>. Muitas APIs asyncio são projetadas para aceitar aguardáveis.</p>
<p>Existem três tipos principais de objetos <em>aguardáveis</em>: <strong>corrotinas</strong>, <strong>Tarefas</strong>, e <strong>Futuros</strong>.</p>
<p class="rubric">Corrotinas</p>
<p>Corrotinas Python são <em>aguardáveis</em> e portanto podem ser aguardadas a partir de outras corrotinas:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">nested</span><span class="p">():</span>
    <span class="k">return</span> <span class="mi">42</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># Nothing happens if we just call &quot;nested()&quot;.</span>
    <span class="c1"># A coroutine object is created but not awaited,</span>
    <span class="c1"># so it *won&#39;t run at all*.</span>
    <span class="n">nested</span><span class="p">()</span>

    <span class="c1"># Let&#39;s do it differently now and await it:</span>
    <span class="nb">print</span><span class="p">(</span><span class="k">await</span> <span class="n">nested</span><span class="p">())</span>  <span class="c1"># will print &quot;42&quot;.</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</pre></div>
</div>
<div class="admonition important">
<p class="admonition-title">Importante</p>
<p>Nesta documentação, o termo “corrotina” pode ser usado para dois conceitos intimamente relacionados:</p>
<ul class="simple">
<li><p>uma <em>função de corrotina</em>: uma função <a class="reference internal" href="../reference/compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a>;</p></li>
<li><p>um <em>objeto de corrotina</em>: um objeto retornado ao chamar uma <em>função de corrotina</em>.</p></li>
</ul>
</div>
<p>asyncio também suporta corrotinas legadas <a class="reference internal" href="#asyncio-generator-based-coro"><span class="std std-ref">baseadas em geradores</span></a>.</p>
<p class="rubric">Tarefas</p>
<p><em>Tarefas</em> são usadas para agendar corrotinas <em>concorrentemente</em>.</p>
<p>Quando uma corrotina é envolta em uma <em>tarefa</em> com funções como <a class="reference internal" href="#asyncio.create_task" title="asyncio.create_task"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.create_task()</span></code></a>, a corrotina é automaticamente agendada para executar em breve:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">nested</span><span class="p">():</span>
    <span class="k">return</span> <span class="mi">42</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># Schedule nested() to run soon concurrently</span>
    <span class="c1"># with &quot;main()&quot;.</span>
    <span class="n">task</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">nested</span><span class="p">())</span>

    <span class="c1"># &quot;task&quot; can now be used to cancel &quot;nested()&quot;, or</span>
    <span class="c1"># can simply be awaited to wait until it is complete:</span>
    <span class="k">await</span> <span class="n">task</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</pre></div>
</div>
<p class="rubric">Futuros</p>
<p>Um <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">Future</span></code></a> é um objeto aguardável especial de <strong>baixo nível</strong> que representa um <strong>resultado eventual</strong> de uma operação assíncrona.</p>
<p>Quando um objeto Future é <em>aguardado</em> isso significa que a corrotina irá esperar até que o Future seja resolvido em algum outro local.</p>
<p>Objetos Future em asyncio são necessários para permitir que código baseado em função de retorno seja utilizado com async/await.</p>
<p>Normalmente <strong>não existe necessidade</strong> em criar objetos Future no nível de código da aplicação.</p>
<p>Objetos Future, algumas vezes expostos por bibliotecas e algumas APIs asyncio, podem ser aguardados:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">await</span> <span class="n">function_that_returns_a_future_object</span><span class="p">()</span>

    <span class="c1"># this is also valid:</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span>
        <span class="n">function_that_returns_a_future_object</span><span class="p">(),</span>
        <span class="n">some_python_coroutine</span><span class="p">()</span>
    <span class="p">)</span>
</pre></div>
</div>
<p>Um bom exemplo de uma função de baixo nível que retorna um objeto Future é <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.run_in_executor" title="asyncio.loop.run_in_executor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.run_in_executor()</span></code></a>.</p>
</section>
<section id="running-an-asyncio-program">
<h2><a class="toc-backref" href="#id3">Executando um programa asyncio</a><a class="headerlink" href="#running-an-asyncio-program" title="Link permanente para este título">¶</a></h2>
<dl class="py function">
<dt id="asyncio.run">
<code class="sig-prename descclassname">asyncio.</code><code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">coro</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">debug</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.run" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Executa a <a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">corrotina</span></a> <em>coro</em> e retorna o resultado.</p>
<p>Esta função executa a corrotina passada, tomando cuidado de gerenciar o laço de eventos asyncio, <em>finalizando geradores assíncronos</em>, e encerrando a threadpool.</p>
<p>Esta função não pode ser chamada quando outro laço de eventos asyncio está executando na mesma thread.</p>
<p>Se <em>debug</em> for <code class="docutils literal notranslate"><span class="pre">True</span></code>, o laço de eventos irá ser executado em modo debug.</p>
<p>Esta função sempre cria um novo laço de eventos e fecha-o no final. Ela deve ser usada como um ponto de entrada principal para programas asyncio, e deve idealmente ser chamada apenas uma vez.</p>
<p>Exemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.7.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.9: </span>Atualizado para usar <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.shutdown_default_executor" title="asyncio.loop.shutdown_default_executor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.shutdown_default_executor()</span></code></a>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>O código-fonte para <code class="docutils literal notranslate"><span class="pre">asyncio.run()</span></code> pode ser encontrado em <a class="reference external" href="https://github.com/python/cpython/tree/3.10/Lib/asyncio/runners.py">Lib/asyncio/runners.py</a>.</p>
</div>
</dd></dl>

</section>
<section id="creating-tasks">
<h2><a class="toc-backref" href="#id4">Criando Tarefas</a><a class="headerlink" href="#creating-tasks" title="Link permanente para este título">¶</a></h2>
<dl class="py function">
<dt id="asyncio.create_task">
<code class="sig-prename descclassname">asyncio.</code><code class="sig-name descname">create_task</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">coro</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.create_task" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Envolva a <a class="reference internal" href="#coroutine"><span class="std std-ref">corrotina</span></a> <em>coro</em> em uma <a class="reference internal" href="#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> e agende sua execução. Retorne o objeto Task.</p>
<p>Se <em>name</em> não for <code class="docutils literal notranslate"><span class="pre">None</span></code>, ele é setado como o nome da tarefa usando <a class="reference internal" href="#asyncio.Task.set_name" title="asyncio.Task.set_name"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Task.set_name()</span></code></a>.</p>
<p>A tarefa é executada no laço e retornada por <a class="reference internal" href="asyncio-eventloop.html#asyncio.get_running_loop" title="asyncio.get_running_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_running_loop()</span></code></a>, <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> é levantado se não existir nenhum loop na thread atual.</p>
<div class="admonition important">
<p class="admonition-title">Importante</p>
<p>Save a reference to the result of this function, to avoid
a task disappearing mid execution.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.7.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.8: </span>Added the <em>name</em> parameter.</p>
</div>
</dd></dl>

</section>
<section id="sleeping">
<h2><a class="toc-backref" href="#id5">Dormindo</a><a class="headerlink" href="#sleeping" title="Link permanente para este título">¶</a></h2>
<dl class="py function">
<dt id="asyncio.sleep">
<em class="property">coroutine </em><code class="sig-prename descclassname">asyncio.</code><code class="sig-name descname">sleep</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">delay</span></em>, <em class="sig-param"><span class="n">result</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.sleep" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Bloqueia por <em>delay</em> segundos.</p>
<p>Se <em>result</em> é fornecido, é retornado para o autor da chamada quando a corrotina termina.</p>
<p><code class="docutils literal notranslate"><span class="pre">sleep()</span></code> sempre suspende a tarefa atual, permitindo que outras tarefas sejam executadas.</p>
<p>Configurando o delay para 0 fornece um caminho otimizado para permitir que outras tarefas executem. Isto pode ser usado por funções de longa execução para evitar que bloqueiem o laço de eventos por toda a duração da chamada da função.</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.8, removed in version 3.10: </span>O parâmetro <code class="docutils literal notranslate"><span class="pre">loop</span></code>. Esta função está obtendo implicitamente o loop atual em execução desde 3.7. Veja a <a class="reference internal" href="../whatsnew/3.10.html#whatsnew310-removed"><span class="std std-ref">seção Removidos do O que há de novo no 3.10</span></a> para mais informações.</p>
</div>
<p id="asyncio-example-sleep">Exemplo de uma corrotina exibindo a data atual a cada segundo durante 5 segundos:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">datetime</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">display_date</span><span class="p">():</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>
    <span class="n">end_time</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">+</span> <span class="mf">5.0</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">())</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">loop</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">end_time</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">display_date</span><span class="p">())</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.10: </span>Removed the <em>loop</em> parameter.</p>
</div>
</dd></dl>

</section>
<section id="running-tasks-concurrently">
<h2><a class="toc-backref" href="#id6">Executando tarefas concorrentemente</a><a class="headerlink" href="#running-tasks-concurrently" title="Link permanente para este título">¶</a></h2>
<dl class="py function">
<dt id="asyncio.gather">
<em class="property">awaitable </em><code class="sig-prename descclassname">asyncio.</code><code class="sig-name descname">gather</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">aws</span></em>, <em class="sig-param"><span class="n">return_exceptions</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.gather" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Executa <a class="reference internal" href="#asyncio-awaitables"><span class="std std-ref">objetos aguardáveis</span></a> na sequência <em>aws</em> de forma <em>concorrente</em>.</p>
<p>Se qualquer aguardável em <em>aws</em> é uma corrotina, ele é automaticamente agendado como uma Tarefa.</p>
<p>Se todos os aguardáveis forem concluídos com sucesso, o resultado é uma lista agregada de valores retornados. A ordem dos valores resultantes corresponde a ordem dos aguardáveis em <em>aws</em>.</p>
<p>Se <em>return_exceptions</em> for <code class="docutils literal notranslate"><span class="pre">False</span></code> (valor padrão), a primeira exceção levantada é imediatamente propagada para a tarefa que espera em <code class="docutils literal notranslate"><span class="pre">gather()</span></code>. Outros aguardáveis na sequência <em>aws</em> <strong>não serão cancelados</strong> e irão continuar a executar.</p>
<p>Se <em>return_exceptions</em> for <code class="docutils literal notranslate"><span class="pre">True</span></code>, exceções são tratadas da mesma forma que resultados com sucesso, e agregadas na lista de resultados.</p>
<p>Se <code class="docutils literal notranslate"><span class="pre">gather()</span></code> for <em>cancelado</em>, todos os aguardáveis que foram submetidos (que não foram concluídos ainda) também são <em>cancelados</em>.</p>
<p>Se qualquer Tarefa ou Futuro da sequência <em>aws</em> for <em>cancelado</em>, ele é tratado como se tivesse levantado <a class="reference internal" href="asyncio-exceptions.html#asyncio.CancelledError" title="asyncio.CancelledError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">CancelledError</span></code></a> – a chamada para <code class="docutils literal notranslate"><span class="pre">gather()</span></code> <strong>não</strong> é cancelada neste caso. Isso existe para prevenir que o cancelamento de uma Tarefa/Futuro submetida ocasione outras Tarefas/Futuros a serem cancelados.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.10: </span>Removed the <em>loop</em> parameter.</p>
</div>
<p id="asyncio-example-gather">Exemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">factorial</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">number</span><span class="p">):</span>
    <span class="n">f</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">number</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Task </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">: Compute factorial(</span><span class="si">{</span><span class="n">number</span><span class="si">}</span><span class="s2">), currently i=</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">...&quot;</span><span class="p">)</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">*=</span> <span class="n">i</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Task </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">: factorial(</span><span class="si">{</span><span class="n">number</span><span class="si">}</span><span class="s2">) = </span><span class="si">{</span><span class="n">f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">f</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># Schedule three calls *concurrently*:</span>
    <span class="n">L</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span>
        <span class="n">factorial</span><span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
        <span class="n">factorial</span><span class="p">(</span><span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
        <span class="n">factorial</span><span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>

<span class="c1"># Expected output:</span>
<span class="c1">#</span>
<span class="c1">#     Task A: Compute factorial(2), currently i=2...</span>
<span class="c1">#     Task B: Compute factorial(3), currently i=2...</span>
<span class="c1">#     Task C: Compute factorial(4), currently i=2...</span>
<span class="c1">#     Task A: factorial(2) = 2</span>
<span class="c1">#     Task B: Compute factorial(3), currently i=3...</span>
<span class="c1">#     Task C: Compute factorial(4), currently i=3...</span>
<span class="c1">#     Task B: factorial(3) = 6</span>
<span class="c1">#     Task C: Compute factorial(4), currently i=4...</span>
<span class="c1">#     Task C: factorial(4) = 24</span>
<span class="c1">#     [2, 6, 24]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Se <em>return_exceptions</em> for False, cancelar gather() depois que ele foi marcado como concluído não irá cancelar quaisquer aguardáveis submetidos. Por exemplo, gather pode ser marcado como concluído após propagar uma exceção para o autor da chamada, portanto, chamar <code class="docutils literal notranslate"><span class="pre">gather.cancel()</span></code> após capturar uma exceção (levantada por um dos aguardáveis) a partir de gather não irá cancelar quaisquer outros aguardáveis.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.7: </span>Se <em>gather</em> por si mesmo for cancelado, o cancelamento é propagado independente de <em>return_exceptions</em>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.10: </span>Removed the <em>loop</em> parameter.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde a versão 3.10: </span>Aviso de descontinuidade é emitido se nenhum argumento posicional for fornecido, ou nem todos os argumentos posicionais são objetos similar a Futuro, e não existe nenhum laço de eventos em execução.</p>
</div>
</dd></dl>

</section>
<section id="shielding-from-cancellation">
<h2><a class="toc-backref" href="#id7">Protegendo contra cancelamento</a><a class="headerlink" href="#shielding-from-cancellation" title="Link permanente para este título">¶</a></h2>
<dl class="py function">
<dt id="asyncio.shield">
<em class="property">awaitable </em><code class="sig-prename descclassname">asyncio.</code><code class="sig-name descname">shield</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">aw</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.shield" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Protege um <a class="reference internal" href="#asyncio-awaitables"><span class="std std-ref">objeto aguardável</span></a> de ser <a class="reference internal" href="#asyncio.Task.cancel" title="asyncio.Task.cancel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cancelado</span></code></a>.</p>
<p>Se <em>aw</em> é uma corrotina, ela é automaticamente agendada como uma Tarefa.</p>
<p>A instrução:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">res</span> <span class="o">=</span> <span class="k">await</span> <span class="n">shield</span><span class="p">(</span><span class="n">something</span><span class="p">())</span>
</pre></div>
</div>
<p>é equivalente a:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">res</span> <span class="o">=</span> <span class="k">await</span> <span class="n">something</span><span class="p">()</span>
</pre></div>
</div>
<p><em>exceto</em> que se a corrotina contendo-a for cancelada, a Tarefa executando em <code class="docutils literal notranslate"><span class="pre">something()</span></code> não é cancelada. Do ponto de vista de <code class="docutils literal notranslate"><span class="pre">something()</span></code>, o cancelamento não aconteceu. Apesar do autor da chamada ainda estar cancelado, então a expressão “await” ainda levanta um <a class="reference internal" href="asyncio-exceptions.html#asyncio.CancelledError" title="asyncio.CancelledError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">CancelledError</span></code></a>.</p>
<p>Se <code class="docutils literal notranslate"><span class="pre">something()</span></code> é cancelada por outros meios (isto é, dentro ou a partir de si mesma) isso também iria cancelar <code class="docutils literal notranslate"><span class="pre">shield()</span></code>.</p>
<p>Se for desejado ignorar completamente os cancelamentos (não recomendado) a função <code class="docutils literal notranslate"><span class="pre">shield()</span></code> deve ser combinada com uma cláusula try/except, conforme abaixo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">res</span> <span class="o">=</span> <span class="k">await</span> <span class="n">shield</span><span class="p">(</span><span class="n">something</span><span class="p">())</span>
<span class="k">except</span> <span class="n">CancelledError</span><span class="p">:</span>
    <span class="n">res</span> <span class="o">=</span> <span class="kc">None</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.10: </span>Removed the <em>loop</em> parameter.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde a versão 3.10: </span>Aviso de descontinuidade é emitido se <em>aw</em> não é um objeto similar a Futuro, e não existe nenhum laço de eventos em execução.</p>
</div>
</dd></dl>

</section>
<section id="timeouts">
<h2><a class="toc-backref" href="#id8">Tempo limite</a><a class="headerlink" href="#timeouts" title="Link permanente para este título">¶</a></h2>
<dl class="py function">
<dt id="asyncio.wait_for">
<em class="property">coroutine </em><code class="sig-prename descclassname">asyncio.</code><code class="sig-name descname">wait_for</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">aw</span></em>, <em class="sig-param"><span class="n">timeout</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.wait_for" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Espera o <a class="reference internal" href="#asyncio-awaitables"><span class="std std-ref">aguardável</span></a> <em>aw</em> concluir sem ultrapassar o tempo limite “timeout”.</p>
<p>Se <em>aw</em> é uma corrotina, ela é automaticamente agendada como uma Tarefa.</p>
<p><em>timeout</em> pode ser <code class="docutils literal notranslate"><span class="pre">None</span></code>, ou um ponto flutuante, ou um número inteiro de segundos para aguardar. Se <em>timeout</em> é <code class="docutils literal notranslate"><span class="pre">None</span></code>, aguarda até o future encerrar.</p>
<p>Se o tempo limite timeout for atingido, ele cancela a tarefa e levanta <a class="reference internal" href="asyncio-exceptions.html#asyncio.TimeoutError" title="asyncio.TimeoutError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">asyncio.TimeoutError</span></code></a>.</p>
<p>Para evitar o <a class="reference internal" href="#asyncio.Task.cancel" title="asyncio.Task.cancel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cancelamento</span></code></a> da tarefa, envolva-a com <a class="reference internal" href="#asyncio.shield" title="asyncio.shield"><code class="xref py py-func docutils literal notranslate"><span class="pre">shield()</span></code></a>.</p>
<p>A função irá aguardar até o future ser realmente cancelado, então o tempo total de espera pode exceder o tempo limite <em>timeout</em>. Se uma exceção ocorrer durante o cancelamento, ela será propagada.</p>
<p>Se ele for cancelado, o future <em>aw</em> também é cancelado.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.10: </span>Removed the <em>loop</em> parameter.</p>
</div>
<p id="asyncio-example-waitfor">Exemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">eternity</span><span class="p">():</span>
    <span class="c1"># Sleep for one hour</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">3600</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;yay!&#39;</span><span class="p">)</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># Wait for at most 1 second</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">wait_for</span><span class="p">(</span><span class="n">eternity</span><span class="p">(),</span> <span class="n">timeout</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">TimeoutError</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;timeout!&#39;</span><span class="p">)</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>

<span class="c1"># Expected output:</span>
<span class="c1">#</span>
<span class="c1">#     timeout!</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.7: </span>Quando <em>aw</em> é cancelado devido a um tempo limite, <code class="docutils literal notranslate"><span class="pre">wait_for</span></code> aguarda que <em>aw</em> seja cancelado. Anteriormente, ele levantava <a class="reference internal" href="asyncio-exceptions.html#asyncio.TimeoutError" title="asyncio.TimeoutError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">asyncio.TimeoutError</span></code></a> imediatamente.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.10: </span>Removed the <em>loop</em> parameter.</p>
</div>
</dd></dl>

</section>
<section id="waiting-primitives">
<h2><a class="toc-backref" href="#id9">Primitivas de Espera</a><a class="headerlink" href="#waiting-primitives" title="Link permanente para este título">¶</a></h2>
<dl class="py function">
<dt id="asyncio.wait">
<em class="property">coroutine </em><code class="sig-prename descclassname">asyncio.</code><code class="sig-name descname">wait</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">aws</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">timeout</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">return_when</span><span class="o">=</span><span class="default_value">ALL_COMPLETED</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.wait" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Executa <a class="reference internal" href="#asyncio-awaitables"><span class="std std-ref">objetos aguardáveis</span></a> no iterável <em>aws</em> concorrentemente e bloqueia até que a condição especificada por <em>return_when</em> seja atingida.</p>
<p>O iterável <em>aws</em> não deve ser vazio.</p>
<p>Retorna dois conjuntos de Tarefas/Futuros: <code class="docutils literal notranslate"><span class="pre">(done,</span> <span class="pre">pending)</span></code>.</p>
<p>Uso:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">done</span><span class="p">,</span> <span class="n">pending</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">aws</span><span class="p">)</span>
</pre></div>
</div>
<p><em>timeout</em> (um ponto flutuante ou inteiro), se especificado, pode ser usado para controlar o número máximo de segundos para aguardar antes de retornar.</p>
<p>Perceba que esta função não levanta <a class="reference internal" href="asyncio-exceptions.html#asyncio.TimeoutError" title="asyncio.TimeoutError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">asyncio.TimeoutError</span></code></a>. Futuros ou Tarefas que não estão concluídas quando o tempo limite é excedido são simplesmente retornadas no segundo conjunto.</p>
<p><em>return_when</em> indica quando esta função deve retornar. Ele deve ser uma das seguintes constantes:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 42%" />
<col style="width: 58%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Constante</p></th>
<th class="head"><p>Descrição</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">FIRST_COMPLETED</span></code></p></td>
<td><p>A função irá retornar quando qualquer futuro terminar ou for cancelado.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">FIRST_EXCEPTION</span></code></p></td>
<td><p>A função irá retornar quando qualquer futuro encerrar levantando uma exceção. Se nenhum futuro levantar uma exceção, então é equivalente a <code class="xref py py-const docutils literal notranslate"><span class="pre">ALL_COMPLETED</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">ALL_COMPLETED</span></code></p></td>
<td><p>A função irá retornar quando todos os futuros encerrarem ou forem cancelados.</p></td>
</tr>
</tbody>
</table>
<p>Diferente de <a class="reference internal" href="#asyncio.wait_for" title="asyncio.wait_for"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_for()</span></code></a>, <code class="docutils literal notranslate"><span class="pre">wait()</span></code> não cancela os futuros quando um tempo limite é atingido.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde a versão 3.8: </span>Se qualquer aguardável em <em>aws</em> for uma corrotina, ela é automaticamente agendada como uma tarefa. Passar objetos que são corrotinas para <code class="docutils literal notranslate"><span class="pre">wait()</span></code> diretamente está descontinuado, pois leva a <a class="reference internal" href="#asyncio-example-wait-coroutine"><span class="std std-ref">comportamentos confusos</span></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.10: </span>Removed the <em>loop</em> parameter.</p>
</div>
<div class="admonition note" id="asyncio-example-wait-coroutine">
<p class="admonition-title">Nota</p>
<p><code class="docutils literal notranslate"><span class="pre">wait()</span></code> agenda corrotinas como Tarefas automaticamente e posteriormente retorna esses objetos Tarefas criados implicitamente em conjuntos <code class="docutils literal notranslate"><span class="pre">(done,</span> <span class="pre">pending)</span></code>. Portanto o seguinte código não irá funcionar como esperado:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
    <span class="k">return</span> <span class="mi">42</span>

<span class="n">coro</span> <span class="o">=</span> <span class="n">foo</span><span class="p">()</span>
<span class="n">done</span><span class="p">,</span> <span class="n">pending</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">wait</span><span class="p">({</span><span class="n">coro</span><span class="p">})</span>

<span class="k">if</span> <span class="n">coro</span> <span class="ow">in</span> <span class="n">done</span><span class="p">:</span>
    <span class="c1"># This branch will never be run!</span>
</pre></div>
</div>
<p>Aqui está a forma como o trecho de código acima pode ser consertado:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
    <span class="k">return</span> <span class="mi">42</span>

<span class="n">task</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">foo</span><span class="p">())</span>
<span class="n">done</span><span class="p">,</span> <span class="n">pending</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">wait</span><span class="p">({</span><span class="n">task</span><span class="p">})</span>

<span class="k">if</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">done</span><span class="p">:</span>
    <span class="c1"># Everything will work as expected now.</span>
</pre></div>
</div>
</div>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.8, will be removed in version 3.11: </span>Passar objetos corrotina para <code class="docutils literal notranslate"><span class="pre">wait()</span></code> diretamente foi descontinuado.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.10: </span>Removed the <em>loop</em> parameter.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="asyncio.as_completed">
<code class="sig-prename descclassname">asyncio.</code><code class="sig-name descname">as_completed</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">aws</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">timeout</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.as_completed" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Executa <a class="reference internal" href="#asyncio-awaitables"><span class="std std-ref">objetos aguardáveis</span></a> no iterável <em>aws</em> concorrentemente. Retorna um iterador de corrotinas. Cada corrotina retornada pode ser aguardada para obter o primeiro resultado seguinte a partir do iterável dos aguardáveis restantes.</p>
<p>Levanta <a class="reference internal" href="asyncio-exceptions.html#asyncio.TimeoutError" title="asyncio.TimeoutError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">asyncio.TimeoutError</span></code></a> se o tempo limite ocorrer antes que todos os futuros tenham encerrado.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.10: </span>Removed the <em>loop</em> parameter.</p>
</div>
<p>Exemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">coro</span> <span class="ow">in</span> <span class="n">as_completed</span><span class="p">(</span><span class="n">aws</span><span class="p">):</span>
    <span class="n">earliest_result</span> <span class="o">=</span> <span class="k">await</span> <span class="n">coro</span>
    <span class="c1"># ...</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.10: </span>Removed the <em>loop</em> parameter.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde a versão 3.10: </span>Aviso de descontinuidade é emitido se nem todos os objetos aguardáveis no iterável <em>aws</em> forem objetos similar a Futuro, e não existe nenhum laço de eventos em execução.</p>
</div>
</dd></dl>

</section>
<section id="running-in-threads">
<h2><a class="toc-backref" href="#id10">Executando em Threads</a><a class="headerlink" href="#running-in-threads" title="Link permanente para este título">¶</a></h2>
<dl class="py function">
<dt id="asyncio.to_thread">
<em class="property">coroutine </em><code class="sig-prename descclassname">asyncio.</code><code class="sig-name descname">to_thread</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="o">/</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.to_thread" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Executa a função <em>func</em> assincronamente em uma thread separada.</p>
<p>Quaisquer *args e **kwargs fornecidos para esta função são diretamente passados para <em>func</em>. Além disso, o <a class="reference internal" href="contextvars.html#contextvars.Context" title="contextvars.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextvars.Context</span></code></a> atual é propagado, permitindo que variáveis de contexto da thread do laço de eventos sejam acessadas na thread separada.</p>
<p>Retorna uma corrotina que pode ser aguardada para obter o resultado eventual de <em>func</em>.</p>
<p>Esta função de corrotina é pretendida primariamente para ser usada para execução de funções/métodos vinculados a IO, que poderiam de outra forma bloquear o laço de eventos se eles fossem executados na thread principal. Por exemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">blocking_io</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;start blocking_io at </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%X</span><span class="s1">&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="c1"># Note that time.sleep() can be replaced with any blocking</span>
    <span class="c1"># IO-bound operation, such as file operations.</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;blocking_io complete at </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%X</span><span class="s1">&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;started main at </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%X</span><span class="s1">&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span>
        <span class="n">asyncio</span><span class="o">.</span><span class="n">to_thread</span><span class="p">(</span><span class="n">blocking_io</span><span class="p">),</span>
        <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;finished main at </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%X</span><span class="s1">&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>

<span class="c1"># Expected output:</span>
<span class="c1">#</span>
<span class="c1"># started main at 19:50:53</span>
<span class="c1"># start blocking_io at 19:50:53</span>
<span class="c1"># blocking_io complete at 19:50:54</span>
<span class="c1"># finished main at 19:50:54</span>
</pre></div>
</div>
<p>Chamar diretamente <cite>blocking_io()</cite> em qualquer corrotina iria bloquear o laço de eventos durante a sua duração, resultando em 1 segundo adicional no tempo de execução. Ao invés disso, ao utilizar <cite>asyncio.to_thread()</cite>, nós podemos executá-la em uma thread separada sem bloquear o laço de eventos.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Devido ao <a class="reference internal" href="../glossary.html#term-GIL"><span class="xref std std-term">GIL</span></a>, <cite>asyncio.to_thread()</cite> pode tipicamente ser usado apenas para fazer funções vinculadas a IO não-bloqueantes. Entretanto, para módulos de extensão que liberam o GIL ou implementações alternativas do Python que não tem um, <cite>asyncio.to_thread()</cite> também pode ser usado para funções vinculadas a CPU.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.9.</span></p>
</div>
</dd></dl>

</section>
<section id="scheduling-from-other-threads">
<h2><a class="toc-backref" href="#id11">Agendando a partir de outras Threads</a><a class="headerlink" href="#scheduling-from-other-threads" title="Link permanente para este título">¶</a></h2>
<dl class="py function">
<dt id="asyncio.run_coroutine_threadsafe">
<code class="sig-prename descclassname">asyncio.</code><code class="sig-name descname">run_coroutine_threadsafe</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">coro</span></em>, <em class="sig-param"><span class="n">loop</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.run_coroutine_threadsafe" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Envia uma corrotina para o laço de eventos fornecido. Seguro para thread.</p>
<p>Retorna um <a class="reference internal" href="concurrent.futures.html#concurrent.futures.Future" title="concurrent.futures.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">concurrent.futures.Future</span></code></a> para aguardar pelo resultado de outra thread do sistema operacional.</p>
<p>Esta função destina-se a ser chamada partir de uma thread diferente do sistema operacional, da qual o laço de eventos está executando. Exemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a coroutine</span>
<span class="n">coro</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">result</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

<span class="c1"># Submit the coroutine to a given loop</span>
<span class="n">future</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">run_coroutine_threadsafe</span><span class="p">(</span><span class="n">coro</span><span class="p">,</span> <span class="n">loop</span><span class="p">)</span>

<span class="c1"># Wait for the result with an optional timeout argument</span>
<span class="k">assert</span> <span class="n">future</span><span class="o">.</span><span class="n">result</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
</pre></div>
</div>
<p>Se uma exceção for levantada na corrotina, o Futuro retornado será notificado. Isso também pode ser usado para cancelar a tarefa no laço de eventos:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">future</span><span class="o">.</span><span class="n">result</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span>
<span class="k">except</span> <span class="n">concurrent</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">TimeoutError</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The coroutine took too long, cancelling the task...&#39;</span><span class="p">)</span>
    <span class="n">future</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>
<span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The coroutine raised an exception: </span><span class="si">{</span><span class="n">exc</span><span class="si">!r}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The coroutine returned: </span><span class="si">{</span><span class="n">result</span><span class="si">!r}</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Veja a seção <a class="reference internal" href="asyncio-dev.html#asyncio-multithreading"><span class="std std-ref">concorrência e multithreading</span></a> da documentação.</p>
<p>Ao contrário de outras funções asyncio, esta função requer que o argumento <em>loop</em> seja passado explicitamente.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.5.1.</span></p>
</div>
</dd></dl>

</section>
<section id="introspection">
<h2><a class="toc-backref" href="#id12">Introspecção</a><a class="headerlink" href="#introspection" title="Link permanente para este título">¶</a></h2>
<dl class="py function">
<dt id="asyncio.current_task">
<code class="sig-prename descclassname">asyncio.</code><code class="sig-name descname">current_task</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">loop</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.current_task" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna a instância <a class="reference internal" href="#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> atualmente em execução, ou <code class="docutils literal notranslate"><span class="pre">None</span></code> se nenhuma tarefa estiver executando.</p>
<p>Se <em>loop</em> for <code class="docutils literal notranslate"><span class="pre">None</span></code>, então <a class="reference internal" href="asyncio-eventloop.html#asyncio.get_running_loop" title="asyncio.get_running_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_running_loop()</span></code></a> é usado para obter o laço atual.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.7.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="asyncio.all_tasks">
<code class="sig-prename descclassname">asyncio.</code><code class="sig-name descname">all_tasks</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">loop</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.all_tasks" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna um conjunto de objetos <a class="reference internal" href="#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> ainda não concluídos a serem executados pelo laço.</p>
<p>Se <em>loop</em> for <code class="docutils literal notranslate"><span class="pre">None</span></code>, então <a class="reference internal" href="asyncio-eventloop.html#asyncio.get_running_loop" title="asyncio.get_running_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_running_loop()</span></code></a> é usado para obter o laço atual.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.7.</span></p>
</div>
</dd></dl>

</section>
<section id="task-object">
<h2><a class="toc-backref" href="#id13">Objeto Task</a><a class="headerlink" href="#task-object" title="Link permanente para este título">¶</a></h2>
<dl class="py class">
<dt id="asyncio.Task">
<em class="property">class </em><code class="sig-prename descclassname">asyncio.</code><code class="sig-name descname">Task</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">coro</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">loop</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Task" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Um objeto <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">similar</span> <span class="pre">a</span> <span class="pre">Futuro</span></code></a> que executa uma <a class="reference internal" href="#coroutine"><span class="std std-ref">corrotina</span></a> Python. Não é seguro para thread.</p>
<p>Tarefas são usadas para executar corrotinas em laços de eventos. Se uma corrotina espera por um Futuro, a Tarefa suspende a execução da corrotina e aguarda a conclusão do Futuro. Quando o Futuro é <em>concluído</em>, a execução da corrotina contida é retomada.</p>
<p>Laço de eventos usam agendamento cooperativo: um ciclo de evento executa uma Tarefa de cada vez. Enquanto uma Tarefa aguarda a conclusão de um Futuro, o laço de eventos executa outras Tarefas, funções de retorno, ou executa operações de IO.</p>
<p>Use a função de alto nível <a class="reference internal" href="#asyncio.create_task" title="asyncio.create_task"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.create_task()</span></code></a> para criar Tarefas, ou as funções de baixo nível <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.create_task" title="asyncio.loop.create_task"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_task()</span></code></a> ou <a class="reference internal" href="asyncio-future.html#asyncio.ensure_future" title="asyncio.ensure_future"><code class="xref py py-func docutils literal notranslate"><span class="pre">ensure_future()</span></code></a>. Instanciação manual de Tarefas é desencorajado.</p>
<p>Para cancelar uma Tarefa em execução, use o método <a class="reference internal" href="#asyncio.Task.cancel" title="asyncio.Task.cancel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cancel()</span></code></a>. Chamar ele fará com que a Tarefa levante uma exceção <a class="reference internal" href="asyncio-exceptions.html#asyncio.CancelledError" title="asyncio.CancelledError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">CancelledError</span></code></a> dentro da corrotina contida. Se a corrotina estiver esperando por um objeto Future durante o cancelamento, o objeto Future será cancelado.</p>
<p><a class="reference internal" href="#asyncio.Task.cancelled" title="asyncio.Task.cancelled"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cancelled()</span></code></a> pode ser usado para verificar se a Tarefa foi cancelada. O método retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> se a corrotina envolta não suprimiu a exceção <a class="reference internal" href="asyncio-exceptions.html#asyncio.CancelledError" title="asyncio.CancelledError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">CancelledError</span></code></a> e foi na verdade cancelada.</p>
<p><a class="reference internal" href="#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Task</span></code></a> herda de <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">Future</span></code></a> todas as suas APIs exceto <a class="reference internal" href="asyncio-future.html#asyncio.Future.set_result" title="asyncio.Future.set_result"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Future.set_result()</span></code></a> e <a class="reference internal" href="asyncio-future.html#asyncio.Future.set_exception" title="asyncio.Future.set_exception"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Future.set_exception()</span></code></a>.</p>
<p>Tarefas suportam o módulo <a class="reference internal" href="contextvars.html#module-contextvars" title="contextvars: Context Variables"><code class="xref py py-mod docutils literal notranslate"><span class="pre">contextvars</span></code></a>. Quando a Tarefa é criada, ela copia o contexto atual e posteriormente executa sua corrotina no contexto copiado.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.7: </span>Adicionado suporte para o módulo <a class="reference internal" href="contextvars.html#module-contextvars" title="contextvars: Context Variables"><code class="xref py py-mod docutils literal notranslate"><span class="pre">contextvars</span></code></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.8: </span>Added the <em>name</em> parameter.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde a versão 3.10: </span>Aviso de descontinuidade é emitido se <em>loop</em> não é especificado, e não existe nenhum laço de eventos em execução.</p>
</div>
<dl class="py method">
<dt id="asyncio.Task.cancel">
<code class="sig-name descname">cancel</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Task.cancel" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Solicita o cancelamento da Tarefa.</p>
<p>Isto prepara para uma exceção <a class="reference internal" href="asyncio-exceptions.html#asyncio.CancelledError" title="asyncio.CancelledError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">CancelledError</span></code></a> ser lançada na corrotina contida no próximo ciclo do laço de eventos.</p>
<p>A corrotina então tem uma chance de limpar ou até mesmo negar a requisição, suprimindo a exceção com um bloco <a class="reference internal" href="../reference/compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> … … <code class="docutils literal notranslate"><span class="pre">except</span> <span class="pre">CancelledError</span></code> … <a class="reference internal" href="../reference/compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a>. Portanto, ao contrário de <a class="reference internal" href="asyncio-future.html#asyncio.Future.cancel" title="asyncio.Future.cancel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Future.cancel()</span></code></a>, <a class="reference internal" href="#asyncio.Task.cancel" title="asyncio.Task.cancel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Task.cancel()</span></code></a> não garante que a Tarefa será cancelada, apesar que suprimir o cancelamento completamente não é comum, e é ativamente desencorajado.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.9: </span>Added the <em>msg</em> parameter.</p>
</div>
<p id="asyncio-example-task-cancel">O seguinte exemplo ilustra como corrotinas podem interceptar o cancelamento de requisições:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">cancel_me</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;cancel_me(): before sleep&#39;</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Wait for 1 hour</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">3600</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">CancelledError</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;cancel_me(): cancel sleep&#39;</span><span class="p">)</span>
        <span class="k">raise</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;cancel_me(): after sleep&#39;</span><span class="p">)</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># Create a &quot;cancel_me&quot; Task</span>
    <span class="n">task</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">cancel_me</span><span class="p">())</span>

    <span class="c1"># Wait for 1 second</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">task</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">await</span> <span class="n">task</span>
    <span class="k">except</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">CancelledError</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;main(): cancel_me is cancelled now&quot;</span><span class="p">)</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>

<span class="c1"># Expected output:</span>
<span class="c1">#</span>
<span class="c1">#     cancel_me(): before sleep</span>
<span class="c1">#     cancel_me(): cancel sleep</span>
<span class="c1">#     cancel_me(): after sleep</span>
<span class="c1">#     main(): cancel_me is cancelled now</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="asyncio.Task.cancelled">
<code class="sig-name descname">cancelled</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Task.cancelled" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> se a Tarefa for <em>cancelada</em>.</p>
<p>A Tarefa é <em>cancelada</em> quando o cancelamento foi requisitado com <a class="reference internal" href="#asyncio.Task.cancel" title="asyncio.Task.cancel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cancel()</span></code></a> e a corrotina contida propagou a exceção <a class="reference internal" href="asyncio-exceptions.html#asyncio.CancelledError" title="asyncio.CancelledError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">CancelledError</span></code></a> gerada nela.</p>
</dd></dl>

<dl class="py method">
<dt id="asyncio.Task.done">
<code class="sig-name descname">done</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Task.done" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> se a Tarefa estiver <em>concluída</em>.</p>
<p>Uma Tarefa está <em>concluída</em> quando a corrotina contida retornou um valor, ou levantou uma exceção, ou a Tarefa foi cancelada.</p>
</dd></dl>

<dl class="py method">
<dt id="asyncio.Task.result">
<code class="sig-name descname">result</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Task.result" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna o resultado da Tarefa.</p>
<p>Se a Tarefa estiver <em>concluída</em>, o resultado da corrotina contida é retornado (ou se a corrotina levantou uma exceção, essa exceção é re-levantada.)</p>
<p>Se a Tarefa foi <em>cancelada</em>, este método levanta uma exceção <a class="reference internal" href="asyncio-exceptions.html#asyncio.CancelledError" title="asyncio.CancelledError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">CancelledError</span></code></a>.</p>
<p>Se o resultado da Tarefa não estiver disponível ainda, este método levanta uma exceção <a class="reference internal" href="asyncio-exceptions.html#asyncio.InvalidStateError" title="asyncio.InvalidStateError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">InvalidStateError</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="asyncio.Task.exception">
<code class="sig-name descname">exception</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Task.exception" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna a exceção de uma Tarefa.</p>
<p>Se a corrotina contida levantou uma exceção, essa exceção é retornada. Se a corrotina contida retornou normalmente, este método retorna <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>Se a Tarefa foi <em>cancelada</em>, este método levanta uma exceção <a class="reference internal" href="asyncio-exceptions.html#asyncio.CancelledError" title="asyncio.CancelledError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">CancelledError</span></code></a>.</p>
<p>Se a Tarefa não estiver <em>concluída</em> ainda, este método levanta uma exceção <a class="reference internal" href="asyncio-exceptions.html#asyncio.InvalidStateError" title="asyncio.InvalidStateError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">InvalidStateError</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="asyncio.Task.add_done_callback">
<code class="sig-name descname">add_done_callback</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">callback</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">context</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Task.add_done_callback" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Adiciona uma função de retorno para ser executada quando a Tarefa estiver <em>concluída</em>.</p>
<p>Este método deve ser usado apenas em código de baixo nível baseado em funções de retorno.</p>
<p>Veja a documentação para <a class="reference internal" href="asyncio-future.html#asyncio.Future.add_done_callback" title="asyncio.Future.add_done_callback"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Future.add_done_callback()</span></code></a> para mais detalhes.</p>
</dd></dl>

<dl class="py method">
<dt id="asyncio.Task.remove_done_callback">
<code class="sig-name descname">remove_done_callback</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">callback</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Task.remove_done_callback" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Remove <em>callback</em> da lista de funções de retorno.</p>
<p>Este método deve ser usado apenas em código de baixo nível baseado em funções de retorno.</p>
<p>Veja a documentação do método <a class="reference internal" href="asyncio-future.html#asyncio.Future.remove_done_callback" title="asyncio.Future.remove_done_callback"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Future.remove_done_callback()</span></code></a> para mais detalhes.</p>
</dd></dl>

<dl class="py method">
<dt id="asyncio.Task.get_stack">
<code class="sig-name descname">get_stack</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">limit</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Task.get_stack" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna a lista de frames da pilha para esta Tarefa.</p>
<p>Se a corrotina contida não estiver concluída, isto retorna a pilha onde ela foi suspensa. Se a corrotina foi concluída com sucesso ou foi cancelada, isto retorna uma lista vazia. Se a corrotina foi terminada por uma exceção, isto retorna a lista de frames do traceback (situação da pilha de execução).</p>
<p>Os quadros são sempre ordenados dos mais antigos para os mais recentes.</p>
<p>Apenas um frame da pilha é retornado para uma corrotina suspensa.</p>
<p>O argumento opcional <em>limit</em> define o o número de frames máximo para retornar; por padrão todos os frames disponíveis são retornados. O ordenamento da lista retornada é diferente dependendo se uma pilha ou um traceback (situação da pilha de execução) é retornado: os frames mais recentes de uma pilha são retornados, mas os frames mais antigos de um traceback são retornados. (Isso combina com o comportamento do módulo traceback.)</p>
</dd></dl>

<dl class="py method">
<dt id="asyncio.Task.print_stack">
<code class="sig-name descname">print_stack</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">limit</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">file</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Task.print_stack" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Exibe a pilha ou situação da pilha de execução para esta Tarefa.</p>
<p>Isto produz uma saída similar a do módulo traceback para frames recuperados por <a class="reference internal" href="#asyncio.Task.get_stack" title="asyncio.Task.get_stack"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_stack()</span></code></a>.</p>
<p>O argumento <em>limit</em> é passado para <a class="reference internal" href="#asyncio.Task.get_stack" title="asyncio.Task.get_stack"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_stack()</span></code></a> diretamente.</p>
<p>O argumento <em>file</em> é um fluxo de entrada e saída para o qual a saída é escrita; por padrão a saída é escrita para <a class="reference internal" href="sys.html#sys.stderr" title="sys.stderr"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stderr</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="asyncio.Task.get_coro">
<code class="sig-name descname">get_coro</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Task.get_coro" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna o objeto corrotina contido pela <a class="reference internal" href="#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.8.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="asyncio.Task.get_name">
<code class="sig-name descname">get_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Task.get_name" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna o nome da Tarefa.</p>
<p>Se nenhum nome foi explicitamente designado para a Tarefa, a implementação padrão asyncio da classe Task gera um nome padrão durante a instanciação.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.8.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="asyncio.Task.set_name">
<code class="sig-name descname">set_name</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">value</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Task.set_name" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Define o nome da Tarefa.</p>
<p>O argumento <em>value</em> pode ser qualquer objeto, o qual é então convertido para uma string.</p>
<p>Na implementação padrão da Tarefa, o nome será visível na <a class="reference internal" href="functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> de saída de um objeto task.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.8.</span></p>
</div>
</dd></dl>

</dd></dl>

</section>
<section id="generator-based-coroutines">
<span id="asyncio-generator-based-coro"></span><h2><a class="toc-backref" href="#id14">Corrotinas baseadas em gerador</a><a class="headerlink" href="#generator-based-coroutines" title="Link permanente para este título">¶</a></h2>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Support for generator-based coroutines is <strong>deprecated</strong> and
is removed in Python 3.11.</p>
</div>
<p>Corrotinas baseadas em gerador antecedem a sintaxe async/await. Elas são geradores Python que usam expressões <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> para aguardar Futuros e outras corrotinas.</p>
<p>Corrotinas baseadas em gerador devem ser decoradas com <a class="reference internal" href="#asyncio.coroutine" title="asyncio.coroutine"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;asyncio.coroutine</span></code></a>, apesar disso não ser forçado.</p>
<dl class="py function">
<dt id="asyncio.coroutine">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">asyncio.</code><code class="sig-name descname">coroutine</code><a class="headerlink" href="#asyncio.coroutine" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Decorador para marcar corrotinas baseadas em gerador.</p>
<p>Este decorador permite que corrotinas legadas baseadas em gerador sejam compatíveis com código async/await:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@asyncio</span><span class="o">.</span><span class="n">coroutine</span>
<span class="k">def</span> <span class="nf">old_style_coroutine</span><span class="p">():</span>
    <span class="k">yield from</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">await</span> <span class="n">old_style_coroutine</span><span class="p">()</span>
</pre></div>
</div>
<p>Este decorador não deve ser usado para corrotinas <a class="reference internal" href="../reference/compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a>.</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.8, will be removed in version 3.11: </span>Use <a class="reference internal" href="../reference/compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> ao invés.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="asyncio.iscoroutine">
<code class="sig-prename descclassname">asyncio.</code><code class="sig-name descname">iscoroutine</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">obj</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.iscoroutine" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> se <em>obj</em> é um <a class="reference internal" href="#coroutine"><span class="std std-ref">objeto corrotina</span></a>.</p>
<p>Este método é diferente de <a class="reference internal" href="inspect.html#inspect.iscoroutine" title="inspect.iscoroutine"><code class="xref py py-func docutils literal notranslate"><span class="pre">inspect.iscoroutine()</span></code></a> porque ele retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> para corrotinas baseadas em gerador.</p>
</dd></dl>

<dl class="py function">
<dt id="asyncio.iscoroutinefunction">
<code class="sig-prename descclassname">asyncio.</code><code class="sig-name descname">iscoroutinefunction</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">func</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.iscoroutinefunction" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> se <em>func</em> é uma <a class="reference internal" href="#coroutine"><span class="std std-ref">função de corrotina</span></a>.</p>
<p>Este método é diferente de <a class="reference internal" href="inspect.html#inspect.iscoroutinefunction" title="inspect.iscoroutinefunction"><code class="xref py py-func docutils literal notranslate"><span class="pre">inspect.iscoroutinefunction()</span></code></a> porque ele retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> para funções de corrotina baseadas em gerador, decoradas com <a class="reference internal" href="#asyncio.coroutine" title="asyncio.coroutine"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;coroutine</span></code></a>.</p>
</dd></dl>

</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Tabela de Conteúdo</a></h3>
  <ul>
<li><a class="reference internal" href="#">Corrotinas e Tarefas</a><ul>
<li><a class="reference internal" href="#coroutines">Corrotinas</a></li>
<li><a class="reference internal" href="#awaitables">Aguardáveis</a></li>
<li><a class="reference internal" href="#running-an-asyncio-program">Executando um programa asyncio</a></li>
<li><a class="reference internal" href="#creating-tasks">Criando Tarefas</a></li>
<li><a class="reference internal" href="#sleeping">Dormindo</a></li>
<li><a class="reference internal" href="#running-tasks-concurrently">Executando tarefas concorrentemente</a></li>
<li><a class="reference internal" href="#shielding-from-cancellation">Protegendo contra cancelamento</a></li>
<li><a class="reference internal" href="#timeouts">Tempo limite</a></li>
<li><a class="reference internal" href="#waiting-primitives">Primitivas de Espera</a></li>
<li><a class="reference internal" href="#running-in-threads">Executando em Threads</a></li>
<li><a class="reference internal" href="#scheduling-from-other-threads">Agendando a partir de outras Threads</a></li>
<li><a class="reference internal" href="#introspection">Introspecção</a></li>
<li><a class="reference internal" href="#task-object">Objeto Task</a></li>
<li><a class="reference internal" href="#generator-based-coroutines">Corrotinas baseadas em gerador</a></li>
</ul>
</li>
</ul>

  <h4>Tópico anterior</h4>
  <p class="topless"><a href="asyncio.html"
                        title="capítulo anterior"><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code> — E/S assíncrona</a></p>
  <h4>Próximo tópico</h4>
  <p class="topless"><a href="asyncio-stream.html"
                        title="próximo capítulo">Streams</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Relatar um erro</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.10/Doc/library/asyncio-task.rst"
            rel="nofollow">Exibir código-fonte
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegação</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice geral"
             >índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="asyncio-stream.html" title="Streams"
             >próximo</a> |</li>
        <li class="right" >
          <a href="asyncio.html" title="asyncio — E/S assíncrona"
             >anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.10.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >A Biblioteca Padrão do Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="ipc.html" >Comunicação em Rede e Interprocesso</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="asyncio.html" ><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code> — E/S assíncrona</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Corrotinas e Tarefas</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Busca rápida" aria-label="Busca rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Direitos autorais</a> 2001-2022, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    Última atualização em jun. 04, 2022.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.4.3.
    </div>

  </body>
</html>