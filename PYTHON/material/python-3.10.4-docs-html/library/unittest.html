
<!DOCTYPE html>

<html lang="pt_BR">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17: http://docutils.sourceforge.net/" />

    <title>unittest — Framework de Testes Unitários &#8212; documentação Python 3.10.4</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pydoctheme.css?2022.1" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Pesquisar dentro de documentação Python 3.10.4"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="Sobre esses documentos" href="../about.html" />
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Buscar" href="../search.html" />
    <link rel="copyright" title="Direitos autorais" href="../copyright.html" />
    <link rel="next" title="unittest.mock — biblioteca de objeto mock" href="unittest.mock.html" />
    <link rel="prev" title="doctest — Teste exemplos interativos de Python" href="doctest.html" />
    <link rel="canonical" href="https://docs.python.org/3/library/unittest.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <label for="menuToggler" class="toggler__label">
        <span></span>
    </label>
    <nav class="nav-content" role="navigation">
         <a href="https://www.python.org/" class="nav-logo">
             <img src="../_static/py.svg" alt="Logo"/>
         </a>
        <div class="version_switcher_placeholder"></div>
        <form role="search" class="search" action="../search.html" method="get">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                <path fill-rule="nonzero"
                        d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="#444"></path>
            </svg>
            <input type="text" name="q" aria-label="Busca rápida"/>
            <input type="submit" value="Ir"/>
        </form>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
  <h3><a href="../contents.html">Tabela de Conteúdo</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code> — Framework de Testes Unitários</a><ul>
<li><a class="reference internal" href="#basic-example">Exemplo Básico</a></li>
<li><a class="reference internal" href="#command-line-interface">Interface de Linha de Comando</a><ul>
<li><a class="reference internal" href="#command-line-options">Opções de linha de comando</a></li>
</ul>
</li>
<li><a class="reference internal" href="#test-discovery">Test Discovery</a></li>
<li><a class="reference internal" href="#organizing-test-code">Organizando código teste</a></li>
<li><a class="reference internal" href="#re-using-old-test-code">Reutilizando códigos de teste antigos</a></li>
<li><a class="reference internal" href="#skipping-tests-and-expected-failures">Ignorando testes e falhas esperadas</a></li>
<li><a class="reference internal" href="#distinguishing-test-iterations-using-subtests">Distinguindo iterações de teste utilizando subtestes</a></li>
<li><a class="reference internal" href="#classes-and-functions">Classes e funções</a><ul>
<li><a class="reference internal" href="#test-cases">Casos de teste</a><ul>
<li><a class="reference internal" href="#deprecated-aliases">Deprecated aliases</a></li>
</ul>
</li>
<li><a class="reference internal" href="#grouping-tests">Grouping tests</a></li>
<li><a class="reference internal" href="#loading-and-running-tests">Carregando e executando testes</a><ul>
<li><a class="reference internal" href="#load-tests-protocol">load_tests Protocol</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#class-and-module-fixtures">Classes e Módulos de Definição de Contexto</a><ul>
<li><a class="reference internal" href="#setupclass-and-teardownclass">setUpClass and tearDownClass</a></li>
<li><a class="reference internal" href="#setupmodule-and-teardownmodule">setUpModule and tearDownModule</a></li>
</ul>
</li>
<li><a class="reference internal" href="#signal-handling">Tratamento de sinal</a></li>
</ul>
</li>
</ul>

  <h4>Tópico anterior</h4>
  <p class="topless"><a href="doctest.html"
                        title="capítulo anterior"><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code> — Teste exemplos interativos de Python</a></p>
  <h4>Próximo tópico</h4>
  <p class="topless"><a href="unittest.mock.html"
                        title="próximo capítulo"><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest.mock</span></code> — biblioteca de objeto mock</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Relatar um erro</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.10/Doc/library/unittest.rst"
            rel="nofollow">Exibir código-fonte
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegação</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice geral"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="unittest.mock.html" title="unittest.mock — biblioteca de objeto mock"
             accesskey="N">próximo</a> |</li>
        <li class="right" >
          <a href="doctest.html" title="doctest — Teste exemplos interativos de Python"
             accesskey="P">anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.10.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >A Biblioteca Padrão do Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="development.html" accesskey="U">Ferramentas de Desenvolvimento</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code> — Framework de Testes Unitários</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Busca rápida" aria-label="Busca rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="module-unittest">
<span id="unittest-unit-testing-framework"></span><h1><a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> — Framework de Testes Unitários<a class="headerlink" href="#module-unittest" title="Link permanente para este título">¶</a></h1>
<p><strong>Source code:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.10/Lib/unittest/__init__.py">Lib/unittest/__init__.py</a></p>
<hr class="docutils" />
<p>(Caso já estejas familiarizado com os conceitos básicos de testes, poderás querer ignorar <a class="reference internal" href="#assert-methods"><span class="std std-ref">a lista de métodos assertivos</span></a>.)</p>
<p>O framework de testes unitários <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> foi originalmente inspirado no JUnit e tem um sabor semelhante contendo as principais estruturas de teste de unidades existentes em outras linguagens. Ele suporta a automação de testes, compartilhamento de configuração e código de desligamento para testes, agregação de testes em coleções e independência dos testes do framework de relatórios.</p>
<p>Para conseguir isso, o módulo <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> suporta alguns conceitos importantes de forma orientada a objetos:</p>
<dl class="simple">
<dt>definição de contexto de teste</dt><dd><p>Uma <em class="dfn">definição de contexto de teste</em> representa a preparação necessária pra performar um ou mais testes, além de quaisquer ações de limpeza relacionadas. Isso pode envolver, por exemplo, criar bancos de dados proxy ou temporários, diretórios ou iniciar um processo de servidor.</p>
</dd>
<dt>caso de teste</dt><dd><p>Um <em class="dfn">test case</em> é uma unidade de teste individual. O mesmo verifica uma resposta específica a um determinado conjunto de entradas. O <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> fornece uma classe base, <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>, que pode ser usada para criar novos casos de teste.</p>
</dd>
<dt>Suíte de Testes</dt><dd><p>Uma <em class="dfn">test suite</em> é uma coleção de casos de teste, conjuntos de teste ou ambos. O mesmo é usado para agregar testes que devem ser executados juntos.</p>
</dd>
<dt>test runner</dt><dd><p>Um <em class="dfn">test runner</em> é um componente que orquestra a execução de testes e fornece o resultado para o usuário. O runner pode usar uma interface gráfica, uma interface textual ou retornar um valor especial para indicar os resultados da execução dos testes.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">Ver também</p>
<dl class="simple">
<dt>Módulo <a class="reference internal" href="doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a></dt><dd><p>Outro módulo de suporte a testes com um sabor muito diferente.</p>
</dd>
<dt><a class="reference external" href="https://web.archive.org/web/20150315073817/http://www.xprogramming.com/testfram.htm">Simple Smalltalk Testing: With Patterns</a></dt><dd><p>O documento original de Kent Beck sobre estruturas de teste usando o padrão compartilhado por <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a>.</p>
</dd>
<dt><a class="reference external" href="https://docs.pytest.org/">pytest</a></dt><dd><p>É um framework externo do unittest com uma sintaxe mais leve para escrever testes. Por exemplo, <code class="docutils literal notranslate"><span class="pre">assert</span> <span class="pre">func(10)</span> <span class="pre">==</span> <span class="pre">42</span></code>.</p>
</dd>
<dt><a class="reference external" href="https://wiki.python.org/moin/PythonTestingToolsTaxonomy">The Python Testing Tools Taxonomy</a></dt><dd><p>Uma extensa lista de ferramentas para testar código Python, incluindo estruturas de teste funcionais e bibliotecas de objetos simulados.</p>
</dd>
<dt><a class="reference external" href="http://lists.idyll.org/listinfo/testing-in-python">Testing in Python Mailing List</a></dt><dd><p>Um grupo de interesse especial para discussão de testes e ferramentas de teste, em Python.</p>
</dd>
</dl>
<p>O arquivo <code class="file docutils literal notranslate"><span class="pre">Tools/unittestgui/unittestgui.py</span></code>, na distribuição fonte do Python, é uma ferramenta com interface gráfica para descobrimento e execução de testes. Esta ferramenta é direcionada para facilitar o uso de quem está inciando com testes unitários. Para ambientes de produção, é recomendado que estes testes sejam executados em uma plataforma de integração contínua, como <a class="reference external" href="https://buildbot.net/">Buildbot</a>, <a class="reference external" href="https://jenkins.io/">Jenkins</a> ,`Travis-CI &lt;<a class="reference external" href="https://travis-ci.com">https://travis-ci.com</a>&gt;`_, ou <a class="reference external" href="https://www.appveyor.com/">AppVeyor</a>.</p>
</div>
<section id="basic-example">
<span id="unittest-minimal-example"></span><h2>Exemplo Básico<a class="headerlink" href="#basic-example" title="Link permanente para este título">¶</a></h2>
<p>O módulo <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> fornece um conjunto amplo de ferramentas para a construção e execução de testes. Esta seção demonstra que um pequeno subconjunto das ferramentas é suficiente para atender às necessidades da maioria dos usuários.</p>
<p>Aqui temos um simples Script para testar três métodos de String:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">unittest</span>

<span class="k">class</span> <span class="nc">TestStringMethods</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">test_upper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="s1">&#39;FOO&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_isupper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="s1">&#39;FOO&#39;</span><span class="o">.</span><span class="n">isupper</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertFalse</span><span class="p">(</span><span class="s1">&#39;Foo&#39;</span><span class="o">.</span><span class="n">isupper</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">test_split</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;hello world&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(),</span> <span class="p">[</span><span class="s1">&#39;hello&#39;</span><span class="p">,</span> <span class="s1">&#39;world&#39;</span><span class="p">])</span>
        <span class="c1"># check that s.split fails when the separator is not a string</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertRaises</span><span class="p">(</span><span class="ne">TypeError</span><span class="p">):</span>
            <span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">unittest</span><span class="o">.</span><span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>Para criar um testcase basta criar uma classe que estende de <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">unittest.TestCase</span></code></a>. Os três testes individuais são definidos com métodos cujos nomes começam com as letras <code class="docutils literal notranslate"><span class="pre">test</span></code>. Esta convenção na nomenclatura informa o runner a respeitos de quais métodos são, na verdade, testes.</p>
<p>O cerne de cada teste é a invocação de um método <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a> para verificar se há um resultado esperado; <a class="reference internal" href="#unittest.TestCase.assertTrue" title="unittest.TestCase.assertTrue"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertTrue()</span></code></a> ou <a class="reference internal" href="#unittest.TestCase.assertFalse" title="unittest.TestCase.assertFalse"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertFalse()</span></code></a> para verificar uma condição; ou <a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaises()</span></code></a> para verificar se uma exceção específica será levantada. Esses métodos são usados ao invés de utilizar a expressão <a class="reference internal" href="../reference/simple_stmts.html#assert"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">assert</span></code></a> para que o runner de teste possa acumular todos os resultados do teste e produzir um relatório.</p>
<p>Os métodos <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a> e <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDown()</span></code></a> permitem que você defina instruções que serão executadas antes e depois de cada método de teste. Eles são abordados em mais detalhes na seção <a class="reference internal" href="#organizing-tests"><span class="std std-ref">Organizando código teste</span></a>.</p>
<p>O bloco final mostra uma maneira simples de executar os testes. A função <a class="reference internal" href="#unittest.main" title="unittest.main"><code class="xref py py-func docutils literal notranslate"><span class="pre">unittest.main()</span></code></a> fornece uma interface de linha de comando para o Script de teste. Quando executado a partir da linha de comando, o Script acima produz uma saída que se parece com isso:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="o">----------------------------------------------------------------------</span>
<span class="n">Ran</span> <span class="mi">3</span> <span class="n">tests</span> <span class="ow">in</span> <span class="mf">0.000</span><span class="n">s</span>

<span class="n">OK</span>
</pre></div>
</div>
<p>Passando a opção <code class="docutils literal notranslate"><span class="pre">-v</span></code> para o nosso Script de teste instruirá a função <a class="reference internal" href="#unittest.main" title="unittest.main"><code class="xref py py-func docutils literal notranslate"><span class="pre">unittest.main()</span></code></a> a habilitar um nível mais alto de verbosidade e produzirá a seguinte saída:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">test_isupper</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">TestStringMethods</span><span class="p">)</span> <span class="o">...</span> <span class="n">ok</span>
<span class="n">test_split</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">TestStringMethods</span><span class="p">)</span> <span class="o">...</span> <span class="n">ok</span>
<span class="n">test_upper</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">TestStringMethods</span><span class="p">)</span> <span class="o">...</span> <span class="n">ok</span>

<span class="o">----------------------------------------------------------------------</span>
<span class="n">Ran</span> <span class="mi">3</span> <span class="n">tests</span> <span class="ow">in</span> <span class="mf">0.001</span><span class="n">s</span>

<span class="n">OK</span>
</pre></div>
</div>
<p>Os exemplos acima mostram os recursos mais utilizados <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> que são suficientes para atender a muitas necessidades de testes diários. O restante da documentação explora o conjunto completo de recursos desde os primeiros princípios.</p>
</section>
<section id="command-line-interface">
<span id="unittest-command-line-interface"></span><h2>Interface de Linha de Comando<a class="headerlink" href="#command-line-interface" title="Link permanente para este título">¶</a></h2>
<p>O módulo unittest pode ser usado diretamente da linha de comando para executar testes de módulos, classes ou mesmo testes de métodos individuais:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span> <span class="n">test_module1</span> <span class="n">test_module2</span>
<span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span> <span class="n">test_module</span><span class="o">.</span><span class="n">TestClass</span>
<span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span> <span class="n">test_module</span><span class="o">.</span><span class="n">TestClass</span><span class="o">.</span><span class="n">test_method</span>
</pre></div>
</div>
<p>Você pode passar uma lista com qualquer combinação de nomes de módulos e nomes de classes ou métodos totalmente qualificados.</p>
<p>Os módulos de teste podem ser especificados por caminhos de arquivo também:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span> <span class="n">tests</span><span class="o">/</span><span class="n">test_something</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p>Isso permite que você use o auto-completar do console/shell para especificar o módulo de teste. O arquivo especificado precisa ser “importável” como um módulo. O caminho é convertido para um nome de módulo ao remover a extensão <cite>.py</cite> e conversando os separadores do caminho em <cite>.</cite>. Se você quer executar um arquivo de teste que não é importável como um módulo, você deve executar o arquivo diretamente.</p>
<p>Você pode executar os testes com mais detalhes (maior verbosidade) ao usar o sinalizador -v:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span> <span class="o">-</span><span class="n">v</span> <span class="n">test_module</span>
</pre></div>
</div>
<p>Quando executado sem argumentos <a class="reference internal" href="#unittest-test-discovery"><span class="std std-ref">Test Discovery</span></a> é iniciado:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span>
</pre></div>
</div>
<p>Para uma lista de todas as opções de linha de comando:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span> <span class="o">-</span><span class="n">h</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.2: </span>Em versões mais antigas, era possível de executar apenas testes de métodos individuais e não de módulos ou classes.</p>
</div>
<section id="command-line-options">
<h3>Opções de linha de comando<a class="headerlink" href="#command-line-options" title="Link permanente para este título">¶</a></h3>
<p><strong class="program">unittest</strong> suporta as seguintes opções de linha de comando:</p>
<dl class="std cmdoption">
<dt id="cmdoption-unittest-b">
<span id="cmdoption-unittest-buffer"></span><code class="sig-name descname">-b</code><code class="sig-prename descclassname"></code><code class="sig-prename descclassname">, </code><code class="sig-name descname">--buffer</code><code class="sig-prename descclassname"></code><a class="headerlink" href="#cmdoption-unittest-b" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Os streams da saída padrão e do erro padrão são carregados durante a execução do teste. A saída de um teste que passou é descartada. A saída geralmente é mostrada quando um teste falha e é adicionada às mensagens de falha.</p>
</dd></dl>

<dl class="std cmdoption">
<dt id="cmdoption-unittest-c">
<span id="cmdoption-unittest-catch"></span><code class="sig-name descname">-c</code><code class="sig-prename descclassname"></code><code class="sig-prename descclassname">, </code><code class="sig-name descname">--catch</code><code class="sig-prename descclassname"></code><a class="headerlink" href="#cmdoption-unittest-c" title="Link permanente para esta definição">¶</a></dt>
<dd><p><kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate">Control</kbd>-<kbd class="kbd docutils literal notranslate">C</kbd></kbd> durante a execução do teste aguarda até que o teste corrente termine e a partir disso mostra todos os resultados até o momento. Um segundo <kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate">Control</kbd>-<kbd class="kbd docutils literal notranslate">C</kbd></kbd> invoca uma exceção <a class="reference internal" href="exceptions.html#KeyboardInterrupt" title="KeyboardInterrupt"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> comum.</p>
<p>Veja <a class="reference internal" href="#signal-handling">Signal Handling</a> para as funções que provêm essa funcionalidade.</p>
</dd></dl>

<dl class="std cmdoption">
<dt id="cmdoption-unittest-f">
<span id="cmdoption-unittest-failfast"></span><code class="sig-name descname">-f</code><code class="sig-prename descclassname"></code><code class="sig-prename descclassname">, </code><code class="sig-name descname">--failfast</code><code class="sig-prename descclassname"></code><a class="headerlink" href="#cmdoption-unittest-f" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Parar a execução do teste no primeiro erro ou falha.</p>
</dd></dl>

<dl class="std cmdoption">
<dt id="cmdoption-unittest-k">
<code class="sig-name descname">-k</code><code class="sig-prename descclassname"></code><a class="headerlink" href="#cmdoption-unittest-k" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Only run test methods and classes that match the pattern or substring.
This option may be used multiple times, in which case all test cases that
match any of the given patterns are included.</p>
<p>Padrões que contém um caractere curinga (<code class="docutils literal notranslate"><span class="pre">*</span></code>) são combinados com os testes pelo método <a class="reference internal" href="fnmatch.html#fnmatch.fnmatchcase" title="fnmatch.fnmatchcase"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fnmatch.fnmatchcase()</span></code></a>; caso contrário, é utilizada uma combinação simples de substrings, diferenciando-se letras maiúsculas e minúsculas.</p>
<p>Padrões são combinados com o nome completo qualificado do método de teste no formato que ele é importado pelo carregador.</p>
<p>Por exemplo, <code class="docutils literal notranslate"><span class="pre">-k</span> <span class="pre">foo</span></code> combina com <code class="docutils literal notranslate"><span class="pre">foo_tests.SomeTest.test_something</span></code>, <code class="docutils literal notranslate"><span class="pre">bar_tests.SomeTest.test_foo</span></code>, mas não com <code class="docutils literal notranslate"><span class="pre">bar_tests.FooTest.test_something</span></code>.</p>
</dd></dl>

<dl class="std cmdoption">
<dt id="cmdoption-unittest-locals">
<code class="sig-name descname">--locals</code><code class="sig-prename descclassname"></code><a class="headerlink" href="#cmdoption-unittest-locals" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Mostra variáveis locais no traceback.</p>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.2: </span>As opções de linha de comando <code class="docutils literal notranslate"><span class="pre">-b</span></code>, <code class="docutils literal notranslate"><span class="pre">-c</span></code> e <code class="docutils literal notranslate"><span class="pre">-f</span></code> foram adicionadas.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.5: </span>A opção de linha de comando <code class="docutils literal notranslate"><span class="pre">--locals</span></code>.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.7: </span>A opção de linha de comando <code class="docutils literal notranslate"><span class="pre">-k</span></code>.</p>
</div>
<p>A linha de comando também pode ser usada para descobrir testes, para executar todos os testes de um projeto ou apenas de um subconjunto.</p>
</section>
</section>
<section id="test-discovery">
<span id="unittest-test-discovery"></span><h2>Test Discovery<a class="headerlink" href="#test-discovery" title="Link permanente para este título">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.2.</span></p>
</div>
<p>Unittest oferece suporte para descobrimento simples de testes. Para serem compatíveis com o descobrimento de testes, todos os arquivos de teste devem ser <a class="reference internal" href="../tutorial/modules.html#tut-modules"><span class="std std-ref">módulos</span></a> ou <a class="reference internal" href="../tutorial/modules.html#tut-packages"><span class="std std-ref">pacotes</span></a> (incluindo <a class="reference internal" href="../glossary.html#term-namespace-package"><span class="xref std std-term">pacotes de espaço de nomes</span></a>) importáveis a partir do diretório raiz do projeto (isso significa que os nomes dos arquivos devem ser <a class="reference internal" href="../reference/lexical_analysis.html#identifiers"><span class="std std-ref">identificadores</span></a> válidos).</p>
<p>O descobrimento de testes é implementado no <a class="reference internal" href="#unittest.TestLoader.discover" title="unittest.TestLoader.discover"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestLoader.discover()</span></code></a>, mas também pode ser utilizado a partir da linha de comando. O comando básico para uso é:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span> <span class="n">project_directory</span>
<span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span> <span class="n">discover</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Como um atalho, <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">-m</span> <span class="pre">unittest</span></code> é o equivalente a <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">-m</span> <span class="pre">unittest</span> <span class="pre">discover</span></code>. Se você deseja passar argumentos para a descoberta de testes, o subcomando <code class="docutils literal notranslate"><span class="pre">discover</span></code> deve ser usado explicitamente.</p>
</div>
<p>O sub-comando <code class="docutils literal notranslate"><span class="pre">discover</span></code> (descubra) tem as seguintes opções:</p>
<dl class="std cmdoption">
<dt id="cmdoption-unittest-discover-v">
<span id="cmdoption-unittest-discover-verbose"></span><code class="sig-name descname">-v</code><code class="sig-prename descclassname"></code><code class="sig-prename descclassname">, </code><code class="sig-name descname">--verbose</code><code class="sig-prename descclassname"></code><a class="headerlink" href="#cmdoption-unittest-discover-v" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Saída verbosa</p>
</dd></dl>

<dl class="std cmdoption">
<dt id="cmdoption-unittest-discover-s">
<span id="cmdoption-unittest-discover-start-directory"></span><code class="sig-name descname">-s</code><code class="sig-prename descclassname"></code><code class="sig-prename descclassname">, </code><code class="sig-name descname">--start-directory</code><code class="sig-prename descclassname"> directory</code><a class="headerlink" href="#cmdoption-unittest-discover-s" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Diretório no qual se inicia o descobrimento (<code class="docutils literal notranslate"><span class="pre">.</span></code> por padrão)</p>
</dd></dl>

<dl class="std cmdoption">
<dt id="cmdoption-unittest-discover-p">
<span id="cmdoption-unittest-discover-pattern"></span><code class="sig-name descname">-p</code><code class="sig-prename descclassname"></code><code class="sig-prename descclassname">, </code><code class="sig-name descname">--pattern</code><code class="sig-prename descclassname"> pattern</code><a class="headerlink" href="#cmdoption-unittest-discover-p" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Padrão de texto para se descobrir os arquivos de teste (<code class="docutils literal notranslate"><span class="pre">test*.py</span></code> por padrão)</p>
</dd></dl>

<dl class="std cmdoption">
<dt id="cmdoption-unittest-discover-t">
<span id="cmdoption-unittest-discover-top-level-directory"></span><code class="sig-name descname">-t</code><code class="sig-prename descclassname"></code><code class="sig-prename descclassname">, </code><code class="sig-name descname">--top-level-directory</code><code class="sig-prename descclassname"> directory</code><a class="headerlink" href="#cmdoption-unittest-discover-t" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Diretório raiz do projeto (diretório de início por padrão)</p>
</dd></dl>

<p>As opções <a class="reference internal" href="#cmdoption-unittest-discover-s"><code class="xref std std-option docutils literal notranslate"><span class="pre">-s</span></code></a>, <a class="reference internal" href="#cmdoption-unittest-discover-p"><code class="xref std std-option docutils literal notranslate"><span class="pre">-p</span></code></a> e <a class="reference internal" href="#cmdoption-unittest-discover-t"><code class="xref std std-option docutils literal notranslate"><span class="pre">-t</span></code></a> podem ser passadas como argumentos posicionais nessa ordem. As duas linhas de comando seguintes são equivalentes:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span> <span class="n">discover</span> <span class="o">-</span><span class="n">s</span> <span class="n">project_directory</span> <span class="o">-</span><span class="n">p</span> <span class="s2">&quot;*_test.py&quot;</span>
<span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span> <span class="n">discover</span> <span class="n">project_directory</span> <span class="s2">&quot;*_test.py&quot;</span>
</pre></div>
</div>
<p>Além de aceitar caminhos, também é possível passar o nome de um pacote, como <code class="docutils literal notranslate"><span class="pre">myproject.subpackage.test</span></code>, como diretório de início. O nome do pacote que for passado será importado e sua localização no sistema de arquivos será utilizada como diretório de início.</p>
<div class="admonition caution">
<p class="admonition-title">Cuidado</p>
<p>O descobridor de testes importa os testes para carregá-los. Uma vez que o descobridor tiver encontrado todos os arquivos de teste a partir do diretório de início especificado, ele transforma os caminhos em nomes de pacotes para conseguir importá-los. Por exemplo, <code class="file docutils literal notranslate"><span class="pre">foo/bar/baz.py</span></code> será importado como <code class="docutils literal notranslate"><span class="pre">foo.bar.baz</span></code>.</p>
<p>Se você possuir um pacote instalado globalmente e tentar executar o descobrimento em uma versão diferente deste mesmo pacote, a importação <em>pode</em> acontecer do lugar errado. Se isso acontecer, o descobridor de testes irá emitir um alerta e encerrar a execução.</p>
<p>Se você configurar o diretório de início como sendo um nome de pacote, não um caminho para um diretório, o descobridor irá assumir que qualquer local do qual ele importar é o local correto. Neste caso, nenhum alerta será emitido.</p>
</div>
<p>Módulos de testes e pacotes podem conter customizações no carregamento de testes utilizando <a class="reference internal" href="#load-tests-protocol">load_tests protocol</a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.4: </span>Descoberta de testes suporta <a class="reference internal" href="../glossary.html#term-namespace-package"><span class="xref std std-term">pacote de espaço de nomes</span></a> para o diretório de início. Perceba que você precisa especificar o diretório de nível superior também (ex: <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">-m</span> <span class="pre">unittest</span> <span class="pre">discover</span> <span class="pre">-s</span> <span class="pre">root/namespace</span> <span class="pre">-t</span> <span class="pre">root</span></code>).</p>
</div>
</section>
<section id="organizing-test-code">
<span id="organizing-tests"></span><h2>Organizando código teste<a class="headerlink" href="#organizing-test-code" title="Link permanente para este título">¶</a></h2>
<p>O bloco básico de construção dos testes unitários são os <em class="dfn">casos de teste</em> — cenários únicos que devem ser configurados e avaliados em sua correção. No <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a>, casos de teste são representados por instâncias <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">unittest.TestCase</span></code></a>. Para criar seus próprios casos de teste, você deve escrever subclasses de <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> ou utilizar <a class="reference internal" href="#unittest.FunctionTestCase" title="unittest.FunctionTestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">FunctionTestCase</span></code></a>.</p>
<p>O código de teste em uma instância da classe <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> deve ser completamente auto-contido, de maneira que ele possa ser executado isoladamente ou combinado, de forma arbitrária, com quaisquer outros casos de teste.</p>
<p>A mais simples subclasse de <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> irá implementar um método de teste (i.e. um método cujo nome começa com <code class="docutils literal notranslate"><span class="pre">test</span></code>) para executar um teste:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">unittest</span>

<span class="k">class</span> <span class="nc">DefaultWidgetSizeTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">test_default_widget_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">widget</span> <span class="o">=</span> <span class="n">Widget</span><span class="p">(</span><span class="s1">&#39;The widget&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">widget</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span> <span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">))</span>
</pre></div>
</div>
<p>Perceba que, para testar algo, utilizamos um dos métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">assert*()</span></code> da classe base <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>. Se o teste falhar, uma exceção será levantada com uma mensagem de explicação e o módulo <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> irá considerar o resultado do caso de teste como uma <em class="dfn">falha</em>. Quaisquer outras exceções serão tratadas como <em class="dfn">erros</em>.</p>
<p>Os testes podem ser muitos, e as configurações podem ser repetitivas. Por sorte, temos como reaproveitar estas configurações implementando um método chamado <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a>, o qual será automaticamente chamado pelo framework de teste para cada teste único que executarmos:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">unittest</span>

<span class="k">class</span> <span class="nc">WidgetTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widget</span> <span class="o">=</span> <span class="n">Widget</span><span class="p">(</span><span class="s1">&#39;The widget&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_default_widget_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">widget</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span> <span class="p">(</span><span class="mi">50</span><span class="p">,</span><span class="mi">50</span><span class="p">),</span>
                         <span class="s1">&#39;incorrect default size&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_widget_resize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widget</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">150</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">widget</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">150</span><span class="p">),</span>
                         <span class="s1">&#39;wrong size after resize&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>A ordem de execução dos testes será feita com base na ordenação dos nomes dos métodos de teste respeitando os critérios da ordenação de strings embutida.</p>
</div>
<p>Se o método <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a> levantar uma exceção durante a sua execução, o framework irá considerar que o teste sofreu um erro e o método de teste não será executado.</p>
<p>De maneira similar, pode-se definir um método <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDown()</span></code></a> que limpa o ambiente após a execução do método de teste:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">unittest</span>

<span class="k">class</span> <span class="nc">WidgetTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widget</span> <span class="o">=</span> <span class="n">Widget</span><span class="p">(</span><span class="s1">&#39;The widget&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tearDown</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widget</span><span class="o">.</span><span class="n">dispose</span><span class="p">()</span>
</pre></div>
</div>
<p>Se o método <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a> for bem sucedido, o método <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDown()</span></code></a> será executado, independente do resultado do método de teste.</p>
<p>Tal ambiente de trabalho do código de teste é chamado de <em class="dfn">definição de contexto de teste</em>. Uma nova instância TestCase é criada como uma única definição de contexto de teste usada para executar cada método de teste. Portanto, os métodos <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a>, <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDown()</span></code></a>, e <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> serão chamados uma vez por teste.</p>
<p>É recomendado utilizar implementações de TestCase para agrupar testes de acordo com as funcionalidades que eles testam. <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> disponibiliza um mecanismo para isso: a <em class="dfn">suíte de testes</em>, representada pela classe <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> do módulo <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a>. Em grande parte dos casos, chamar <a class="reference internal" href="#unittest.main" title="unittest.main"><code class="xref py py-func docutils literal notranslate"><span class="pre">unittest.main()</span></code></a> é suficiente para coletar todos os casos de teste do módulo e executá-los para você.</p>
<p>Entretanto, caso você queira customizar a construção da sua suíte de testes, é possível fazê-la desta forma:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">suite</span><span class="p">():</span>
    <span class="n">suite</span> <span class="o">=</span> <span class="n">unittest</span><span class="o">.</span><span class="n">TestSuite</span><span class="p">()</span>
    <span class="n">suite</span><span class="o">.</span><span class="n">addTest</span><span class="p">(</span><span class="n">WidgetTestCase</span><span class="p">(</span><span class="s1">&#39;test_default_widget_size&#39;</span><span class="p">))</span>
    <span class="n">suite</span><span class="o">.</span><span class="n">addTest</span><span class="p">(</span><span class="n">WidgetTestCase</span><span class="p">(</span><span class="s1">&#39;test_widget_resize&#39;</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">suite</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">runner</span> <span class="o">=</span> <span class="n">unittest</span><span class="o">.</span><span class="n">TextTestRunner</span><span class="p">()</span>
    <span class="n">runner</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">suite</span><span class="p">())</span>
</pre></div>
</div>
<p>Você pode colocar as definições dos casos de teste e suíte de testes em um mesmo módulo que contém o código a ser testado (tal como <code class="file docutils literal notranslate"><span class="pre">widget.py</span></code>), mas existem várias vantagens ao colocar o código dos testes em um módulo separado, como <code class="file docutils literal notranslate"><span class="pre">test_widget.py</span></code>:</p>
<ul class="simple">
<li><p>O módulo de teste pode ser executado de maneira isolada a partir da linha de comando.</p></li>
<li><p>O código de teste pode ser mais facilmente separado do código a ser entregue.</p></li>
<li><p>Há uma menor tentação para modificar o código de teste para que ele se adéque ao código testado sem que haja uma boa razão.</p></li>
<li><p>O código de teste deve ser modificado muito menos frequentemente do que o código que ele testa.</p></li>
<li><p>Código testado pode ser reformulado mais facilmente.</p></li>
<li><p>Testes para módulos escritos em C devem ser, obrigatoriamente, colocados em módulos separados, então por que não manter a consistência?</p></li>
<li><p>Se as estratégias de teste mudarem, não há a necessidade de mudar o código-fonte.</p></li>
</ul>
</section>
<section id="re-using-old-test-code">
<span id="legacy-unit-tests"></span><h2>Reutilizando códigos de teste antigos<a class="headerlink" href="#re-using-old-test-code" title="Link permanente para este título">¶</a></h2>
<p>Alguns usuários irão encontrar antigos códigos de teste que eles gostariam de executar com <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> sem converter cada função antiga para uma subclasse de <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>.</p>
<p>Por isso, <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> contém uma classe <a class="reference internal" href="#unittest.FunctionTestCase" title="unittest.FunctionTestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">FunctionTestCase</span></code></a>. Esta subclasse de <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> pode ser utilizada para englobar funções de teste existentes. Funções de definição de estado inicial e final (set-up e tear-down) também podem ser fornecidas.</p>
<p>Dadas as seguintes funções de teste:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">testSomething</span><span class="p">():</span>
    <span class="n">something</span> <span class="o">=</span> <span class="n">makeSomething</span><span class="p">()</span>
    <span class="k">assert</span> <span class="n">something</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="c1"># ...</span>
</pre></div>
</div>
<p>é possível criar uma instância de caso de teste, com métodos opcionais de configuração inicial e final (set-up e tear-down), como mostrado a seguir:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">testcase</span> <span class="o">=</span> <span class="n">unittest</span><span class="o">.</span><span class="n">FunctionTestCase</span><span class="p">(</span><span class="n">testSomething</span><span class="p">,</span>
                                     <span class="n">setUp</span><span class="o">=</span><span class="n">makeSomethingDB</span><span class="p">,</span>
                                     <span class="n">tearDown</span><span class="o">=</span><span class="n">deleteSomethingDB</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Apesar da classe <a class="reference internal" href="#unittest.FunctionTestCase" title="unittest.FunctionTestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">FunctionTestCase</span></code></a> poder ser utilizada para converter rapidamente um teste existente em um teste do módulo <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a>, esta abordagem não é recomendada. Investir tempo para configurar corretamente uma subclasse de <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> irá tornar futuras refatorações infinitamente mais fáceis.</p>
</div>
<p>Em alguns casos, os testes existentes podem ter sido escritos utilizando o módulo <a class="reference internal" href="doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a>. Se for o caso, <a class="reference internal" href="doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a> contém a classe <code class="xref py py-class docutils literal notranslate"><span class="pre">DocTestSuite</span></code> que pode construir, automaticamente, instâncias <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">unittest.TestSuite</span></code></a> a partir dos testes baseados em <a class="reference internal" href="doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a>.</p>
</section>
<section id="skipping-tests-and-expected-failures">
<span id="unittest-skipping"></span><h2>Ignorando testes e falhas esperadas<a class="headerlink" href="#skipping-tests-and-expected-failures" title="Link permanente para este título">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.1.</span></p>
</div>
<p>Unittest suporta ignorar métodos de teste individuais e, até mesmo, classes de teste inteiras. Além disso, há suporte para a marcação de um teste como uma “falha esperada”, um teste que está incorreto e irá falhar, mas não deve ser considerado como uma falha no <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a>.</p>
<p>Ignorar um teste é simplesmente uma questão de utilizar o <a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">decorador</span></a> <a class="reference internal" href="#unittest.skip" title="unittest.skip"><code class="xref py py-func docutils literal notranslate"><span class="pre">skip()</span></code></a> ou uma de suas variantes condicionais, chamando <a class="reference internal" href="#unittest.TestCase.skipTest" title="unittest.TestCase.skipTest"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestCase.skipTest()</span></code></a> em um <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a> ou método de teste, ou levantando <a class="reference internal" href="#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SkipTest</span></code></a> diretamente.</p>
<p>Ignorar se parece basicamente com:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>

    <span class="nd">@unittest</span><span class="o">.</span><span class="n">skip</span><span class="p">(</span><span class="s2">&quot;demonstrating skipping&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">test_nothing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fail</span><span class="p">(</span><span class="s2">&quot;shouldn&#39;t happen&quot;</span><span class="p">)</span>

    <span class="nd">@unittest</span><span class="o">.</span><span class="n">skipIf</span><span class="p">(</span><span class="n">mylib</span><span class="o">.</span><span class="n">__version__</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
                     <span class="s2">&quot;not supported in this library version&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">test_format</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Tests that work for only a certain version of the library.</span>
        <span class="k">pass</span>

    <span class="nd">@unittest</span><span class="o">.</span><span class="n">skipUnless</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">platform</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;win&quot;</span><span class="p">),</span> <span class="s2">&quot;requires Windows&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">test_windows_support</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># windows specific testing code</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">test_maybe_skipped</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">external_resource_available</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">skipTest</span><span class="p">(</span><span class="s2">&quot;external resource not available&quot;</span><span class="p">)</span>
        <span class="c1"># test code that depends on the external resource</span>
        <span class="k">pass</span>
</pre></div>
</div>
<p>Esta é a saída da execução do exemplo acima em modo verboso:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">test_format</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">MyTestCase</span><span class="p">)</span> <span class="o">...</span> <span class="n">skipped</span> <span class="s1">&#39;not supported in this library version&#39;</span>
<span class="n">test_nothing</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">MyTestCase</span><span class="p">)</span> <span class="o">...</span> <span class="n">skipped</span> <span class="s1">&#39;demonstrating skipping&#39;</span>
<span class="n">test_maybe_skipped</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">MyTestCase</span><span class="p">)</span> <span class="o">...</span> <span class="n">skipped</span> <span class="s1">&#39;external resource not available&#39;</span>
<span class="n">test_windows_support</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">MyTestCase</span><span class="p">)</span> <span class="o">...</span> <span class="n">skipped</span> <span class="s1">&#39;requires Windows&#39;</span>

<span class="o">----------------------------------------------------------------------</span>
<span class="n">Ran</span> <span class="mi">4</span> <span class="n">tests</span> <span class="ow">in</span> <span class="mf">0.005</span><span class="n">s</span>

<span class="n">OK</span> <span class="p">(</span><span class="n">skipped</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>Classes podem ser puladas assim como métodos:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@unittest</span><span class="o">.</span><span class="n">skip</span><span class="p">(</span><span class="s2">&quot;showing class skipping&quot;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">MySkippedTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">test_not_run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>
</pre></div>
</div>
<p><a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestCase.setUp()</span></code></a> também pode ignorar o teste. Isso é útil quando um recurso que precisa ser configurado não está disponível.</p>
<p>Falhas esperadas usam o decorador <a class="reference internal" href="#unittest.expectedFailure" title="unittest.expectedFailure"><code class="xref py py-func docutils literal notranslate"><span class="pre">expectedFailure()</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ExpectedFailureTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="nd">@unittest</span><span class="o">.</span><span class="n">expectedFailure</span>
    <span class="k">def</span> <span class="nf">test_fail</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;broken&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>É simples ignorar com decoradores customizados, basta fazer um decorador que chama <a class="reference internal" href="#unittest.skip" title="unittest.skip"><code class="xref py py-func docutils literal notranslate"><span class="pre">skip()</span></code></a> no teste quando ele deve ser ignorado. Este decorador ignora o teste a não ser que o objeto fornecido tenha um determinado atributo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">skipUnlessHasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">func</span><span class="p">:</span> <span class="n">func</span>
    <span class="k">return</span> <span class="n">unittest</span><span class="o">.</span><span class="n">skip</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{!r}</span><span class="s2"> doesn&#39;t have </span><span class="si">{!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>
</pre></div>
</div>
<p>Os decoradores e exceção seguintes ignoram testes e falhas esperadas:</p>
<dl class="py function">
<dt id="unittest.skip">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">skip</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">reason</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.skip" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Ignora incondicionalmente o teste decorado. <em>reason</em> deve descrever a razão pela qual o teste está sendo ignorado.</p>
</dd></dl>

<dl class="py function">
<dt id="unittest.skipIf">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">skipIf</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">condition</span></em>, <em class="sig-param"><span class="n">reason</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.skipIf" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Ignora o teste decorado se <em>condition</em> for verdadeiro.</p>
</dd></dl>

<dl class="py function">
<dt id="unittest.skipUnless">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">skipUnless</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">condition</span></em>, <em class="sig-param"><span class="n">reason</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.skipUnless" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Ignora o teste decorado a não ser que <em>condition</em> seja verdadeiro.</p>
</dd></dl>

<dl class="py function">
<dt id="unittest.expectedFailure">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">expectedFailure</code><a class="headerlink" href="#unittest.expectedFailure" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Marca o teste como uma falha ou erro esperado. Se o teste falhar ou ocorrerem erros na função de teste mesmo (ao invés de em um dos métodos <em class="dfn">test fixture</em>), então ele será considerado como executado com sucesso. Se o teste passar, ele será considerado como uma falha.</p>
</dd></dl>

<dl class="py exception">
<dt id="unittest.SkipTest">
<em class="property">exception </em><code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">SkipTest</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">reason</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.SkipTest" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Esta exceção é levantada para ignorar um teste.</p>
<p>Normalmente, você pode utilizar <a class="reference internal" href="#unittest.TestCase.skipTest" title="unittest.TestCase.skipTest"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestCase.skipTest()</span></code></a> ou um dos decoradores para ignorar sem ter de levantar esta exceção diretamente.</p>
</dd></dl>

<p>Testes ignorados não terão seus métodos <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a> ou <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDown()</span></code></a> executados. Classes ignoradas não terão seus métodos <a class="reference internal" href="#unittest.TestCase.setUpClass" title="unittest.TestCase.setUpClass"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUpClass()</span></code></a> ou <a class="reference internal" href="#unittest.TestCase.tearDownClass" title="unittest.TestCase.tearDownClass"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDownClass()</span></code></a> executados. Módulos ignorados não terão seus métodos <code class="xref py py-func docutils literal notranslate"><span class="pre">setUpModule()</span></code> ou <code class="xref py py-func docutils literal notranslate"><span class="pre">tearDownModule()</span></code> executados.</p>
</section>
<section id="distinguishing-test-iterations-using-subtests">
<span id="subtests"></span><h2>Distinguindo iterações de teste utilizando subtestes<a class="headerlink" href="#distinguishing-test-iterations-using-subtests" title="Link permanente para este título">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.4.</span></p>
</div>
<p>Quando existem pequenas diferenças entre os seus testes, por exemplo alguns parâmetros, unittest permite que você distinga-os dentro do corpo de um método de teste utilizando o gerenciador de contexto <a class="reference internal" href="#unittest.TestCase.subTest" title="unittest.TestCase.subTest"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subTest()</span></code></a>.</p>
<p>Por exemplo, o teste seguinte:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">NumbersTest</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">test_even</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test that numbers between 0 and 5 are all even.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">):</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">subTest</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>irá produzir a seguinte saída:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">======================================================================</span>
<span class="n">FAIL</span><span class="p">:</span> <span class="n">test_even</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">NumbersTest</span><span class="p">)</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="o">----------------------------------------------------------------------</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">&quot;subtests.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">32</span><span class="p">,</span> <span class="ow">in</span> <span class="n">test_even</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="ne">AssertionError</span><span class="p">:</span> <span class="mi">1</span> <span class="o">!=</span> <span class="mi">0</span>

<span class="o">======================================================================</span>
<span class="n">FAIL</span><span class="p">:</span> <span class="n">test_even</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">NumbersTest</span><span class="p">)</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="o">----------------------------------------------------------------------</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">&quot;subtests.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">32</span><span class="p">,</span> <span class="ow">in</span> <span class="n">test_even</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="ne">AssertionError</span><span class="p">:</span> <span class="mi">1</span> <span class="o">!=</span> <span class="mi">0</span>

<span class="o">======================================================================</span>
<span class="n">FAIL</span><span class="p">:</span> <span class="n">test_even</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">NumbersTest</span><span class="p">)</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="o">----------------------------------------------------------------------</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">&quot;subtests.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">32</span><span class="p">,</span> <span class="ow">in</span> <span class="n">test_even</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="ne">AssertionError</span><span class="p">:</span> <span class="mi">1</span> <span class="o">!=</span> <span class="mi">0</span>
</pre></div>
</div>
<p>Sem usar um subteste, a execução para depois da primeira falha e o erro será menos fácil de ser diagnosticado porque o valor de <code class="docutils literal notranslate"><span class="pre">i</span></code> não será mostrado:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">======================================================================</span>
<span class="n">FAIL</span><span class="p">:</span> <span class="n">test_even</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">NumbersTest</span><span class="p">)</span>
<span class="o">----------------------------------------------------------------------</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">&quot;subtests.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">32</span><span class="p">,</span> <span class="ow">in</span> <span class="n">test_even</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="ne">AssertionError</span><span class="p">:</span> <span class="mi">1</span> <span class="o">!=</span> <span class="mi">0</span>
</pre></div>
</div>
</section>
<section id="classes-and-functions">
<span id="unittest-contents"></span><h2>Classes e funções<a class="headerlink" href="#classes-and-functions" title="Link permanente para este título">¶</a></h2>
<p>Esta seção descreve de maneira aprofundada a API do módulo <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a>.</p>
<section id="test-cases">
<span id="testcase-objects"></span><h3>Casos de teste<a class="headerlink" href="#test-cases" title="Link permanente para este título">¶</a></h3>
<dl class="py class">
<dt id="unittest.TestCase">
<em class="property">class </em><code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">TestCase</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">methodName</span><span class="o">=</span><span class="default_value">'runTest'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Instâncias da classe <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> representam unidades lógicas de teste no universo do <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a>. Esta classe deve ser utilizada como classe base, com testes específicos sendo implementados por subclasses concretas. Esta classe implementa a interface requerida pelo executor de testes, para permitir o controle dos testes, e métodos que o código de teste pode utilizar para checar e reportar diversos tipos de falhas.</p>
<p>Cada instância da classe <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> irá executar um único método base: o método chamado <em>methodName</em>. Em muitos casos de uso da classe <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>, você não precisará modificar o <em>methodName</em> ou reimplementar o método <code class="docutils literal notranslate"><span class="pre">runTest()</span></code> padrão.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.2: </span><a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> pode ser instanciada com sucesso sem fornecer um <em>methodName</em>. Isso torna mais fácil experimentar com <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> a partir de um interpretador interativo.</p>
</div>
<p>Instâncias <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> possuem três grupos de métodos: um grupo utilizado para executar o teste, outro utilizado pela implementação do teste para checar as condições e reportar falhas, e alguns métodos de investigação para permitir coletar dados sobre o teste em si.</p>
<p>Os métodos do primeiro grupo (que executam os testes) são:</p>
<dl class="py method">
<dt id="unittest.TestCase.setUp">
<code class="sig-name descname">setUp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.setUp" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Método chamado para preparar a definição de contexto de teste. Chamado imediatamente após chamar o método de teste; exceto pelo <a class="reference internal" href="exceptions.html#AssertionError" title="AssertionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AssertionError</span></code></a> ou <a class="reference internal" href="#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SkipTest</span></code></a>, qualquer exceção levantada por este método será considerada um erro além de uma simples falha de teste. A implementação padrão não faz nada.</p>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.tearDown">
<code class="sig-name descname">tearDown</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.tearDown" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Método chamado imediatamente após o método de teste ter sido chamado e o resultado registrado. Este método é chamado mesmo se o método de teste tiver levantado uma exceção, então a implementação em subclasses deve ser feita com cautela ao verificar o estado interno. Qualquer exceção além de <a class="reference internal" href="exceptions.html#AssertionError" title="AssertionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AssertionError</span></code></a> ou <a class="reference internal" href="#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SkipTest</span></code></a> levantada por este método será considerado um erro adicional, e não uma simples falha de teste (que incrementaria o número total de erros no relatório final de testes). Este método será executado apenas se o método <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a> for bem sucedido, independente do resultado do método de teste. A implementação padrão não faz nada.</p>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.setUpClass">
<code class="sig-name descname">setUpClass</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.setUpClass" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Um método de classe chamado antes da execução dos testes de uma classe específica. O método <code class="docutils literal notranslate"><span class="pre">setUpClass</span></code> é chamado com a classe sendo o único argumento e deve ser decorada como um <a class="reference internal" href="functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod()</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">setUpClass</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Veja <a class="reference internal" href="#class-and-module-fixtures">Classes e Módulos de Definição de Contexto</a> para mais detalhes.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.2.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.tearDownClass">
<code class="sig-name descname">tearDownClass</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.tearDownClass" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Um método de classe chamado depois da execução dos testes de uma classe específica. O método <code class="docutils literal notranslate"><span class="pre">tearDownClass</span></code> é chamado com a classe sendo o único argumento e deve ser decorada como um <a class="reference internal" href="functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod()</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">tearDownClass</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Veja <a class="reference internal" href="#class-and-module-fixtures">Classes e Módulos de Definição de Contexto</a> para mais detalhes.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.2.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">result</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.run" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Executa o teste, registrando as informações no objeto resultado <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a>, passado como <em>result</em>. Se <em>result</em> for omitido, ou definido como <code class="docutils literal notranslate"><span class="pre">None</span></code>, um objeto resultado temporário é criado (chamando o método <a class="reference internal" href="#unittest.TestCase.defaultTestResult" title="unittest.TestCase.defaultTestResult"><code class="xref py py-meth docutils literal notranslate"><span class="pre">defaultTestResult()</span></code></a>) e utilizado. O objeto resultado é retornado para quem chamou o método <a class="reference internal" href="#unittest.TestCase.run" title="unittest.TestCase.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run()</span></code></a>.</p>
<p>O mesmo efeito pode ser obtido ao chamar uma instância da classe <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.3: </span>Versões anteriores de <code class="docutils literal notranslate"><span class="pre">run</span></code> não retornavam o resultado. Nem chamando por uma instância.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.skipTest">
<code class="sig-name descname">skipTest</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">reason</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.skipTest" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Ao se executar durante um método de teste ou <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a>, pula o teste em execução. Veja <a class="reference internal" href="#unittest-skipping"><span class="std std-ref">Ignorando testes e falhas esperadas</span></a> para mais informações.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.1.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.subTest">
<code class="sig-name descname">subTest</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">params</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.subTest" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna um gerenciador de contexto que executa, como subteste, o bloco de código englobado. <em>msg</em> e <em>params</em> são valores opcionais e arbitrários que são mostrados sempre quando um subteste falha, permitindo identificá-los claramente.</p>
<p>Um caso de teste pode conter inúmeras declarações de subteste e elas podem ser aninhadas de forma arbitrária.</p>
<p>Veja <a class="reference internal" href="#subtests"><span class="std std-ref">Distinguindo iterações de teste utilizando subtestes</span></a> para mais informações.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.4.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.debug">
<code class="sig-name descname">debug</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.debug" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Executa o teste sem coletar o resultado. Permite propagar exceções levantadas pelo teste e pode ser utilizado para oferecer suporte aos testes sob um depurador.</p>
</dd></dl>

<p id="assert-methods">A classe <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> oferece diversos métodos de asserção para checar e reportar falhas. A tabela a seguir lista os métodos mais utilizados (veja as tabelas abaixo para mais métodos de asserção).</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 48%" />
<col style="width: 34%" />
<col style="width: 18%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Método</p></th>
<th class="head"><p>Avalia se</p></th>
<th class="head"><p>Novo em</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">==</span> <span class="pre">b</span></code></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertNotEqual" title="unittest.TestCase.assertNotEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">!=</span> <span class="pre">b</span></code></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertTrue" title="unittest.TestCase.assertTrue"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertTrue(x)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">bool(x)</span> <span class="pre">is</span> <span class="pre">True</span></code></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertFalse" title="unittest.TestCase.assertFalse"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertFalse(x)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">bool(x)</span> <span class="pre">is</span> <span class="pre">False</span></code></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertIs" title="unittest.TestCase.assertIs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertIs(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">is</span> <span class="pre">b</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertIsNot" title="unittest.TestCase.assertIsNot"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertIsNot(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">b</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertIsNone" title="unittest.TestCase.assertIsNone"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertIsNone(x)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">None</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertIsNotNone" title="unittest.TestCase.assertIsNotNone"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertIsNotNone(x)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">None</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertIn" title="unittest.TestCase.assertIn"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertIn(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">in</span> <span class="pre">b</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertNotIn" title="unittest.TestCase.assertNotIn"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotIn(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">b</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertIsInstance" title="unittest.TestCase.assertIsInstance"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertIsInstance(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">isinstance(a,</span> <span class="pre">b)</span></code></p></td>
<td><p>3.2</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertNotIsInstance" title="unittest.TestCase.assertNotIsInstance"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotIsInstance(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">isinstance(a,</span> <span class="pre">b)</span></code></p></td>
<td><p>3.2</p></td>
</tr>
</tbody>
</table>
<p>Todos os métodos de asserção aceitam um argumento <em>msg</em> que, se especificado, é utilizado como a mensagem de erro em caso de falha (veja também <a class="reference internal" href="#unittest.TestCase.longMessage" title="unittest.TestCase.longMessage"><code class="xref py py-data docutils literal notranslate"><span class="pre">longMessage</span></code></a>). Note que o argumento nomeado <em>msg</em> pode ser passado para <a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaises()</span></code></a>, <a class="reference internal" href="#unittest.TestCase.assertRaisesRegex" title="unittest.TestCase.assertRaisesRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaisesRegex()</span></code></a>, <a class="reference internal" href="#unittest.TestCase.assertWarns" title="unittest.TestCase.assertWarns"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertWarns()</span></code></a> e <a class="reference internal" href="#unittest.TestCase.assertWarnsRegex" title="unittest.TestCase.assertWarnsRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertWarnsRegex()</span></code></a> apenas quando eles são utilizados como gerenciador de contexto.</p>
<dl class="py method">
<dt id="unittest.TestCase.assertEqual">
<code class="sig-name descname">assertEqual</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">first</span></em>, <em class="sig-param"><span class="n">second</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertEqual" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Testa se <em>first</em> e <em>second</em> são iguais. Se o resultado da comparação não indicar igualdade, o teste irá falhar.</p>
<p>Além disso, se <em>first</em> e <em>second</em> são exatamente do mesmo tipo e são uma lista, tupla, dict, set, frozenset, str, ou qualquer outro tipo que é registrado na subclasse com <a class="reference internal" href="#unittest.TestCase.addTypeEqualityFunc" title="unittest.TestCase.addTypeEqualityFunc"><code class="xref py py-meth docutils literal notranslate"><span class="pre">addTypeEqualityFunc()</span></code></a>, a função de igualdade específica do tipo é será chamada para gerar uma mensagem de erro mais útil (veja também <a class="reference internal" href="#type-specific-methods"><span class="std std-ref">lista de métodos específicos por tipo</span></a>)</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.1: </span>Adição da chamada automática da função específica por tipo.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.2: </span>método <a class="reference internal" href="#unittest.TestCase.assertMultiLineEqual" title="unittest.TestCase.assertMultiLineEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertMultiLineEqual()</span></code></a> adicionado como função de igualdade padrão para o tipo string.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.assertNotEqual">
<code class="sig-name descname">assertNotEqual</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">first</span></em>, <em class="sig-param"><span class="n">second</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertNotEqual" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Testa se <em>first</em> e <em>second</em> não são iguais. Se o resultado da comparação indicar igualdade, o teste irá falhar.</p>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.assertTrue">
<code class="sig-name descname">assertTrue</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">expr</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertTrue" title="Link permanente para esta definição">¶</a></dt>
<dt id="unittest.TestCase.assertFalse">
<code class="sig-name descname">assertFalse</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">expr</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertFalse" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Testa se a expressão <em>expr</em> é verdadeira (ou falsa).</p>
<p>Note que isso é equivalente a <code class="docutils literal notranslate"><span class="pre">bool(expr)</span> <span class="pre">is</span> <span class="pre">True</span></code> e não a <code class="docutils literal notranslate"><span class="pre">expr</span> <span class="pre">is</span> <span class="pre">True</span></code> (use <code class="docutils literal notranslate"><span class="pre">assertIs(expr,</span> <span class="pre">True)</span></code> neste último caso). Este método também deve ser evitado quando outros métodos mais específicos estão disponíveis (e.g. <code class="docutils literal notranslate"><span class="pre">assertEqual(a,</span> <span class="pre">b)</span></code> no lugar de <code class="docutils literal notranslate"><span class="pre">assertTrue(a</span> <span class="pre">==</span> <span class="pre">b)</span></code>), já que estes podem ter uma melhor mensagem de erro em caso de falha.</p>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.assertIs">
<code class="sig-name descname">assertIs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">first</span></em>, <em class="sig-param"><span class="n">second</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertIs" title="Link permanente para esta definição">¶</a></dt>
<dt id="unittest.TestCase.assertIsNot">
<code class="sig-name descname">assertIsNot</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">first</span></em>, <em class="sig-param"><span class="n">second</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertIsNot" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Testa que <em>first</em> e <em>second</em> são (ou não são) o mesmo objeto.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.1.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.assertIsNone">
<code class="sig-name descname">assertIsNone</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">expr</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertIsNone" title="Link permanente para esta definição">¶</a></dt>
<dt id="unittest.TestCase.assertIsNotNone">
<code class="sig-name descname">assertIsNotNone</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">expr</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertIsNotNone" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Testa se <em>expr</em> é (ou não é) <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.1.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.assertIn">
<code class="sig-name descname">assertIn</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">member</span></em>, <em class="sig-param"><span class="n">container</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertIn" title="Link permanente para esta definição">¶</a></dt>
<dt id="unittest.TestCase.assertNotIn">
<code class="sig-name descname">assertNotIn</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">member</span></em>, <em class="sig-param"><span class="n">container</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertNotIn" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Testa se <em>member</em> está (ou não está) em <em>container</em>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.1.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.assertIsInstance">
<code class="sig-name descname">assertIsInstance</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">obj</span></em>, <em class="sig-param"><span class="n">cls</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertIsInstance" title="Link permanente para esta definição">¶</a></dt>
<dt id="unittest.TestCase.assertNotIsInstance">
<code class="sig-name descname">assertNotIsInstance</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">obj</span></em>, <em class="sig-param"><span class="n">cls</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertNotIsInstance" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Testa se <em>obj</em> é (ou não é) uma instância de <em>cls</em> (que pode ser uma classe ou uma tupla de classes, como suportado pela função <a class="reference internal" href="functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a>). Para checar pelo tipo exato, use <a class="reference internal" href="#unittest.TestCase.assertIs" title="unittest.TestCase.assertIs"><code class="xref py py-func docutils literal notranslate"><span class="pre">assertIs(type(obj),</span> <span class="pre">cls)</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.2.</span></p>
</div>
</dd></dl>

<p>Também é possível checar a produção de exceções, avisos e mensagens de log usando os seguintes métodos:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 53%" />
<col style="width: 36%" />
<col style="width: 11%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Método</p></th>
<th class="head"><p>Avalia se</p></th>
<th class="head"><p>Novo em</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaises(exc,</span> <span class="pre">fun,</span> <span class="pre">*args,</span> <span class="pre">**kwds)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">fun(*args,</span> <span class="pre">**kwds)</span></code> levanta <em>exc</em></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertRaisesRegex" title="unittest.TestCase.assertRaisesRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaisesRegex(exc,</span> <span class="pre">r,</span> <span class="pre">fun,</span> <span class="pre">*args,</span> <span class="pre">**kwds)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">fun(*args,</span> <span class="pre">**kwds)</span></code> levanta <em>exc</em> e a mensagem casa com a expressão regular <em>r</em></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertWarns" title="unittest.TestCase.assertWarns"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertWarns(warn,</span> <span class="pre">fun,</span> <span class="pre">*args,</span> <span class="pre">**kwds)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">fun(*args,</span> <span class="pre">**kwds)</span></code> levanta <em>warn</em></p></td>
<td><p>3.2</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertWarnsRegex" title="unittest.TestCase.assertWarnsRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertWarnsRegex(warn,</span> <span class="pre">r,</span> <span class="pre">fun,</span> <span class="pre">*args,</span> <span class="pre">**kwds)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">fun(*args,</span> <span class="pre">**kwds)</span></code> levanta <em>warn</em> e a mensagem casa com a expressão regular <em>r</em></p></td>
<td><p>3.2</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertLogs" title="unittest.TestCase.assertLogs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertLogs(logger,</span> <span class="pre">level)</span></code></a></p></td>
<td><p>O bloco <code class="docutils literal notranslate"><span class="pre">with</span></code> registra logs no <em>logger</em> com pelo menos um nível <em>level</em></p></td>
<td><p>Módulos para processamento de XML</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertNoLogs" title="unittest.TestCase.assertNoLogs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNoLogs(logger,</span> <span class="pre">level)</span></code></a></p></td>
<td><dl class="simple">
<dt>O bloco <code class="docutils literal notranslate"><span class="pre">with</span></code> não loga em</dt><dd><p><em>logger</em> com <em>level</em> mínimo</p>
</dd>
</dl>
</td>
<td><p>3.10</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="unittest.TestCase.assertRaises">
<code class="sig-name descname">assertRaises</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">exception</span></em>, <em class="sig-param"><span class="n">callable</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertRaises" title="Link permanente para esta definição">¶</a></dt>
<dt>
<code class="sig-name descname">assertRaises</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">exception</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span></dt>
<dd><p>Testa se uma exceção é levantada quando <em>callable</em> é chamado com quaisquer argumentos nomeados ou posicionais que também são passados para <a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaises()</span></code></a>. O teste passa se <em>exception</em> for levantada e falha se outra exceção ou nenhuma exceção for levantada.</p>
<p>Se somente os argumentos <em>exception</em> e, possivelmente, <em>msg</em> forem passados, retorna um gerenciador de contexto para que o código sob teste possa ser escrito de forma embutida ao invés de ser definido como uma função:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertRaises</span><span class="p">(</span><span class="n">SomeException</span><span class="p">):</span>
    <span class="n">do_something</span><span class="p">()</span>
</pre></div>
</div>
<p>Quando utilizado como gerenciador de contexto, <a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaises()</span></code></a> aceita o argumento nomeado adicional <em>msg</em>.</p>
<p>O gerenciador de contexto irá armazenar o objeto exceção capturado no seu atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">exception</span></code>. Isso pode ser útil se a intenção for realizar testes adicionais na exceção levantada:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertRaises</span><span class="p">(</span><span class="n">SomeException</span><span class="p">)</span> <span class="k">as</span> <span class="n">cm</span><span class="p">:</span>
    <span class="n">do_something</span><span class="p">()</span>

<span class="n">the_exception</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">exception</span>
<span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">the_exception</span><span class="o">.</span><span class="n">error_code</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.1: </span>Adicionada a possibilidade de se utilizar <a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaises()</span></code></a> como gerenciador de contexto.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.2: </span>Adicionado o atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">exception</span></code>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.3: </span>Adicionado o argumento nomeado <em>msg</em> quando utilizado como gerenciador de contexto.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.assertRaisesRegex">
<code class="sig-name descname">assertRaisesRegex</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">exception</span></em>, <em class="sig-param"><span class="n">regex</span></em>, <em class="sig-param"><span class="n">callable</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertRaisesRegex" title="Link permanente para esta definição">¶</a></dt>
<dt>
<code class="sig-name descname">assertRaisesRegex</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">exception</span></em>, <em class="sig-param"><span class="n">regex</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span></dt>
<dd><p>Similar ao <a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaises()</span></code></a> mas também testa se <em>regex</em> casa com a representação em string da exceção levantada. <em>regex</em> pode ser um objeto expressão regular ou uma string contendo uma expressão regular compatível com o uso pela função <a class="reference internal" href="re.html#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.search()</span></code></a>. Exemplos:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">assertRaisesRegex</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="s2">&quot;invalid literal for.*XYZ&#39;$&quot;</span><span class="p">,</span>
                       <span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;XYZ&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>or:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertRaisesRegex</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="s1">&#39;literal&#39;</span><span class="p">):</span>
   <span class="nb">int</span><span class="p">(</span><span class="s1">&#39;XYZ&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.1: </span>Adicionado com o nome <code class="docutils literal notranslate"><span class="pre">assertRaisesRegexp</span></code>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.2: </span>Renomeado para <a class="reference internal" href="#unittest.TestCase.assertRaisesRegex" title="unittest.TestCase.assertRaisesRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaisesRegex()</span></code></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.3: </span>Adicionado o argumento nomeado <em>msg</em> quando utilizado como gerenciador de contexto.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.assertWarns">
<code class="sig-name descname">assertWarns</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">warning</span></em>, <em class="sig-param"><span class="n">callable</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertWarns" title="Link permanente para esta definição">¶</a></dt>
<dt>
<code class="sig-name descname">assertWarns</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">warning</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span></dt>
<dd><p>Testa se o aviso <em>warning</em> é acionado quando <em>callable</em> é chamado com quaisquer argumentos nomeados ou posicionais que também são passados para <a class="reference internal" href="#unittest.TestCase.assertWarns" title="unittest.TestCase.assertWarns"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertWarns()</span></code></a>. O teste passa se <em>warning</em> for acionado e falha se não for. Qualquer exceção é considerada como falha. Para capturar qualquer aviso presente em um grupo de avisos, uma tupla contendo as classes de aviso podem ser passadas como <em>warning</em>.</p>
<p>Se apenas os argumentos <em>warning</em> e, possivelmente, <em>msg</em> forem passados, retorna um gerenciador de contexto para que o código sob teste possa ser escrito de forma embutida ao invés de ser definido como uma função:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertWarns</span><span class="p">(</span><span class="n">SomeWarning</span><span class="p">):</span>
    <span class="n">do_something</span><span class="p">()</span>
</pre></div>
</div>
<p>Quando usado como gerenciador de contexto, <a class="reference internal" href="#unittest.TestCase.assertWarns" title="unittest.TestCase.assertWarns"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertWarns()</span></code></a> aceita o argumento nomeado adicional <em>msg</em>.</p>
<p>O gerenciador de contexto irá armazenar o objeto de aviso capturado no atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">warning</span></code> e a linha de código fonte que acionou o aviso nos atributos <code class="xref py py-attr docutils literal notranslate"><span class="pre">filename</span></code> e <code class="xref py py-attr docutils literal notranslate"><span class="pre">lineno</span></code>. Isso pode ser útil se a intenção for executar verificações adicionais no aviso capturado:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertWarns</span><span class="p">(</span><span class="n">SomeWarning</span><span class="p">)</span> <span class="k">as</span> <span class="n">cm</span><span class="p">:</span>
    <span class="n">do_something</span><span class="p">()</span>

<span class="bp">self</span><span class="o">.</span><span class="n">assertIn</span><span class="p">(</span><span class="s1">&#39;myfile.py&#39;</span><span class="p">,</span> <span class="n">cm</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="mi">320</span><span class="p">,</span> <span class="n">cm</span><span class="o">.</span><span class="n">lineno</span><span class="p">)</span>
</pre></div>
</div>
<p>Este método funciona independente dos filtros de aviso configurados no momento em que é chamado.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.2.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.3: </span>Adicionado o argumento nomeado <em>msg</em> quando utilizado como gerenciador de contexto.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.assertWarnsRegex">
<code class="sig-name descname">assertWarnsRegex</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">warning</span></em>, <em class="sig-param"><span class="n">regex</span></em>, <em class="sig-param"><span class="n">callable</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertWarnsRegex" title="Link permanente para esta definição">¶</a></dt>
<dt>
<code class="sig-name descname">assertWarnsRegex</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">warning</span></em>, <em class="sig-param"><span class="n">regex</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span></dt>
<dd><p>Similar ao <a class="reference internal" href="#unittest.TestCase.assertWarns" title="unittest.TestCase.assertWarns"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertWarns()</span></code></a> mas também testa se <em>regex</em> casa com a mensagem do aviso acionado. <em>regex</em> pode ser um objeto expressão regular ou uma string contendo uma expressão regular compatível para uso pela função <a class="reference internal" href="re.html#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.search()</span></code></a>. Exemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">assertWarnsRegex</span><span class="p">(</span><span class="ne">DeprecationWarning</span><span class="p">,</span>
                      <span class="sa">r</span><span class="s1">&#39;legacy_function\(\) is deprecated&#39;</span><span class="p">,</span>
                      <span class="n">legacy_function</span><span class="p">,</span> <span class="s1">&#39;XYZ&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>or:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertWarnsRegex</span><span class="p">(</span><span class="ne">RuntimeWarning</span><span class="p">,</span> <span class="s1">&#39;unsafe frobnicating&#39;</span><span class="p">):</span>
    <span class="n">frobnicate</span><span class="p">(</span><span class="s1">&#39;/etc/passwd&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.2.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.3: </span>Adicionado o argumento nomeado <em>msg</em> quando utilizado como gerenciador de contexto.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.assertLogs">
<code class="sig-name descname">assertLogs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">logger</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertLogs" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Um gerenciador de contexto para testar se pelo menos uma mensagem é inserida em <em>logger</em> ou em um de seus filhos, com pelo menos um nível <em>level</em>.</p>
<p>Se fornecido, <em>logger</em> deve ser um objeto <a class="reference internal" href="logging.html#logging.Logger" title="logging.Logger"><code class="xref py py-class docutils literal notranslate"><span class="pre">logging.Logger</span></code></a> ou uma <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> fornecendo o nome de um logger. O padrão é o logger root, o qual irá capturar todas as mensagens que não foram bloqueadas por um logger descendente não-propagante.</p>
<p>Se passado, <em>level</em> deve ser um nível de log numérico ou a string equivalente (por exemplo, <code class="docutils literal notranslate"><span class="pre">&quot;ERROR&quot;</span></code> ou <code class="xref py py-attr docutils literal notranslate"><span class="pre">logging.ERROR</span></code>). O padrão é <code class="xref py py-attr docutils literal notranslate"><span class="pre">logging.INFO</span></code>.</p>
<p>O teste passa se pelo menos uma das mensagens emitidas dentro do bloco <code class="docutils literal notranslate"><span class="pre">with</span></code> casa com as condições dadas por <em>logger</em> e <em>level</em>, falhando caso contrário.</p>
<p>O objeto retornado pelo gerenciador de contexto é um registro auxiliar que mantém os rastros das mensagens de log capturadas de acordo com os critérios dados. Ele possui dois atributos:</p>
<dl class="py attribute">
<dt id="unittest.TestCase.records">
<code class="sig-name descname">records</code><a class="headerlink" href="#unittest.TestCase.records" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Uma lista de objetos de log da classe <a class="reference internal" href="logging.html#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">logging.LogRecord</span></code></a> que foram compatíveis com os critérios dados.</p>
</dd></dl>

<dl class="py attribute">
<dt id="unittest.TestCase.output">
<code class="sig-name descname">output</code><a class="headerlink" href="#unittest.TestCase.output" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Uma lista de objetos da classe <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> com a saída formatada das mensagens de log compatíveis com os critérios dados.</p>
</dd></dl>

<p>Exemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertLogs</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s1">&#39;INFO&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">cm</span><span class="p">:</span>
   <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;first message&#39;</span><span class="p">)</span>
   <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;foo.bar&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;second message&#39;</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">cm</span><span class="o">.</span><span class="n">output</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;INFO:foo:first message&#39;</span><span class="p">,</span>
                             <span class="s1">&#39;ERROR:foo.bar:second message&#39;</span><span class="p">])</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.4.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.assertNoLogs">
<code class="sig-name descname">assertNoLogs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">logger</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertNoLogs" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Um gerenciador de contexto para testar que nenhuma mensagem é logada no <em>logger</em> ou um dos seus filhos, com pelo menos o <em>level</em> fornecido.</p>
<p>Se passado, <em>logger</em> deve ser um objeto da classe <a class="reference internal" href="logging.html#logging.Logger" title="logging.Logger"><code class="xref py py-class docutils literal notranslate"><span class="pre">logging.Logger</span></code></a> ou um objeto da classe <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> com o nome do registrador de logs. O padrão é o registrador de log raíz, que irá capturar todas as mensagens.</p>
<p>Se passado, <em>level</em> deve ser um nível de log numérico ou a string equivalente (por exemplo, <code class="docutils literal notranslate"><span class="pre">&quot;ERROR&quot;</span></code> ou <code class="xref py py-attr docutils literal notranslate"><span class="pre">logging.ERROR</span></code>). O padrão é <code class="xref py py-attr docutils literal notranslate"><span class="pre">logging.INFO</span></code>.</p>
<p>Ao contrário de <a class="reference internal" href="#unittest.TestCase.assertLogs" title="unittest.TestCase.assertLogs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertLogs()</span></code></a>, nada será retornado pelo gerenciador de contexto.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.10.</span></p>
</div>
</dd></dl>

<p>Existem também outros métodos usados para executar verificações mais específicas, como:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 46%" />
<col style="width: 38%" />
<col style="width: 16%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Método</p></th>
<th class="head"><p>Avalia se</p></th>
<th class="head"><p>Novo em</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertAlmostEqual" title="unittest.TestCase.assertAlmostEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertAlmostEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">round(a-b,</span> <span class="pre">7)</span> <span class="pre">==</span> <span class="pre">0</span></code></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertNotAlmostEqual" title="unittest.TestCase.assertNotAlmostEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotAlmostEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">round(a-b,</span> <span class="pre">7)</span> <span class="pre">!=</span> <span class="pre">0</span></code></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertGreater" title="unittest.TestCase.assertGreater"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertGreater(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&gt;</span> <span class="pre">b</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertGreaterEqual" title="unittest.TestCase.assertGreaterEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertGreaterEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&gt;=</span> <span class="pre">b</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertLess" title="unittest.TestCase.assertLess"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertLess(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">b</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertLessEqual" title="unittest.TestCase.assertLessEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertLessEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&lt;=</span> <span class="pre">b</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertRegex" title="unittest.TestCase.assertRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRegex(s,</span> <span class="pre">r)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">r.search(s)</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertNotRegex" title="unittest.TestCase.assertNotRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotRegex(s,</span> <span class="pre">r)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">r.search(s)</span></code></p></td>
<td><p>3.2</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertCountEqual" title="unittest.TestCase.assertCountEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertCountEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><em>a</em> e <em>b</em> possuem os mesmos elementos na mesma quantidade, independente da sua ordem.</p></td>
<td><p>3.2</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="unittest.TestCase.assertAlmostEqual">
<code class="sig-name descname">assertAlmostEqual</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">first</span></em>, <em class="sig-param"><span class="n">second</span></em>, <em class="sig-param"><span class="n">places</span><span class="o">=</span><span class="default_value">7</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">delta</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertAlmostEqual" title="Link permanente para esta definição">¶</a></dt>
<dt id="unittest.TestCase.assertNotAlmostEqual">
<code class="sig-name descname">assertNotAlmostEqual</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">first</span></em>, <em class="sig-param"><span class="n">second</span></em>, <em class="sig-param"><span class="n">places</span><span class="o">=</span><span class="default_value">7</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">delta</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertNotAlmostEqual" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Testa se <em>first</em> e <em>second</em> são (ou não são) aproximadamente iguais considerando a diferença entre eles, arredondando para o número de casas decimais dado (7 por padrão), e comparando a zero. Note que estes métodos arredondam os valores considerando o número de casas decimais (i.e. como a função <a class="reference internal" href="functions.html#round" title="round"><code class="xref py py-func docutils literal notranslate"><span class="pre">round()</span></code></a>) e não o número de algarismos significativos.</p>
<p>Se <em>delta</em> é fornecido no lugar de <em>places</em>, a diferença entre <em>first</em> e <em>second</em> deve ser menor ou igual a (ou maior que) <em>delta</em>.</p>
<p>Passar <em>delta</em> e <em>places</em> ao mesmo tempo levanta a exceção <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.2: </span><a class="reference internal" href="#unittest.TestCase.assertAlmostEqual" title="unittest.TestCase.assertAlmostEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertAlmostEqual()</span></code></a> considera, automaticamente, objetos quase iguais que possuem a comparação de igualdade dada como verdadeira. <a class="reference internal" href="#unittest.TestCase.assertNotAlmostEqual" title="unittest.TestCase.assertNotAlmostEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotAlmostEqual()</span></code></a> falha automaticamente se os objetos possuem a comparação de igualdade dada como verdadeira. Adicionado o argumento nomeado <em>delta</em>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.assertGreater">
<code class="sig-name descname">assertGreater</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">first</span></em>, <em class="sig-param"><span class="n">second</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertGreater" title="Link permanente para esta definição">¶</a></dt>
<dt id="unittest.TestCase.assertGreaterEqual">
<code class="sig-name descname">assertGreaterEqual</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">first</span></em>, <em class="sig-param"><span class="n">second</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertGreaterEqual" title="Link permanente para esta definição">¶</a></dt>
<dt id="unittest.TestCase.assertLess">
<code class="sig-name descname">assertLess</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">first</span></em>, <em class="sig-param"><span class="n">second</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertLess" title="Link permanente para esta definição">¶</a></dt>
<dt id="unittest.TestCase.assertLessEqual">
<code class="sig-name descname">assertLessEqual</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">first</span></em>, <em class="sig-param"><span class="n">second</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertLessEqual" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Testa que <em>first</em> é respectivamente &gt;, &gt;=, &lt; ou &lt;= que <em>second</em>, dependendo do nome do método. Se não for, o teste irá falhar:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="bp">self</span><span class="o">.</span><span class="n">assertGreaterEqual</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">AssertionError: &quot;3&quot; unexpectedly not greater than or equal to &quot;4&quot;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.1.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.assertRegex">
<code class="sig-name descname">assertRegex</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">text</span></em>, <em class="sig-param"><span class="n">regex</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertRegex" title="Link permanente para esta definição">¶</a></dt>
<dt id="unittest.TestCase.assertNotRegex">
<code class="sig-name descname">assertNotRegex</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">text</span></em>, <em class="sig-param"><span class="n">regex</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertNotRegex" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Testa que uma procura por <em>regex</em> corresponde (ou não corresponde) a <em>text</em>. Em caso de falha, a mensagem de erro irá incluir o padrão e o <em>text</em> (ou o padrão e a parte do <em>text</em> que inesperadamente correspondeu). <em>regex</em> pode ser um objeto de expressão regular ou uma string contendo uma expressão regular adequada para uso por <a class="reference internal" href="re.html#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.search()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.1: </span>Adicionada abaixo do nome <code class="docutils literal notranslate"><span class="pre">assertRegexpMatches</span></code>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.2: </span>O método <code class="docutils literal notranslate"><span class="pre">assertRegexpMatches()</span></code> foi renomeado para <a class="reference internal" href="#unittest.TestCase.assertRegex" title="unittest.TestCase.assertRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRegex()</span></code></a>.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.2: </span><a class="reference internal" href="#unittest.TestCase.assertNotRegex" title="unittest.TestCase.assertNotRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotRegex()</span></code></a>.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.5: </span>O nome <code class="docutils literal notranslate"><span class="pre">assertNotRegexpMatches</span></code> é um apelido descontinuado para <a class="reference internal" href="#unittest.TestCase.assertNotRegex" title="unittest.TestCase.assertNotRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotRegex()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.assertCountEqual">
<code class="sig-name descname">assertCountEqual</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">first</span></em>, <em class="sig-param"><span class="n">second</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertCountEqual" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Test that sequence <em>first</em> contains the same elements as <em>second</em>,
regardless of their order. When they don’t, an error message listing the
differences between the sequences will be generated.</p>
<p>Elementos duplicados <em>não</em> são ignorados ao comparar <em>first</em> e <em>second</em>. É verificado se cada elemento tem a mesma contagem em ambas sequências. Equivalente a: <code class="docutils literal notranslate"><span class="pre">assertEqual(Counter(list(first)),</span> <span class="pre">Counter(list(second)))</span></code>, mas também funciona com sequências de objetos não hasheáveis.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.2.</span></p>
</div>
</dd></dl>

<p id="type-specific-methods">The <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a> method dispatches the equality check for objects of
the same type to different type-specific methods.  These methods are already
implemented for most of the built-in types, but it’s also possible to
register new methods using <a class="reference internal" href="#unittest.TestCase.addTypeEqualityFunc" title="unittest.TestCase.addTypeEqualityFunc"><code class="xref py py-meth docutils literal notranslate"><span class="pre">addTypeEqualityFunc()</span></code></a>:</p>
<dl class="py method">
<dt id="unittest.TestCase.addTypeEqualityFunc">
<code class="sig-name descname">addTypeEqualityFunc</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">typeobj</span></em>, <em class="sig-param"><span class="n">function</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.addTypeEqualityFunc" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Registers a type-specific method called by <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a> to check
if two objects of exactly the same <em>typeobj</em> (not subclasses) compare
equal.  <em>function</em> must take two positional arguments and a third msg=None
keyword argument just as <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a> does.  It must raise
<a class="reference internal" href="#unittest.TestCase.failureException" title="unittest.TestCase.failureException"><code class="xref py py-data docutils literal notranslate"><span class="pre">self.failureException(msg)</span></code></a> when inequality
between the first two parameters is detected – possibly providing useful
information and explaining the inequalities in details in the error
message.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.1.</span></p>
</div>
</dd></dl>

<p>The list of type-specific methods automatically used by
<a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a> are summarized in the following table.  Note
that it’s usually not necessary to invoke these methods directly.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 49%" />
<col style="width: 35%" />
<col style="width: 17%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Método</p></th>
<th class="head"><p>Usado para comparar</p></th>
<th class="head"><p>Novo em</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertMultiLineEqual" title="unittest.TestCase.assertMultiLineEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertMultiLineEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p>strings</p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertSequenceEqual" title="unittest.TestCase.assertSequenceEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertSequenceEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p>sequências</p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertListEqual" title="unittest.TestCase.assertListEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertListEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p>listas</p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertTupleEqual" title="unittest.TestCase.assertTupleEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertTupleEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p>tuplas</p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertSetEqual" title="unittest.TestCase.assertSetEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertSetEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p>sets ou frozensets</p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertDictEqual" title="unittest.TestCase.assertDictEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertDictEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p>dicionários</p></td>
<td><p>3.1</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="unittest.TestCase.assertMultiLineEqual">
<code class="sig-name descname">assertMultiLineEqual</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">first</span></em>, <em class="sig-param"><span class="n">second</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertMultiLineEqual" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Test that the multiline string <em>first</em> is equal to the string <em>second</em>.
When not equal a diff of the two strings highlighting the differences
will be included in the error message. This method is used by default
when comparing strings with <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.1.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.assertSequenceEqual">
<code class="sig-name descname">assertSequenceEqual</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">first</span></em>, <em class="sig-param"><span class="n">second</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">seq_type</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertSequenceEqual" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Tests that two sequences are equal.  If a <em>seq_type</em> is supplied, both
<em>first</em> and <em>second</em> must be instances of <em>seq_type</em> or a failure will
be raised.  If the sequences are different an error message is
constructed that shows the difference between the two.</p>
<p>This method is not called directly by <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a>, but
it’s used to implement <a class="reference internal" href="#unittest.TestCase.assertListEqual" title="unittest.TestCase.assertListEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertListEqual()</span></code></a> and
<a class="reference internal" href="#unittest.TestCase.assertTupleEqual" title="unittest.TestCase.assertTupleEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertTupleEqual()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.1.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.assertListEqual">
<code class="sig-name descname">assertListEqual</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">first</span></em>, <em class="sig-param"><span class="n">second</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertListEqual" title="Link permanente para esta definição">¶</a></dt>
<dt id="unittest.TestCase.assertTupleEqual">
<code class="sig-name descname">assertTupleEqual</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">first</span></em>, <em class="sig-param"><span class="n">second</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertTupleEqual" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Tests that two lists or tuples are equal.  If not, an error message is
constructed that shows only the differences between the two.  An error
is also raised if either of the parameters are of the wrong type.
These methods are used by default when comparing lists or tuples with
<a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.1.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.assertSetEqual">
<code class="sig-name descname">assertSetEqual</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">first</span></em>, <em class="sig-param"><span class="n">second</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertSetEqual" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Tests that two sets are equal.  If not, an error message is constructed
that lists the differences between the sets.  This method is used by
default when comparing sets or frozensets with <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a>.</p>
<p>Fails if either of <em>first</em> or <em>second</em> does not have a <code class="xref py py-meth docutils literal notranslate"><span class="pre">set.difference()</span></code>
method.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.1.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.assertDictEqual">
<code class="sig-name descname">assertDictEqual</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">first</span></em>, <em class="sig-param"><span class="n">second</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertDictEqual" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Test that two dictionaries are equal.  If not, an error message is
constructed that shows the differences in the dictionaries. This
method will be used by default to compare dictionaries in
calls to <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.1.</span></p>
</div>
</dd></dl>

<p id="other-methods-and-attrs">Finally the <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> provides the following methods and attributes:</p>
<dl class="py method">
<dt id="unittest.TestCase.fail">
<code class="sig-name descname">fail</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.fail" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Signals a test failure unconditionally, with <em>msg</em> or <code class="docutils literal notranslate"><span class="pre">None</span></code> for
the error message.</p>
</dd></dl>

<dl class="py attribute">
<dt id="unittest.TestCase.failureException">
<code class="sig-name descname">failureException</code><a class="headerlink" href="#unittest.TestCase.failureException" title="Link permanente para esta definição">¶</a></dt>
<dd><p>This class attribute gives the exception raised by the test method.  If a
test framework needs to use a specialized exception, possibly to carry
additional information, it must subclass this exception in order to “play
fair” with the framework.  The initial value of this attribute is
<a class="reference internal" href="exceptions.html#AssertionError" title="AssertionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AssertionError</span></code></a>.</p>
</dd></dl>

<dl class="py attribute">
<dt id="unittest.TestCase.longMessage">
<code class="sig-name descname">longMessage</code><a class="headerlink" href="#unittest.TestCase.longMessage" title="Link permanente para esta definição">¶</a></dt>
<dd><p>This class attribute determines what happens when a custom failure message
is passed as the msg argument to an assertXYY call that fails.
<code class="docutils literal notranslate"><span class="pre">True</span></code> is the default value. In this case, the custom message is appended
to the end of the standard failure message.
When set to <code class="docutils literal notranslate"><span class="pre">False</span></code>, the custom message replaces the standard message.</p>
<p>The class setting can be overridden in individual test methods by assigning
an instance attribute, self.longMessage, to <code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code> before
calling the assert methods.</p>
<p>The class setting gets reset before each test call.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.1.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="unittest.TestCase.maxDiff">
<code class="sig-name descname">maxDiff</code><a class="headerlink" href="#unittest.TestCase.maxDiff" title="Link permanente para esta definição">¶</a></dt>
<dd><p>This attribute controls the maximum length of diffs output by assert
methods that report diffs on failure. It defaults to 80*8 characters.
Assert methods affected by this attribute are
<a class="reference internal" href="#unittest.TestCase.assertSequenceEqual" title="unittest.TestCase.assertSequenceEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertSequenceEqual()</span></code></a> (including all the sequence comparison
methods that delegate to it), <a class="reference internal" href="#unittest.TestCase.assertDictEqual" title="unittest.TestCase.assertDictEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertDictEqual()</span></code></a> and
<a class="reference internal" href="#unittest.TestCase.assertMultiLineEqual" title="unittest.TestCase.assertMultiLineEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertMultiLineEqual()</span></code></a>.</p>
<p>Setting <code class="docutils literal notranslate"><span class="pre">maxDiff</span></code> to <code class="docutils literal notranslate"><span class="pre">None</span></code> means that there is no maximum length of
diffs.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.2.</span></p>
</div>
</dd></dl>

<p>Frameworks de teste podem usar os seguintes métodos para coletar informações sobre o teste:</p>
<dl class="py method">
<dt id="unittest.TestCase.countTestCases">
<code class="sig-name descname">countTestCases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.countTestCases" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna o número de testes representados por esse objeto de teste. Para instâncias <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> será sempre``1``.</p>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.defaultTestResult">
<code class="sig-name descname">defaultTestResult</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.defaultTestResult" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Return an instance of the test result class that should be used for this
test case class (if no other result instance is provided to the
<a class="reference internal" href="#unittest.TestCase.run" title="unittest.TestCase.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run()</span></code></a> method).</p>
<p>For <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> instances, this will always be an instance of
<a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a>; subclasses of <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> should override this
as necessary.</p>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.id">
<code class="sig-name descname">id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.id" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna uma string identificando o caso de teste específico. Geralmente é o nome completo do método do teste, incluindo o módulo e o nome da classe.</p>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.shortDescription">
<code class="sig-name descname">shortDescription</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.shortDescription" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna uma descrição do teste ou``None`` se nenhuma descrição for fornecida. A implementação padrão desse método retorna a primeira linha da docstring do método do teste, se disponível, ou <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.1: </span>In 3.1 this was changed to add the test name to the short description
even in the presence of a docstring.  This caused compatibility issues
with unittest extensions and adding the test name was moved to the
<a class="reference internal" href="#unittest.TextTestResult" title="unittest.TextTestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TextTestResult</span></code></a> in Python 3.2.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.addCleanup">
<code class="sig-name descname">addCleanup</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">function</span></em>, <em class="sig-param"><span class="o">/</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.addCleanup" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Add a function to be called after <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDown()</span></code></a> to cleanup resources
used during the test. Functions will be called in reverse order to the
order they are added (<abbr title="last-in, first-out">LIFO</abbr>).  They
are called with any arguments and keyword arguments passed into
<a class="reference internal" href="#unittest.TestCase.addCleanup" title="unittest.TestCase.addCleanup"><code class="xref py py-meth docutils literal notranslate"><span class="pre">addCleanup()</span></code></a> when they are added.</p>
<p>If <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a> fails, meaning that <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDown()</span></code></a> is not called,
then any cleanup functions added will still be called.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.1.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.doCleanups">
<code class="sig-name descname">doCleanups</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.doCleanups" title="Link permanente para esta definição">¶</a></dt>
<dd><p>This method is called unconditionally after <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDown()</span></code></a>, or
after <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a> if <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a> raises an exception.</p>
<p>It is responsible for calling all the cleanup functions added by
<a class="reference internal" href="#unittest.TestCase.addCleanup" title="unittest.TestCase.addCleanup"><code class="xref py py-meth docutils literal notranslate"><span class="pre">addCleanup()</span></code></a>. If you need cleanup functions to be called
<em>prior</em> to <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDown()</span></code></a> then you can call <a class="reference internal" href="#unittest.TestCase.doCleanups" title="unittest.TestCase.doCleanups"><code class="xref py py-meth docutils literal notranslate"><span class="pre">doCleanups()</span></code></a>
yourself.</p>
<p><a class="reference internal" href="#unittest.TestCase.doCleanups" title="unittest.TestCase.doCleanups"><code class="xref py py-meth docutils literal notranslate"><span class="pre">doCleanups()</span></code></a> pops methods off the stack of cleanup
functions one at a time, so it can be called at any time.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.1.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.addClassCleanup">
<em class="property">classmethod </em><code class="sig-name descname">addClassCleanup</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">function</span></em>, <em class="sig-param"><span class="o">/</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.addClassCleanup" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Add a function to be called after <a class="reference internal" href="#unittest.TestCase.tearDownClass" title="unittest.TestCase.tearDownClass"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDownClass()</span></code></a> to cleanup
resources used during the test class. Functions will be called in reverse
order to the order they are added (<abbr title="last-in, first-out">LIFO</abbr>).
They are called with any arguments and keyword arguments passed into
<a class="reference internal" href="#unittest.TestCase.addClassCleanup" title="unittest.TestCase.addClassCleanup"><code class="xref py py-meth docutils literal notranslate"><span class="pre">addClassCleanup()</span></code></a> when they are added.</p>
<p>If <a class="reference internal" href="#unittest.TestCase.setUpClass" title="unittest.TestCase.setUpClass"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUpClass()</span></code></a> fails, meaning that <a class="reference internal" href="#unittest.TestCase.tearDownClass" title="unittest.TestCase.tearDownClass"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDownClass()</span></code></a> is not
called, then any cleanup functions added will still be called.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.8.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.doClassCleanups">
<em class="property">classmethod </em><code class="sig-name descname">doClassCleanups</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.doClassCleanups" title="Link permanente para esta definição">¶</a></dt>
<dd><p>This method is called unconditionally after <a class="reference internal" href="#unittest.TestCase.tearDownClass" title="unittest.TestCase.tearDownClass"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDownClass()</span></code></a>, or
after <a class="reference internal" href="#unittest.TestCase.setUpClass" title="unittest.TestCase.setUpClass"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUpClass()</span></code></a> if <a class="reference internal" href="#unittest.TestCase.setUpClass" title="unittest.TestCase.setUpClass"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUpClass()</span></code></a> raises an exception.</p>
<p>It is responsible for calling all the cleanup functions added by
<a class="reference internal" href="#unittest.TestCase.addClassCleanup" title="unittest.TestCase.addClassCleanup"><code class="xref py py-meth docutils literal notranslate"><span class="pre">addClassCleanup()</span></code></a>. If you need cleanup functions to be called
<em>prior</em> to <a class="reference internal" href="#unittest.TestCase.tearDownClass" title="unittest.TestCase.tearDownClass"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDownClass()</span></code></a> then you can call
<a class="reference internal" href="#unittest.TestCase.doClassCleanups" title="unittest.TestCase.doClassCleanups"><code class="xref py py-meth docutils literal notranslate"><span class="pre">doClassCleanups()</span></code></a> yourself.</p>
<p><a class="reference internal" href="#unittest.TestCase.doClassCleanups" title="unittest.TestCase.doClassCleanups"><code class="xref py py-meth docutils literal notranslate"><span class="pre">doClassCleanups()</span></code></a> pops methods off the stack of cleanup
functions one at a time, so it can be called at any time.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.8.</span></p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="unittest.IsolatedAsyncioTestCase">
<em class="property">class </em><code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">IsolatedAsyncioTestCase</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">methodName</span><span class="o">=</span><span class="default_value">'runTest'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.IsolatedAsyncioTestCase" title="Link permanente para esta definição">¶</a></dt>
<dd><p>This class provides an API similar to <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> and also accepts
coroutines as test functions.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.8.</span></p>
</div>
<dl class="py method">
<dt id="unittest.IsolatedAsyncioTestCase.asyncSetUp">
<em class="property">coroutine </em><code class="sig-name descname">asyncSetUp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.IsolatedAsyncioTestCase.asyncSetUp" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Method called to prepare the test fixture. This is called after <code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code>.
This is called immediately before calling the test method; other than
<a class="reference internal" href="exceptions.html#AssertionError" title="AssertionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AssertionError</span></code></a> or <a class="reference internal" href="#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SkipTest</span></code></a>, any exception raised by this method
will be considered an error rather than a test failure. The default implementation
does nothing.</p>
</dd></dl>

<dl class="py method">
<dt id="unittest.IsolatedAsyncioTestCase.asyncTearDown">
<em class="property">coroutine </em><code class="sig-name descname">asyncTearDown</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.IsolatedAsyncioTestCase.asyncTearDown" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Method called immediately after the test method has been called and the
result recorded.  This is called before <code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDown()</span></code>. This is called even if
the test method raised an exception, so the implementation in subclasses may need
to be particularly careful about checking internal state.  Any exception, other than
<a class="reference internal" href="exceptions.html#AssertionError" title="AssertionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AssertionError</span></code></a> or <a class="reference internal" href="#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SkipTest</span></code></a>, raised by this method will be
considered an additional error rather than a test failure (thus increasing
the total number of reported errors). This method will only be called if
the <a class="reference internal" href="#unittest.IsolatedAsyncioTestCase.asyncSetUp" title="unittest.IsolatedAsyncioTestCase.asyncSetUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">asyncSetUp()</span></code></a> succeeds, regardless of the outcome of the test method.
The default implementation does nothing.</p>
</dd></dl>

<dl class="py method">
<dt id="unittest.IsolatedAsyncioTestCase.addAsyncCleanup">
<code class="sig-name descname">addAsyncCleanup</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">function</span></em>, <em class="sig-param"><span class="o">/</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.IsolatedAsyncioTestCase.addAsyncCleanup" title="Link permanente para esta definição">¶</a></dt>
<dd><p>This method accepts a coroutine that can be used as a cleanup function.</p>
</dd></dl>

<dl class="py method">
<dt id="unittest.IsolatedAsyncioTestCase.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">result</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.IsolatedAsyncioTestCase.run" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Sets up a new event loop to run the test, collecting the result into
the <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a> object passed as <em>result</em>.  If <em>result</em> is
omitted or <code class="docutils literal notranslate"><span class="pre">None</span></code>, a temporary result object is created (by calling
the <code class="xref py py-meth docutils literal notranslate"><span class="pre">defaultTestResult()</span></code> method) and used. The result object is
returned to <a class="reference internal" href="#unittest.IsolatedAsyncioTestCase.run" title="unittest.IsolatedAsyncioTestCase.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run()</span></code></a>’s caller. At the end of the test all the tasks
in the event loop are cancelled.</p>
</dd></dl>

<p>An example illustrating the order:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">unittest</span> <span class="kn">import</span> <span class="n">IsolatedAsyncioTestCase</span>

<span class="n">events</span> <span class="o">=</span> <span class="p">[]</span>


<span class="k">class</span> <span class="nc">Test</span><span class="p">(</span><span class="n">IsolatedAsyncioTestCase</span><span class="p">):</span>


    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">events</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;setUp&quot;</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">asyncSetUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_async_connection</span> <span class="o">=</span> <span class="k">await</span> <span class="n">AsyncConnection</span><span class="p">()</span>
        <span class="n">events</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;asyncSetUp&quot;</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">test_response</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">events</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;test_response&quot;</span><span class="p">)</span>
        <span class="n">response</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_async_connection</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;https://example.com&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">status_code</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addAsyncCleanup</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">on_cleanup</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tearDown</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">events</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;tearDown&quot;</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">asyncTearDown</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_async_connection</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">events</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;asyncTearDown&quot;</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">on_cleanup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">events</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;cleanup&quot;</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">unittest</span><span class="o">.</span><span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>After running the test, <code class="docutils literal notranslate"><span class="pre">events</span></code> would contain <code class="docutils literal notranslate"><span class="pre">[&quot;setUp&quot;,</span> <span class="pre">&quot;asyncSetUp&quot;,</span> <span class="pre">&quot;test_response&quot;,</span> <span class="pre">&quot;asyncTearDown&quot;,</span> <span class="pre">&quot;tearDown&quot;,</span> <span class="pre">&quot;cleanup&quot;]</span></code>.</p>
</dd></dl>

<dl class="py class">
<dt id="unittest.FunctionTestCase">
<em class="property">class </em><code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">FunctionTestCase</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">testFunc</span></em>, <em class="sig-param"><span class="n">setUp</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">tearDown</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">description</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.FunctionTestCase" title="Link permanente para esta definição">¶</a></dt>
<dd><p>This class implements the portion of the <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> interface which
allows the test runner to drive the test, but does not provide the methods
which test code can use to check and report errors.  This is used to create
test cases using legacy test code, allowing it to be integrated into a
<a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a>-based test framework.</p>
</dd></dl>

<section id="deprecated-aliases">
<span id="id1"></span><h4>Deprecated aliases<a class="headerlink" href="#deprecated-aliases" title="Link permanente para este título">¶</a></h4>
<p>For historical reasons, some of the <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> methods had one or more
aliases that are now deprecated.  The following table lists the correct names
along with their deprecated aliases:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 40%" />
<col style="width: 29%" />
<col style="width: 31%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Método</p></th>
<th class="head"><p>Apelido descontinuado</p></th>
<th class="head"><p>Apelido descontinuado</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a></p></td>
<td><p>failUnlessEqual</p></td>
<td><p>assertEquals</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertNotEqual" title="unittest.TestCase.assertNotEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotEqual()</span></code></a></p></td>
<td><p>failIfEqual</p></td>
<td><p>assertNotEquals</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertTrue" title="unittest.TestCase.assertTrue"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertTrue()</span></code></a></p></td>
<td><p>failUnless</p></td>
<td><p>assert_</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertFalse" title="unittest.TestCase.assertFalse"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertFalse()</span></code></a></p></td>
<td><p>failIf</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaises()</span></code></a></p></td>
<td><p>failUnlessRaises</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertAlmostEqual" title="unittest.TestCase.assertAlmostEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertAlmostEqual()</span></code></a></p></td>
<td><p>failUnlessAlmostEqual</p></td>
<td><p>assertAlmostEquals</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertNotAlmostEqual" title="unittest.TestCase.assertNotAlmostEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotAlmostEqual()</span></code></a></p></td>
<td><p>failIfAlmostEqual</p></td>
<td><p>assertNotAlmostEquals</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertRegex" title="unittest.TestCase.assertRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRegex()</span></code></a></p></td>
<td></td>
<td><p>assertRegexpMatches</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertNotRegex" title="unittest.TestCase.assertNotRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotRegex()</span></code></a></p></td>
<td></td>
<td><p>assertNotRegexpMatches</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertRaisesRegex" title="unittest.TestCase.assertRaisesRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaisesRegex()</span></code></a></p></td>
<td></td>
<td><p>assertRaisesRegexp</p></td>
</tr>
</tbody>
</table>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde a versão 3.1: </span>The fail* aliases listed in the second column have been deprecated.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde a versão 3.2: </span>The assert* aliases listed in the third column have been deprecated.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde a versão 3.2: </span><code class="docutils literal notranslate"><span class="pre">assertRegexpMatches</span></code> and <code class="docutils literal notranslate"><span class="pre">assertRaisesRegexp</span></code> have been renamed to
<a class="reference internal" href="#unittest.TestCase.assertRegex" title="unittest.TestCase.assertRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRegex()</span></code></a> and <a class="reference internal" href="#unittest.TestCase.assertRaisesRegex" title="unittest.TestCase.assertRaisesRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaisesRegex()</span></code></a>.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde a versão 3.5: </span>The <code class="docutils literal notranslate"><span class="pre">assertNotRegexpMatches</span></code> name is deprecated in favor of <a class="reference internal" href="#unittest.TestCase.assertNotRegex" title="unittest.TestCase.assertNotRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotRegex()</span></code></a>.</p>
</div>
</div></blockquote>
</section>
</section>
<section id="grouping-tests">
<span id="testsuite-objects"></span><h3>Grouping tests<a class="headerlink" href="#grouping-tests" title="Link permanente para este título">¶</a></h3>
<dl class="py class">
<dt id="unittest.TestSuite">
<em class="property">class </em><code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">TestSuite</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tests</span><span class="o">=</span><span class="default_value">()</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestSuite" title="Link permanente para esta definição">¶</a></dt>
<dd><p>This class represents an aggregation of individual test cases and test suites.
The class presents the interface needed by the test runner to allow it to be run
as any other test case.  Running a <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> instance is the same as
iterating over the suite, running each test individually.</p>
<p>If <em>tests</em> is given, it must be an iterable of individual test cases or other
test suites that will be used to build the suite initially. Additional methods
are provided to add test cases and suites to the collection later on.</p>
<p><a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> objects behave much like <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> objects, except
they do not actually implement a test.  Instead, they are used to aggregate
tests into groups of tests that should be run together. Some additional
methods are available to add tests to <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> instances:</p>
<dl class="py method">
<dt id="unittest.TestSuite.addTest">
<code class="sig-name descname">addTest</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">test</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestSuite.addTest" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Add a <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> or <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> to the suite.</p>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestSuite.addTests">
<code class="sig-name descname">addTests</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tests</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestSuite.addTests" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Add all the tests from an iterable of <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> and <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a>
instances to this test suite.</p>
<p>This is equivalent to iterating over <em>tests</em>, calling <a class="reference internal" href="#unittest.TestSuite.addTest" title="unittest.TestSuite.addTest"><code class="xref py py-meth docutils literal notranslate"><span class="pre">addTest()</span></code></a> for
each element.</p>
</dd></dl>

<p><a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> shares the following methods with <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>:</p>
<dl class="py method">
<dt id="unittest.TestSuite.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">result</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestSuite.run" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Run the tests associated with this suite, collecting the result into the
test result object passed as <em>result</em>.  Note that unlike
<a class="reference internal" href="#unittest.TestCase.run" title="unittest.TestCase.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestCase.run()</span></code></a>, <a class="reference internal" href="#unittest.TestSuite.run" title="unittest.TestSuite.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestSuite.run()</span></code></a> requires the result object to
be passed in.</p>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestSuite.debug">
<code class="sig-name descname">debug</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestSuite.debug" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Run the tests associated with this suite without collecting the
result. This allows exceptions raised by the test to be propagated to the
caller and can be used to support running tests under a debugger.</p>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestSuite.countTestCases">
<code class="sig-name descname">countTestCases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestSuite.countTestCases" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Return the number of tests represented by this test object, including all
individual tests and sub-suites.</p>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestSuite.__iter__">
<code class="sig-name descname">__iter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestSuite.__iter__" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Tests grouped by a <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> are always accessed by iteration.
Subclasses can lazily provide tests by overriding <a class="reference internal" href="#unittest.TestSuite.__iter__" title="unittest.TestSuite.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a>. Note
that this method may be called several times on a single suite (for
example when counting tests or comparing for equality) so the tests
returned by repeated iterations before <a class="reference internal" href="#unittest.TestSuite.run" title="unittest.TestSuite.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestSuite.run()</span></code></a> must be the
same for each call iteration. After <a class="reference internal" href="#unittest.TestSuite.run" title="unittest.TestSuite.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestSuite.run()</span></code></a>, callers should
not rely on the tests returned by this method unless the caller uses a
subclass that overrides <code class="xref py py-meth docutils literal notranslate"><span class="pre">TestSuite._removeTestAtIndex()</span></code> to preserve
test references.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.2: </span>In earlier versions the <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> accessed tests directly rather
than through iteration, so overriding <a class="reference internal" href="#unittest.TestSuite.__iter__" title="unittest.TestSuite.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> wasn’t sufficient
for providing tests.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.4: </span>In earlier versions the <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> held references to each
<a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> after <a class="reference internal" href="#unittest.TestSuite.run" title="unittest.TestSuite.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestSuite.run()</span></code></a>. Subclasses can restore
that behavior by overriding <code class="xref py py-meth docutils literal notranslate"><span class="pre">TestSuite._removeTestAtIndex()</span></code>.</p>
</div>
</dd></dl>

<p>In the typical usage of a <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> object, the <a class="reference internal" href="#unittest.TestSuite.run" title="unittest.TestSuite.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run()</span></code></a> method
is invoked by a <code class="xref py py-class docutils literal notranslate"><span class="pre">TestRunner</span></code> rather than by the end-user test harness.</p>
</dd></dl>

</section>
<section id="loading-and-running-tests">
<h3>Carregando e executando testes<a class="headerlink" href="#loading-and-running-tests" title="Link permanente para este título">¶</a></h3>
<dl class="py class">
<dt id="unittest.TestLoader">
<em class="property">class </em><code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">TestLoader</code><a class="headerlink" href="#unittest.TestLoader" title="Link permanente para esta definição">¶</a></dt>
<dd><p>The <a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestLoader</span></code></a> class is used to create test suites from classes and
modules.  Normally, there is no need to create an instance of this class; the
<a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> module provides an instance that can be shared as
<a class="reference internal" href="#unittest.defaultTestLoader" title="unittest.defaultTestLoader"><code class="xref py py-data docutils literal notranslate"><span class="pre">unittest.defaultTestLoader</span></code></a>.  Using a subclass or instance, however,
allows customization of some configurable properties.</p>
<p>Objetos da classe <a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestLoader</span></code></a> possuem os seguintes atributos:</p>
<dl class="py attribute">
<dt id="unittest.TestLoader.errors">
<code class="sig-name descname">errors</code><a class="headerlink" href="#unittest.TestLoader.errors" title="Link permanente para esta definição">¶</a></dt>
<dd><p>A list of the non-fatal errors encountered while loading tests. Not reset
by the loader at any point. Fatal errors are signalled by the relevant
a method raising an exception to the caller. Non-fatal errors are also
indicated by a synthetic test that will raise the original error when
run.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.5.</span></p>
</div>
</dd></dl>

<p>Objetos da classe <a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestLoader</span></code></a> possuem os seguintes métodos:</p>
<dl class="py method">
<dt id="unittest.TestLoader.loadTestsFromTestCase">
<code class="sig-name descname">loadTestsFromTestCase</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">testCaseClass</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestLoader.loadTestsFromTestCase" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Return a suite of all test cases contained in the <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>-derived
<code class="xref py py-class docutils literal notranslate"><span class="pre">testCaseClass</span></code>.</p>
<p>A test case instance is created for each method named by
<a class="reference internal" href="#unittest.TestLoader.getTestCaseNames" title="unittest.TestLoader.getTestCaseNames"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getTestCaseNames()</span></code></a>. By default these are the method names
beginning with <code class="docutils literal notranslate"><span class="pre">test</span></code>. If <a class="reference internal" href="#unittest.TestLoader.getTestCaseNames" title="unittest.TestLoader.getTestCaseNames"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getTestCaseNames()</span></code></a> returns no
methods, but the <code class="xref py py-meth docutils literal notranslate"><span class="pre">runTest()</span></code> method is implemented, a single test
case is created for that method instead.</p>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestLoader.loadTestsFromModule">
<code class="sig-name descname">loadTestsFromModule</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">module</span></em>, <em class="sig-param"><span class="n">pattern</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestLoader.loadTestsFromModule" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Return a suite of all test cases contained in the given module. This
method searches <em>module</em> for classes derived from <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> and
creates an instance of the class for each test method defined for the
class.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>While using a hierarchy of <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>-derived classes can be
convenient in sharing fixtures and helper functions, defining test
methods on base classes that are not intended to be instantiated
directly does not play well with this method.  Doing so, however, can
be useful when the fixtures are different and defined in subclasses.</p>
</div>
<p>If a module provides a <code class="docutils literal notranslate"><span class="pre">load_tests</span></code> function it will be called to
load the tests. This allows modules to customize test loading.
This is the <a class="reference internal" href="#load-tests-protocol">load_tests protocol</a>.  The <em>pattern</em> argument is passed as
the third argument to <code class="docutils literal notranslate"><span class="pre">load_tests</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.2: </span>Suporte para <code class="docutils literal notranslate"><span class="pre">load_tests</span></code> adicionado.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.5: </span>The undocumented and unofficial <em>use_load_tests</em> default argument is
deprecated and ignored, although it is still accepted for backward
compatibility.  The method also now accepts a keyword-only argument
<em>pattern</em> which is passed to <code class="docutils literal notranslate"><span class="pre">load_tests</span></code> as the third argument.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestLoader.loadTestsFromName">
<code class="sig-name descname">loadTestsFromName</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">module</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestLoader.loadTestsFromName" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Return a suite of all test cases given a string specifier.</p>
<p>The specifier <em>name</em> is a “dotted name” that may resolve either to a
module, a test case class, a test method within a test case class, a
<a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> instance, or a callable object which returns a
<a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> or <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> instance.  These checks are
applied in the order listed here; that is, a method on a possible test
case class will be picked up as “a test method within a test case class”,
rather than “a callable object”.</p>
<p>For example, if you have a module <code class="xref py py-mod docutils literal notranslate"><span class="pre">SampleTests</span></code> containing a
<a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>-derived class <code class="xref py py-class docutils literal notranslate"><span class="pre">SampleTestCase</span></code> with three test
methods (<code class="xref py py-meth docutils literal notranslate"><span class="pre">test_one()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">test_two()</span></code>, and <code class="xref py py-meth docutils literal notranslate"><span class="pre">test_three()</span></code>), the
specifier <code class="docutils literal notranslate"><span class="pre">'SampleTests.SampleTestCase'</span></code> would cause this method to
return a suite which will run all three test methods. Using the specifier
<code class="docutils literal notranslate"><span class="pre">'SampleTests.SampleTestCase.test_two'</span></code> would cause it to return a test
suite which will run only the <code class="xref py py-meth docutils literal notranslate"><span class="pre">test_two()</span></code> test method. The specifier
can refer to modules and packages which have not been imported; they will
be imported as a side-effect.</p>
<p>O método opcionalmente resolve o <em>nome</em> relativo ao <em>módulo</em> dado.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.5: </span>If an <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> or <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> occurs while traversing
<em>name</em> then a synthetic test that raises that error when run will be
returned. These errors are included in the errors accumulated by
self.errors.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestLoader.loadTestsFromNames">
<code class="sig-name descname">loadTestsFromNames</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">names</span></em>, <em class="sig-param"><span class="n">module</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestLoader.loadTestsFromNames" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Similar to <a class="reference internal" href="#unittest.TestLoader.loadTestsFromName" title="unittest.TestLoader.loadTestsFromName"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loadTestsFromName()</span></code></a>, but takes a sequence of names rather
than a single name.  The return value is a test suite which supports all
the tests defined for each name.</p>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestLoader.getTestCaseNames">
<code class="sig-name descname">getTestCaseNames</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">testCaseClass</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestLoader.getTestCaseNames" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Return a sorted sequence of method names found within <em>testCaseClass</em>;
this should be a subclass of <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestLoader.discover">
<code class="sig-name descname">discover</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">start_dir</span></em>, <em class="sig-param"><span class="n">pattern</span><span class="o">=</span><span class="default_value">'test*.py'</span></em>, <em class="sig-param"><span class="n">top_level_dir</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestLoader.discover" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Find all the test modules by recursing into subdirectories from the
specified start directory, and return a TestSuite object containing them.
Only test files that match <em>pattern</em> will be loaded. (Using shell style
pattern matching.) Only module names that are importable (i.e. are valid
Python identifiers) will be loaded.</p>
<p>All test modules must be importable from the top level of the project. If
the start directory is not the top level directory then the top level
directory must be specified separately.</p>
<p>If importing a module fails, for example due to a syntax error, then
this will be recorded as a single error and discovery will continue.  If
the import failure is due to <a class="reference internal" href="#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SkipTest</span></code></a> being raised, it will be
recorded as a skip instead of an error.</p>
<p>If a package (a directory containing a file named <code class="file docutils literal notranslate"><span class="pre">__init__.py</span></code>) is
found, the package will be checked for a <code class="docutils literal notranslate"><span class="pre">load_tests</span></code> function. If this
exists then it will be called
<code class="docutils literal notranslate"><span class="pre">package.load_tests(loader,</span> <span class="pre">tests,</span> <span class="pre">pattern)</span></code>. Test discovery takes care
to ensure that a package is only checked for tests once during an
invocation, even if the load_tests function itself calls
<code class="docutils literal notranslate"><span class="pre">loader.discover</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">load_tests</span></code> exists then discovery does <em>not</em> recurse into the
package, <code class="docutils literal notranslate"><span class="pre">load_tests</span></code> is responsible for loading all tests in the
package.</p>
<p>The pattern is deliberately not stored as a loader attribute so that
packages can continue discovery themselves. <em>top_level_dir</em> is stored so
<code class="docutils literal notranslate"><span class="pre">load_tests</span></code> does not need to pass this argument in to
<code class="docutils literal notranslate"><span class="pre">loader.discover()</span></code>.</p>
<p><em>start_dir</em> can be a dotted module name as well as a directory.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.2.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.4: </span>Modules that raise <a class="reference internal" href="#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SkipTest</span></code></a> on import are recorded as skips,
not errors.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.4: </span><em>start_dir</em> can be a <a class="reference internal" href="../glossary.html#term-namespace-package"><span class="xref std std-term">namespace packages</span></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.4: </span>Paths are sorted before being imported so that execution order is the
same even if the underlying file system’s ordering is not dependent
on file name.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.5: </span>Found packages are now checked for <code class="docutils literal notranslate"><span class="pre">load_tests</span></code> regardless of
whether their path matches <em>pattern</em>, because it is impossible for
a package name to match the default pattern.</p>
</div>
</dd></dl>

<p>The following attributes of a <a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestLoader</span></code></a> can be configured either by
subclassing or assignment on an instance:</p>
<dl class="py attribute">
<dt id="unittest.TestLoader.testMethodPrefix">
<code class="sig-name descname">testMethodPrefix</code><a class="headerlink" href="#unittest.TestLoader.testMethodPrefix" title="Link permanente para esta definição">¶</a></dt>
<dd><p>String giving the prefix of method names which will be interpreted as test
methods.  The default value is <code class="docutils literal notranslate"><span class="pre">'test'</span></code>.</p>
<p>This affects <a class="reference internal" href="#unittest.TestLoader.getTestCaseNames" title="unittest.TestLoader.getTestCaseNames"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getTestCaseNames()</span></code></a> and all the <code class="xref py py-meth docutils literal notranslate"><span class="pre">loadTestsFrom*()</span></code>
methods.</p>
</dd></dl>

<dl class="py attribute">
<dt id="unittest.TestLoader.sortTestMethodsUsing">
<code class="sig-name descname">sortTestMethodsUsing</code><a class="headerlink" href="#unittest.TestLoader.sortTestMethodsUsing" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Function to be used to compare method names when sorting them in
<a class="reference internal" href="#unittest.TestLoader.getTestCaseNames" title="unittest.TestLoader.getTestCaseNames"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getTestCaseNames()</span></code></a> and all the <code class="xref py py-meth docutils literal notranslate"><span class="pre">loadTestsFrom*()</span></code> methods.</p>
</dd></dl>

<dl class="py attribute">
<dt id="unittest.TestLoader.suiteClass">
<code class="sig-name descname">suiteClass</code><a class="headerlink" href="#unittest.TestLoader.suiteClass" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Callable object that constructs a test suite from a list of tests. No
methods on the resulting object are needed.  The default value is the
<a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> class.</p>
<p>This affects all the <code class="xref py py-meth docutils literal notranslate"><span class="pre">loadTestsFrom*()</span></code> methods.</p>
</dd></dl>

<dl class="py attribute">
<dt id="unittest.TestLoader.testNamePatterns">
<code class="sig-name descname">testNamePatterns</code><a class="headerlink" href="#unittest.TestLoader.testNamePatterns" title="Link permanente para esta definição">¶</a></dt>
<dd><p>List of Unix shell-style wildcard test name patterns that test methods
have to match to be included in test suites (see <code class="docutils literal notranslate"><span class="pre">-v</span></code> option).</p>
<p>If this attribute is not <code class="docutils literal notranslate"><span class="pre">None</span></code> (the default), all test methods to be
included in test suites must match one of the patterns in this list.
Note that matches are always performed using <a class="reference internal" href="fnmatch.html#fnmatch.fnmatchcase" title="fnmatch.fnmatchcase"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fnmatch.fnmatchcase()</span></code></a>,
so unlike patterns passed to the <code class="docutils literal notranslate"><span class="pre">-v</span></code> option, simple substring patterns
will have to be converted using <code class="docutils literal notranslate"><span class="pre">*</span></code> wildcards.</p>
<p>This affects all the <code class="xref py py-meth docutils literal notranslate"><span class="pre">loadTestsFrom*()</span></code> methods.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.7.</span></p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="unittest.TestResult">
<em class="property">class </em><code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">TestResult</code><a class="headerlink" href="#unittest.TestResult" title="Link permanente para esta definição">¶</a></dt>
<dd><p>This class is used to compile information about which tests have succeeded
and which have failed.</p>
<p>A <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a> object stores the results of a set of tests.  The
<a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> and <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> classes ensure that results are
properly recorded; test authors do not need to worry about recording the
outcome of tests.</p>
<p>Testing frameworks built on top of <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> may want access to the
<a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a> object generated by running a set of tests for reporting
purposes; a <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a> instance is returned by the
<code class="xref py py-meth docutils literal notranslate"><span class="pre">TestRunner.run()</span></code> method for this purpose.</p>
<p><a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a> instances have the following attributes that will be of
interest when inspecting the results of running a set of tests:</p>
<dl class="py attribute">
<dt id="unittest.TestResult.errors">
<code class="sig-name descname">errors</code><a class="headerlink" href="#unittest.TestResult.errors" title="Link permanente para esta definição">¶</a></dt>
<dd><p>A list containing 2-tuples of <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> instances and strings
holding formatted tracebacks. Each tuple represents a test which raised an
unexpected exception.</p>
</dd></dl>

<dl class="py attribute">
<dt id="unittest.TestResult.failures">
<code class="sig-name descname">failures</code><a class="headerlink" href="#unittest.TestResult.failures" title="Link permanente para esta definição">¶</a></dt>
<dd><p>A list containing 2-tuples of <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> instances and strings
holding formatted tracebacks. Each tuple represents a test where a failure
was explicitly signalled using the <code class="xref py py-meth docutils literal notranslate"><span class="pre">TestCase.assert*()</span></code> methods.</p>
</dd></dl>

<dl class="py attribute">
<dt id="unittest.TestResult.skipped">
<code class="sig-name descname">skipped</code><a class="headerlink" href="#unittest.TestResult.skipped" title="Link permanente para esta definição">¶</a></dt>
<dd><p>A list containing 2-tuples of <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> instances and strings
holding the reason for skipping the test.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.1.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="unittest.TestResult.expectedFailures">
<code class="sig-name descname">expectedFailures</code><a class="headerlink" href="#unittest.TestResult.expectedFailures" title="Link permanente para esta definição">¶</a></dt>
<dd><p>A list containing 2-tuples of <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> instances and strings
holding formatted tracebacks.  Each tuple represents an expected failure
or error of the test case.</p>
</dd></dl>

<dl class="py attribute">
<dt id="unittest.TestResult.unexpectedSuccesses">
<code class="sig-name descname">unexpectedSuccesses</code><a class="headerlink" href="#unittest.TestResult.unexpectedSuccesses" title="Link permanente para esta definição">¶</a></dt>
<dd><p>A list containing <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> instances that were marked as expected
failures, but succeeded.</p>
</dd></dl>

<dl class="py attribute">
<dt id="unittest.TestResult.shouldStop">
<code class="sig-name descname">shouldStop</code><a class="headerlink" href="#unittest.TestResult.shouldStop" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Set to <code class="docutils literal notranslate"><span class="pre">True</span></code> when the execution of tests should stop by <a class="reference internal" href="#unittest.TestResult.stop" title="unittest.TestResult.stop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stop()</span></code></a>.</p>
</dd></dl>

<dl class="py attribute">
<dt id="unittest.TestResult.testsRun">
<code class="sig-name descname">testsRun</code><a class="headerlink" href="#unittest.TestResult.testsRun" title="Link permanente para esta definição">¶</a></dt>
<dd><p>The total number of tests run so far.</p>
</dd></dl>

<dl class="py attribute">
<dt id="unittest.TestResult.buffer">
<code class="sig-name descname">buffer</code><a class="headerlink" href="#unittest.TestResult.buffer" title="Link permanente para esta definição">¶</a></dt>
<dd><p>If set to true, <code class="docutils literal notranslate"><span class="pre">sys.stdout</span></code> and <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code> will be buffered in between
<a class="reference internal" href="#unittest.TestResult.startTest" title="unittest.TestResult.startTest"><code class="xref py py-meth docutils literal notranslate"><span class="pre">startTest()</span></code></a> and <a class="reference internal" href="#unittest.TestResult.stopTest" title="unittest.TestResult.stopTest"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stopTest()</span></code></a> being called. Collected output will
only be echoed onto the real <code class="docutils literal notranslate"><span class="pre">sys.stdout</span></code> and <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code> if the test
fails or errors. Any output is also attached to the failure / error message.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.2.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="unittest.TestResult.failfast">
<code class="sig-name descname">failfast</code><a class="headerlink" href="#unittest.TestResult.failfast" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Se definido como true (verdadeiro) <a class="reference internal" href="#unittest.TestResult.stop" title="unittest.TestResult.stop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stop()</span></code></a> será chamado na primeira falha ou erro, interrompendo a execução do teste.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.2.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="unittest.TestResult.tb_locals">
<code class="sig-name descname">tb_locals</code><a class="headerlink" href="#unittest.TestResult.tb_locals" title="Link permanente para esta definição">¶</a></dt>
<dd><p>If set to true then local variables will be shown in tracebacks.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.5.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestResult.wasSuccessful">
<code class="sig-name descname">wasSuccessful</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.wasSuccessful" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if all tests run so far have passed, otherwise returns
<code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.4: </span>Returns <code class="docutils literal notranslate"><span class="pre">False</span></code> if there were any <a class="reference internal" href="#unittest.TestResult.unexpectedSuccesses" title="unittest.TestResult.unexpectedSuccesses"><code class="xref py py-attr docutils literal notranslate"><span class="pre">unexpectedSuccesses</span></code></a>
from tests marked with the <a class="reference internal" href="#unittest.expectedFailure" title="unittest.expectedFailure"><code class="xref py py-func docutils literal notranslate"><span class="pre">expectedFailure()</span></code></a> decorator.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestResult.stop">
<code class="sig-name descname">stop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.stop" title="Link permanente para esta definição">¶</a></dt>
<dd><p>This method can be called to signal that the set of tests being run should
be aborted by setting the <a class="reference internal" href="#unittest.TestResult.shouldStop" title="unittest.TestResult.shouldStop"><code class="xref py py-attr docutils literal notranslate"><span class="pre">shouldStop</span></code></a> attribute to <code class="docutils literal notranslate"><span class="pre">True</span></code>.
<code class="xref py py-class docutils literal notranslate"><span class="pre">TestRunner</span></code> objects should respect this flag and return without
running any additional tests.</p>
<p>For example, this feature is used by the <a class="reference internal" href="#unittest.TextTestRunner" title="unittest.TextTestRunner"><code class="xref py py-class docutils literal notranslate"><span class="pre">TextTestRunner</span></code></a> class to
stop the test framework when the user signals an interrupt from the
keyboard.  Interactive tools which provide <code class="xref py py-class docutils literal notranslate"><span class="pre">TestRunner</span></code>
implementations can use this in a similar manner.</p>
</dd></dl>

<p>The following methods of the <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a> class are used to maintain
the internal data structures, and may be extended in subclasses to support
additional reporting requirements.  This is particularly useful in building
tools which support interactive reporting while tests are being run.</p>
<dl class="py method">
<dt id="unittest.TestResult.startTest">
<code class="sig-name descname">startTest</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">test</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.startTest" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Called when the test case <em>test</em> is about to be run.</p>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestResult.stopTest">
<code class="sig-name descname">stopTest</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">test</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.stopTest" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Called after the test case <em>test</em> has been executed, regardless of the
outcome.</p>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestResult.startTestRun">
<code class="sig-name descname">startTestRun</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.startTestRun" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Called once before any tests are executed.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.1.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestResult.stopTestRun">
<code class="sig-name descname">stopTestRun</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.stopTestRun" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Called once after all tests are executed.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.1.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestResult.addError">
<code class="sig-name descname">addError</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">test</span></em>, <em class="sig-param"><span class="n">err</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.addError" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Called when the test case <em>test</em> raises an unexpected exception. <em>err</em> is a
tuple of the form returned by <a class="reference internal" href="sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a>: <code class="docutils literal notranslate"><span class="pre">(type,</span> <span class="pre">value,</span>
<span class="pre">traceback)</span></code>.</p>
<p>The default implementation appends a tuple <code class="docutils literal notranslate"><span class="pre">(test,</span> <span class="pre">formatted_err)</span></code> to
the instance’s <a class="reference internal" href="#unittest.TestResult.errors" title="unittest.TestResult.errors"><code class="xref py py-attr docutils literal notranslate"><span class="pre">errors</span></code></a> attribute, where <em>formatted_err</em> is a
formatted traceback derived from <em>err</em>.</p>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestResult.addFailure">
<code class="sig-name descname">addFailure</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">test</span></em>, <em class="sig-param"><span class="n">err</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.addFailure" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Called when the test case <em>test</em> signals a failure. <em>err</em> is a tuple of
the form returned by <a class="reference internal" href="sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a>: <code class="docutils literal notranslate"><span class="pre">(type,</span> <span class="pre">value,</span> <span class="pre">traceback)</span></code>.</p>
<p>The default implementation appends a tuple <code class="docutils literal notranslate"><span class="pre">(test,</span> <span class="pre">formatted_err)</span></code> to
the instance’s <a class="reference internal" href="#unittest.TestResult.failures" title="unittest.TestResult.failures"><code class="xref py py-attr docutils literal notranslate"><span class="pre">failures</span></code></a> attribute, where <em>formatted_err</em> is a
formatted traceback derived from <em>err</em>.</p>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestResult.addSuccess">
<code class="sig-name descname">addSuccess</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">test</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.addSuccess" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Called when the test case <em>test</em> succeeds.</p>
<p>The default implementation does nothing.</p>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestResult.addSkip">
<code class="sig-name descname">addSkip</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">test</span></em>, <em class="sig-param"><span class="n">reason</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.addSkip" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Called when the test case <em>test</em> is skipped.  <em>reason</em> is the reason the
test gave for skipping.</p>
<p>The default implementation appends a tuple <code class="docutils literal notranslate"><span class="pre">(test,</span> <span class="pre">reason)</span></code> to the
instance’s <a class="reference internal" href="#unittest.TestResult.skipped" title="unittest.TestResult.skipped"><code class="xref py py-attr docutils literal notranslate"><span class="pre">skipped</span></code></a> attribute.</p>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestResult.addExpectedFailure">
<code class="sig-name descname">addExpectedFailure</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">test</span></em>, <em class="sig-param"><span class="n">err</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.addExpectedFailure" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Called when the test case <em>test</em> fails or errors, but was marked with
the <a class="reference internal" href="#unittest.expectedFailure" title="unittest.expectedFailure"><code class="xref py py-func docutils literal notranslate"><span class="pre">expectedFailure()</span></code></a> decorator.</p>
<p>The default implementation appends a tuple <code class="docutils literal notranslate"><span class="pre">(test,</span> <span class="pre">formatted_err)</span></code> to
the instance’s <a class="reference internal" href="#unittest.TestResult.expectedFailures" title="unittest.TestResult.expectedFailures"><code class="xref py py-attr docutils literal notranslate"><span class="pre">expectedFailures</span></code></a> attribute, where <em>formatted_err</em>
is a formatted traceback derived from <em>err</em>.</p>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestResult.addUnexpectedSuccess">
<code class="sig-name descname">addUnexpectedSuccess</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">test</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.addUnexpectedSuccess" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Called when the test case <em>test</em> was marked with the
<a class="reference internal" href="#unittest.expectedFailure" title="unittest.expectedFailure"><code class="xref py py-func docutils literal notranslate"><span class="pre">expectedFailure()</span></code></a> decorator, but succeeded.</p>
<p>The default implementation appends the test to the instance’s
<a class="reference internal" href="#unittest.TestResult.unexpectedSuccesses" title="unittest.TestResult.unexpectedSuccesses"><code class="xref py py-attr docutils literal notranslate"><span class="pre">unexpectedSuccesses</span></code></a> attribute.</p>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestResult.addSubTest">
<code class="sig-name descname">addSubTest</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">test</span></em>, <em class="sig-param"><span class="n">subtest</span></em>, <em class="sig-param"><span class="n">outcome</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.addSubTest" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Called when a subtest finishes.  <em>test</em> is the test case
corresponding to the test method.  <em>subtest</em> is a custom
<a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> instance describing the subtest.</p>
<p>If <em>outcome</em> is <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>, the subtest succeeded.  Otherwise,
it failed with an exception where <em>outcome</em> is a tuple of the form
returned by <a class="reference internal" href="sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a>: <code class="docutils literal notranslate"><span class="pre">(type,</span> <span class="pre">value,</span> <span class="pre">traceback)</span></code>.</p>
<p>The default implementation does nothing when the outcome is a
success, and records subtest failures as normal failures.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.4.</span></p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="unittest.TextTestResult">
<em class="property">class </em><code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">TextTestResult</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">stream</span></em>, <em class="sig-param"><span class="n">descriptions</span></em>, <em class="sig-param"><span class="n">verbosity</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TextTestResult" title="Link permanente para esta definição">¶</a></dt>
<dd><p>A concrete implementation of <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a> used by the
<a class="reference internal" href="#unittest.TextTestRunner" title="unittest.TextTestRunner"><code class="xref py py-class docutils literal notranslate"><span class="pre">TextTestRunner</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.2: </span>This class was previously named <code class="docutils literal notranslate"><span class="pre">_TextTestResult</span></code>. The old name still
exists as an alias but is deprecated.</p>
</div>
</dd></dl>

<dl class="py data">
<dt id="unittest.defaultTestLoader">
<code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">defaultTestLoader</code><a class="headerlink" href="#unittest.defaultTestLoader" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Instance of the <a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestLoader</span></code></a> class intended to be shared.  If no
customization of the <a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestLoader</span></code></a> is needed, this instance can be used
instead of repeatedly creating new instances.</p>
</dd></dl>

<dl class="py class">
<dt id="unittest.TextTestRunner">
<em class="property">class </em><code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">TextTestRunner</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">stream</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">descriptions</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">verbosity</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">failfast</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">buffer</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">resultclass</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">warnings</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">tb_locals</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TextTestRunner" title="Link permanente para esta definição">¶</a></dt>
<dd><p>A basic test runner implementation that outputs results to a stream. If <em>stream</em>
is <code class="docutils literal notranslate"><span class="pre">None</span></code>, the default, <a class="reference internal" href="sys.html#sys.stderr" title="sys.stderr"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stderr</span></code></a> is used as the output stream. This class
has a few configurable parameters, but is essentially very simple.  Graphical
applications which run test suites should provide alternate implementations. Such
implementations should accept <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code> as the interface to construct runners
changes when features are added to unittest.</p>
<p>By default this runner shows <a class="reference internal" href="exceptions.html#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a>,
<a class="reference internal" href="exceptions.html#PendingDeprecationWarning" title="PendingDeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">PendingDeprecationWarning</span></code></a>, <a class="reference internal" href="exceptions.html#ResourceWarning" title="ResourceWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ResourceWarning</span></code></a> and
<a class="reference internal" href="exceptions.html#ImportWarning" title="ImportWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportWarning</span></code></a> even if they are <a class="reference internal" href="warnings.html#warning-ignored"><span class="std std-ref">ignored by default</span></a>. Deprecation warnings caused by <a class="reference internal" href="#deprecated-aliases"><span class="std std-ref">deprecated unittest
methods</span></a> are also special-cased and, when the warning
filters are <code class="docutils literal notranslate"><span class="pre">'default'</span></code> or <code class="docutils literal notranslate"><span class="pre">'always'</span></code>, they will appear only once
per-module, in order to avoid too many warning messages.  This behavior can
be overridden using Python’s <code class="xref std std-option docutils literal notranslate"><span class="pre">-Wd</span></code> or <code class="xref std std-option docutils literal notranslate"><span class="pre">-Wa</span></code> options
(see <a class="reference internal" href="../using/cmdline.html#using-on-warnings"><span class="std std-ref">Warning control</span></a>) and leaving
<em>warnings</em> to <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.2: </span>Added the <code class="docutils literal notranslate"><span class="pre">warnings</span></code> argument.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.2: </span>The default stream is set to <a class="reference internal" href="sys.html#sys.stderr" title="sys.stderr"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stderr</span></code></a> at instantiation time rather
than import time.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.5: </span>Added the tb_locals parameter.</p>
</div>
<dl class="py method">
<dt id="unittest.TextTestRunner._makeResult">
<code class="sig-name descname">_makeResult</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TextTestRunner._makeResult" title="Link permanente para esta definição">¶</a></dt>
<dd><p>This method returns the instance of <code class="docutils literal notranslate"><span class="pre">TestResult</span></code> used by <a class="reference internal" href="#unittest.TextTestRunner.run" title="unittest.TextTestRunner.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run()</span></code></a>.
It is not intended to be called directly, but can be overridden in
subclasses to provide a custom <code class="docutils literal notranslate"><span class="pre">TestResult</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">_makeResult()</span></code> instantiates the class or callable passed in the
<code class="docutils literal notranslate"><span class="pre">TextTestRunner</span></code> constructor as the <code class="docutils literal notranslate"><span class="pre">resultclass</span></code> argument. It
defaults to <a class="reference internal" href="#unittest.TextTestResult" title="unittest.TextTestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TextTestResult</span></code></a> if no <code class="docutils literal notranslate"><span class="pre">resultclass</span></code> is provided.
The result class is instantiated with the following arguments:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">stream</span><span class="p">,</span> <span class="n">descriptions</span><span class="p">,</span> <span class="n">verbosity</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TextTestRunner.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">test</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TextTestRunner.run" title="Link permanente para esta definição">¶</a></dt>
<dd><p>This method is the main public interface to the <code class="docutils literal notranslate"><span class="pre">TextTestRunner</span></code>. This
method takes a <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> or <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> instance. A
<a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a> is created by calling
<a class="reference internal" href="#unittest.TextTestRunner._makeResult" title="unittest.TextTestRunner._makeResult"><code class="xref py py-func docutils literal notranslate"><span class="pre">_makeResult()</span></code></a> and the test(s) are run and the
results printed to stdout.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="unittest.main">
<code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">main</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">module</span><span class="o">=</span><span class="default_value">'__main__'</span></em>, <em class="sig-param"><span class="n">defaultTest</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">argv</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">testRunner</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">testLoader</span><span class="o">=</span><span class="default_value">unittest.defaultTestLoader</span></em>, <em class="sig-param"><span class="n">exit</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">verbosity</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">failfast</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">catchbreak</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">buffer</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">warnings</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.main" title="Link permanente para esta definição">¶</a></dt>
<dd><p>A command-line program that loads a set of tests from <em>module</em> and runs them;
this is primarily for making test modules conveniently executable.
The simplest use for this function is to include the following line at the
end of a test script:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">unittest</span><span class="o">.</span><span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>You can run tests with more detailed information by passing in the verbosity
argument:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">unittest</span><span class="o">.</span><span class="n">main</span><span class="p">(</span><span class="n">verbosity</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>The <em>defaultTest</em> argument is either the name of a single test or an
iterable of test names to run if no test names are specified via <em>argv</em>.  If
not specified or <code class="docutils literal notranslate"><span class="pre">None</span></code> and no test names are provided via <em>argv</em>, all
tests found in <em>module</em> are run.</p>
<p>O argumento <em>argv</em> pode ser uma lista de opções passada para o programa, com o primeiro elemento sendo o nome do programa. Se não for especificado ou for <code class="docutils literal notranslate"><span class="pre">None</span></code>, os valores de <a class="reference internal" href="sys.html#sys.argv" title="sys.argv"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.argv</span></code></a> são usados.</p>
<p>The <em>testRunner</em> argument can either be a test runner class or an already
created instance of it. By default <code class="docutils literal notranslate"><span class="pre">main</span></code> calls <a class="reference internal" href="sys.html#sys.exit" title="sys.exit"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exit()</span></code></a> with
an exit code indicating success or failure of the tests run.</p>
<p>The <em>testLoader</em> argument has to be a <a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestLoader</span></code></a> instance,
and defaults to <a class="reference internal" href="#unittest.defaultTestLoader" title="unittest.defaultTestLoader"><code class="xref py py-data docutils literal notranslate"><span class="pre">defaultTestLoader</span></code></a>.</p>
<p><code class="docutils literal notranslate"><span class="pre">main</span></code> supports being used from the interactive interpreter by passing in the
argument <code class="docutils literal notranslate"><span class="pre">exit=False</span></code>. This displays the result on standard output without
calling <a class="reference internal" href="sys.html#sys.exit" title="sys.exit"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exit()</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">unittest</span> <span class="kn">import</span> <span class="n">main</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">main</span><span class="p">(</span><span class="n">module</span><span class="o">=</span><span class="s1">&#39;test_module&#39;</span><span class="p">,</span> <span class="n">exit</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>The <em>failfast</em>, <em>catchbreak</em> and <em>buffer</em> parameters have the same
effect as the same-name <a class="reference internal" href="#command-line-options">command-line options</a>.</p>
<p>The <em>warnings</em> argument specifies the <a class="reference internal" href="warnings.html#warning-filter"><span class="std std-ref">warning filter</span></a>
that should be used while running the tests.  If it’s not specified, it will
remain <code class="docutils literal notranslate"><span class="pre">None</span></code> if a <code class="xref std std-option docutils literal notranslate"><span class="pre">-W</span></code> option is passed to <strong class="program">python</strong>
(see <a class="reference internal" href="../using/cmdline.html#using-on-warnings"><span class="std std-ref">Warning control</span></a>),
otherwise it will be set to <code class="docutils literal notranslate"><span class="pre">'default'</span></code>.</p>
<p>Calling <code class="docutils literal notranslate"><span class="pre">main</span></code> actually returns an instance of the <code class="docutils literal notranslate"><span class="pre">TestProgram</span></code> class.
This stores the result of the tests run as the <code class="docutils literal notranslate"><span class="pre">result</span></code> attribute.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.1: </span>The <em>exit</em> parameter was added.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.2: </span>The <em>verbosity</em>, <em>failfast</em>, <em>catchbreak</em>, <em>buffer</em>
and <em>warnings</em> parameters were added.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.4: </span>The <em>defaultTest</em> parameter was changed to also accept an iterable of
test names.</p>
</div>
</dd></dl>

<section id="load-tests-protocol">
<h4>load_tests Protocol<a class="headerlink" href="#load-tests-protocol" title="Link permanente para este título">¶</a></h4>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.2.</span></p>
</div>
<p>Modules or packages can customize how tests are loaded from them during normal
test runs or test discovery by implementing a function called <code class="docutils literal notranslate"><span class="pre">load_tests</span></code>.</p>
<p>If a test module defines <code class="docutils literal notranslate"><span class="pre">load_tests</span></code> it will be called by
<a class="reference internal" href="#unittest.TestLoader.loadTestsFromModule" title="unittest.TestLoader.loadTestsFromModule"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestLoader.loadTestsFromModule()</span></code></a> with the following arguments:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">load_tests</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="n">standard_tests</span><span class="p">,</span> <span class="n">pattern</span><span class="p">)</span>
</pre></div>
</div>
<p>where <em>pattern</em> is passed straight through from <code class="docutils literal notranslate"><span class="pre">loadTestsFromModule</span></code>.  It
defaults to <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>It should return a <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a>.</p>
<p><em>loader</em> is the instance of <a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestLoader</span></code></a> doing the loading.
<em>standard_tests</em> are the tests that would be loaded by default from the
module. It is common for test modules to only want to add or remove tests
from the standard set of tests.
The third argument is used when loading packages as part of test discovery.</p>
<p>A typical <code class="docutils literal notranslate"><span class="pre">load_tests</span></code> function that loads tests from a specific set of
<a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> classes may look like:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">test_cases</span> <span class="o">=</span> <span class="p">(</span><span class="n">TestCase1</span><span class="p">,</span> <span class="n">TestCase2</span><span class="p">,</span> <span class="n">TestCase3</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">load_tests</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="n">tests</span><span class="p">,</span> <span class="n">pattern</span><span class="p">):</span>
    <span class="n">suite</span> <span class="o">=</span> <span class="n">TestSuite</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">test_class</span> <span class="ow">in</span> <span class="n">test_cases</span><span class="p">:</span>
        <span class="n">tests</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">loadTestsFromTestCase</span><span class="p">(</span><span class="n">test_class</span><span class="p">)</span>
        <span class="n">suite</span><span class="o">.</span><span class="n">addTests</span><span class="p">(</span><span class="n">tests</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">suite</span>
</pre></div>
</div>
<p>If discovery is started in a directory containing a package, either from the
command line or by calling <a class="reference internal" href="#unittest.TestLoader.discover" title="unittest.TestLoader.discover"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestLoader.discover()</span></code></a>, then the package
<code class="file docutils literal notranslate"><span class="pre">__init__.py</span></code> will be checked for <code class="docutils literal notranslate"><span class="pre">load_tests</span></code>.  If that function does
not exist, discovery will recurse into the package as though it were just
another directory.  Otherwise, discovery of the package’s tests will be left up
to <code class="docutils literal notranslate"><span class="pre">load_tests</span></code> which is called with the following arguments:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">load_tests</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="n">standard_tests</span><span class="p">,</span> <span class="n">pattern</span><span class="p">)</span>
</pre></div>
</div>
<p>This should return a <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> representing all the tests
from the package. (<code class="docutils literal notranslate"><span class="pre">standard_tests</span></code> will only contain tests
collected from <code class="file docutils literal notranslate"><span class="pre">__init__.py</span></code>.)</p>
<p>Because the pattern is passed into <code class="docutils literal notranslate"><span class="pre">load_tests</span></code> the package is free to
continue (and potentially modify) test discovery. A ‘do nothing’
<code class="docutils literal notranslate"><span class="pre">load_tests</span></code> function for a test package would look like:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">load_tests</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="n">standard_tests</span><span class="p">,</span> <span class="n">pattern</span><span class="p">):</span>
    <span class="c1"># top level directory cached on loader instance</span>
    <span class="n">this_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span>
    <span class="n">package_tests</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">discover</span><span class="p">(</span><span class="n">start_dir</span><span class="o">=</span><span class="n">this_dir</span><span class="p">,</span> <span class="n">pattern</span><span class="o">=</span><span class="n">pattern</span><span class="p">)</span>
    <span class="n">standard_tests</span><span class="o">.</span><span class="n">addTests</span><span class="p">(</span><span class="n">package_tests</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">standard_tests</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.5: </span>Discovery no longer checks package names for matching <em>pattern</em> due to the
impossibility of package names matching the default pattern.</p>
</div>
</section>
</section>
</section>
<section id="class-and-module-fixtures">
<h2>Classes e Módulos de Definição de Contexto<a class="headerlink" href="#class-and-module-fixtures" title="Link permanente para este título">¶</a></h2>
<p>Definições de contexto em um nível de classe e módulo são implementadas na classe <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a>. Quando a suíte de testes encontrar um teste de uma nova classe, o método <code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDownClass()</span></code> da classe anterior (se houver alguma) é chamado logo antes da chamada do método <code class="xref py py-meth docutils literal notranslate"><span class="pre">setUpClass()</span></code> da nova classe.</p>
<p>Similarly if a test is from a different module from the previous test then
<code class="docutils literal notranslate"><span class="pre">tearDownModule</span></code> from the previous module is run, followed by
<code class="docutils literal notranslate"><span class="pre">setUpModule</span></code> from the new module.</p>
<p>Após executar todos os testes, haverá a execução final do <code class="docutils literal notranslate"><span class="pre">tearDownClass</span></code> e do <code class="docutils literal notranslate"><span class="pre">tearDownModule</span></code>.</p>
<p>Note that shared fixtures do not play well with [potential] features like test
parallelization and they break test isolation. They should be used with care.</p>
<p>The default ordering of tests created by the unittest test loaders is to group
all tests from the same modules and classes together. This will lead to
<code class="docutils literal notranslate"><span class="pre">setUpClass</span></code> / <code class="docutils literal notranslate"><span class="pre">setUpModule</span></code> (etc) being called exactly once per class and
module. If you randomize the order, so that tests from different modules and
classes are adjacent to each other, then these shared fixture functions may be
called multiple times in a single test run.</p>
<p>Shared fixtures are not intended to work with suites with non-standard
ordering. A <code class="docutils literal notranslate"><span class="pre">BaseTestSuite</span></code> still exists for frameworks that don’t want to
support shared fixtures.</p>
<p>If there are any exceptions raised during one of the shared fixture functions
the test is reported as an error. Because there is no corresponding test
instance an <code class="docutils literal notranslate"><span class="pre">_ErrorHolder</span></code> object (that has the same interface as a
<a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>) is created to represent the error. If you are just using
the standard unittest test runner then this detail doesn’t matter, but if you
are a framework author it may be relevant.</p>
<section id="setupclass-and-teardownclass">
<h3>setUpClass and tearDownClass<a class="headerlink" href="#setupclass-and-teardownclass" title="Link permanente para este título">¶</a></h3>
<p>These must be implemented as class methods:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">unittest</span>

<span class="k">class</span> <span class="nc">Test</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">setUpClass</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_connection</span> <span class="o">=</span> <span class="n">createExpensiveConnectionObject</span><span class="p">()</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">tearDownClass</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">destroy</span><span class="p">()</span>
</pre></div>
</div>
<p>If you want the <code class="docutils literal notranslate"><span class="pre">setUpClass</span></code> and <code class="docutils literal notranslate"><span class="pre">tearDownClass</span></code> on base classes called
then you must call up to them yourself. The implementations in
<a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> are empty.</p>
<p>If an exception is raised during a <code class="docutils literal notranslate"><span class="pre">setUpClass</span></code> then the tests in the class
are not run and the <code class="docutils literal notranslate"><span class="pre">tearDownClass</span></code> is not run. Skipped classes will not
have <code class="docutils literal notranslate"><span class="pre">setUpClass</span></code> or <code class="docutils literal notranslate"><span class="pre">tearDownClass</span></code> run. If the exception is a
<a class="reference internal" href="#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SkipTest</span></code></a> exception then the class will be reported as having been skipped
instead of as an error.</p>
</section>
<section id="setupmodule-and-teardownmodule">
<h3>setUpModule and tearDownModule<a class="headerlink" href="#setupmodule-and-teardownmodule" title="Link permanente para este título">¶</a></h3>
<p>These should be implemented as functions:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">setUpModule</span><span class="p">():</span>
    <span class="n">createConnection</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">tearDownModule</span><span class="p">():</span>
    <span class="n">closeConnection</span><span class="p">()</span>
</pre></div>
</div>
<p>If an exception is raised in a <code class="docutils literal notranslate"><span class="pre">setUpModule</span></code> then none of the tests in the
module will be run and the <code class="docutils literal notranslate"><span class="pre">tearDownModule</span></code> will not be run. If the exception is a
<a class="reference internal" href="#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SkipTest</span></code></a> exception then the module will be reported as having been skipped
instead of as an error.</p>
<p>To add cleanup code that must be run even in the case of an exception, use
<code class="docutils literal notranslate"><span class="pre">addModuleCleanup</span></code>:</p>
<dl class="py function">
<dt id="unittest.addModuleCleanup">
<code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">addModuleCleanup</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">function</span></em>, <em class="sig-param"><span class="o">/</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.addModuleCleanup" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Add a function to be called after <code class="xref py py-func docutils literal notranslate"><span class="pre">tearDownModule()</span></code> to cleanup
resources used during the test class. Functions will be called in reverse
order to the order they are added (<abbr title="last-in, first-out">LIFO</abbr>).
They are called with any arguments and keyword arguments passed into
<a class="reference internal" href="#unittest.addModuleCleanup" title="unittest.addModuleCleanup"><code class="xref py py-meth docutils literal notranslate"><span class="pre">addModuleCleanup()</span></code></a> when they are added.</p>
<p>If <code class="xref py py-meth docutils literal notranslate"><span class="pre">setUpModule()</span></code> fails, meaning that <code class="xref py py-func docutils literal notranslate"><span class="pre">tearDownModule()</span></code> is not
called, then any cleanup functions added will still be called.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.8.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="unittest.doModuleCleanups">
<code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">doModuleCleanups</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.doModuleCleanups" title="Link permanente para esta definição">¶</a></dt>
<dd><p>This function is called unconditionally after <code class="xref py py-func docutils literal notranslate"><span class="pre">tearDownModule()</span></code>, or
after <code class="xref py py-func docutils literal notranslate"><span class="pre">setUpModule()</span></code> if <code class="xref py py-func docutils literal notranslate"><span class="pre">setUpModule()</span></code> raises an exception.</p>
<p>It is responsible for calling all the cleanup functions added by
<a class="reference internal" href="#unittest.addModuleCleanup" title="unittest.addModuleCleanup"><code class="xref py py-func docutils literal notranslate"><span class="pre">addModuleCleanup()</span></code></a>. If you need cleanup functions to be called
<em>prior</em> to <code class="xref py py-func docutils literal notranslate"><span class="pre">tearDownModule()</span></code> then you can call
<a class="reference internal" href="#unittest.doModuleCleanups" title="unittest.doModuleCleanups"><code class="xref py py-func docutils literal notranslate"><span class="pre">doModuleCleanups()</span></code></a> yourself.</p>
<p><a class="reference internal" href="#unittest.doModuleCleanups" title="unittest.doModuleCleanups"><code class="xref py py-func docutils literal notranslate"><span class="pre">doModuleCleanups()</span></code></a> pops methods off the stack of cleanup
functions one at a time, so it can be called at any time.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.8.</span></p>
</div>
</dd></dl>

</section>
</section>
<section id="signal-handling">
<h2>Tratamento de sinal<a class="headerlink" href="#signal-handling" title="Link permanente para este título">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.2.</span></p>
</div>
<p>The <a class="reference internal" href="#cmdoption-unittest-c"><code class="xref std std-option docutils literal notranslate"><span class="pre">-c/--catch</span></code></a> command-line option to unittest,
along with the <code class="docutils literal notranslate"><span class="pre">catchbreak</span></code> parameter to <a class="reference internal" href="#unittest.main" title="unittest.main"><code class="xref py py-func docutils literal notranslate"><span class="pre">unittest.main()</span></code></a>, provide
more friendly handling of control-C during a test run. With catch break
behavior enabled control-C will allow the currently running test to complete,
and the test run will then end and report all the results so far. A second
control-c will raise a <a class="reference internal" href="exceptions.html#KeyboardInterrupt" title="KeyboardInterrupt"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> in the usual way.</p>
<p>The control-c handling signal handler attempts to remain compatible with code or
tests that install their own <a class="reference internal" href="signal.html#signal.SIGINT" title="signal.SIGINT"><code class="xref py py-const docutils literal notranslate"><span class="pre">signal.SIGINT</span></code></a> handler. If the <code class="docutils literal notranslate"><span class="pre">unittest</span></code>
handler is called but <em>isn’t</em> the installed <a class="reference internal" href="signal.html#signal.SIGINT" title="signal.SIGINT"><code class="xref py py-const docutils literal notranslate"><span class="pre">signal.SIGINT</span></code></a> handler,
i.e. it has been replaced by the system under test and delegated to, then it
calls the default handler. This will normally be the expected behavior by code
that replaces an installed handler and delegates to it. For individual tests
that need <code class="docutils literal notranslate"><span class="pre">unittest</span></code> control-c handling disabled the <a class="reference internal" href="#unittest.removeHandler" title="unittest.removeHandler"><code class="xref py py-func docutils literal notranslate"><span class="pre">removeHandler()</span></code></a>
decorator can be used.</p>
<p>There are a few utility functions for framework authors to enable control-c
handling functionality within test frameworks.</p>
<dl class="py function">
<dt id="unittest.installHandler">
<code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">installHandler</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.installHandler" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Install the control-c handler. When a <a class="reference internal" href="signal.html#signal.SIGINT" title="signal.SIGINT"><code class="xref py py-const docutils literal notranslate"><span class="pre">signal.SIGINT</span></code></a> is received
(usually in response to the user pressing control-c) all registered results
have <a class="reference internal" href="#unittest.TestResult.stop" title="unittest.TestResult.stop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stop()</span></code></a> called.</p>
</dd></dl>

<dl class="py function">
<dt id="unittest.registerResult">
<code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">registerResult</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">result</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.registerResult" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Register a <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a> object for control-c handling. Registering a
result stores a weak reference to it, so it doesn’t prevent the result from
being garbage collected.</p>
<p>Registering a <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a> object has no side-effects if control-c
handling is not enabled, so test frameworks can unconditionally register
all results they create independently of whether or not handling is enabled.</p>
</dd></dl>

<dl class="py function">
<dt id="unittest.removeResult">
<code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">removeResult</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">result</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.removeResult" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Remove um resultado registrado. Dado que um resultado for removido, então <a class="reference internal" href="#unittest.TestResult.stop" title="unittest.TestResult.stop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stop()</span></code></a> não será mais chamado no objeto resultado em resposta a um Ctrl+C</p>
</dd></dl>

<dl class="py function">
<dt id="unittest.removeHandler">
<code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">removeHandler</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">function</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.removeHandler" title="Link permanente para esta definição">¶</a></dt>
<dd><p>When called without arguments this function removes the control-c handler
if it has been installed. This function can also be used as a test decorator
to temporarily remove the handler while the test is being executed:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@unittest</span><span class="o">.</span><span class="n">removeHandler</span>
<span class="k">def</span> <span class="nf">test_signal_handling</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Tabela de Conteúdo</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code> — Framework de Testes Unitários</a><ul>
<li><a class="reference internal" href="#basic-example">Exemplo Básico</a></li>
<li><a class="reference internal" href="#command-line-interface">Interface de Linha de Comando</a><ul>
<li><a class="reference internal" href="#command-line-options">Opções de linha de comando</a></li>
</ul>
</li>
<li><a class="reference internal" href="#test-discovery">Test Discovery</a></li>
<li><a class="reference internal" href="#organizing-test-code">Organizando código teste</a></li>
<li><a class="reference internal" href="#re-using-old-test-code">Reutilizando códigos de teste antigos</a></li>
<li><a class="reference internal" href="#skipping-tests-and-expected-failures">Ignorando testes e falhas esperadas</a></li>
<li><a class="reference internal" href="#distinguishing-test-iterations-using-subtests">Distinguindo iterações de teste utilizando subtestes</a></li>
<li><a class="reference internal" href="#classes-and-functions">Classes e funções</a><ul>
<li><a class="reference internal" href="#test-cases">Casos de teste</a><ul>
<li><a class="reference internal" href="#deprecated-aliases">Deprecated aliases</a></li>
</ul>
</li>
<li><a class="reference internal" href="#grouping-tests">Grouping tests</a></li>
<li><a class="reference internal" href="#loading-and-running-tests">Carregando e executando testes</a><ul>
<li><a class="reference internal" href="#load-tests-protocol">load_tests Protocol</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#class-and-module-fixtures">Classes e Módulos de Definição de Contexto</a><ul>
<li><a class="reference internal" href="#setupclass-and-teardownclass">setUpClass and tearDownClass</a></li>
<li><a class="reference internal" href="#setupmodule-and-teardownmodule">setUpModule and tearDownModule</a></li>
</ul>
</li>
<li><a class="reference internal" href="#signal-handling">Tratamento de sinal</a></li>
</ul>
</li>
</ul>

  <h4>Tópico anterior</h4>
  <p class="topless"><a href="doctest.html"
                        title="capítulo anterior"><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code> — Teste exemplos interativos de Python</a></p>
  <h4>Próximo tópico</h4>
  <p class="topless"><a href="unittest.mock.html"
                        title="próximo capítulo"><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest.mock</span></code> — biblioteca de objeto mock</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Relatar um erro</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.10/Doc/library/unittest.rst"
            rel="nofollow">Exibir código-fonte
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegação</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice geral"
             >índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="unittest.mock.html" title="unittest.mock — biblioteca de objeto mock"
             >próximo</a> |</li>
        <li class="right" >
          <a href="doctest.html" title="doctest — Teste exemplos interativos de Python"
             >anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.10.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >A Biblioteca Padrão do Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="development.html" >Ferramentas de Desenvolvimento</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code> — Framework de Testes Unitários</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Busca rápida" aria-label="Busca rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Direitos autorais</a> 2001-2022, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    Última atualização em jun. 04, 2022.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.4.3.
    </div>

  </body>
</html>