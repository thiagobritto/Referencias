
<!DOCTYPE html>

<html lang="pt_BR">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17: http://docutils.sourceforge.net/" />

    <title>re — Operações com expressões regulares &#8212; documentação Python 3.10.4</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pydoctheme.css?2022.1" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Pesquisar dentro de documentação Python 3.10.4"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="Sobre esses documentos" href="../about.html" />
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Buscar" href="../search.html" />
    <link rel="copyright" title="Direitos autorais" href="../copyright.html" />
    <link rel="next" title="difflib — Helpers for computing deltas" href="difflib.html" />
    <link rel="prev" title="string — Operações comuns de strings" href="string.html" />
    <link rel="canonical" href="https://docs.python.org/3/library/re.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <label for="menuToggler" class="toggler__label">
        <span></span>
    </label>
    <nav class="nav-content" role="navigation">
         <a href="https://www.python.org/" class="nav-logo">
             <img src="../_static/py.svg" alt="Logo"/>
         </a>
        <div class="version_switcher_placeholder"></div>
        <form role="search" class="search" action="../search.html" method="get">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                <path fill-rule="nonzero"
                        d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="#444"></path>
            </svg>
            <input type="text" name="q" aria-label="Busca rápida"/>
            <input type="submit" value="Ir"/>
        </form>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
  <h3><a href="../contents.html">Tabela de Conteúdo</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code> — Operações com expressões regulares</a><ul>
<li><a class="reference internal" href="#regular-expression-syntax">Sintaxe de expressão regular</a></li>
<li><a class="reference internal" href="#module-contents">Conteúdo do módulo</a><ul>
<li><a class="reference internal" href="#flags">Flags</a></li>
<li><a class="reference internal" href="#functions">Functions</a></li>
<li><a class="reference internal" href="#exceptions">Exceptions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#regular-expression-objects">Objetos expressão regular</a></li>
<li><a class="reference internal" href="#match-objects">Objetos correspondência</a></li>
<li><a class="reference internal" href="#regular-expression-examples">Exemplos de expressão regular</a><ul>
<li><a class="reference internal" href="#checking-for-a-pair">Verificando por um par</a></li>
<li><a class="reference internal" href="#simulating-scanf">Simulando scanf()</a></li>
<li><a class="reference internal" href="#search-vs-match">search() vs. match()</a></li>
<li><a class="reference internal" href="#making-a-phonebook">Criando uma lista telefônica</a></li>
<li><a class="reference internal" href="#text-munging">Mastigação de texto</a></li>
<li><a class="reference internal" href="#finding-all-adverbs">Encontrando todos os advérbios</a></li>
<li><a class="reference internal" href="#finding-all-adverbs-and-their-positions">Encontrando todos os advérbios e suas posições</a></li>
<li><a class="reference internal" href="#raw-string-notation">Notação de string bruta</a></li>
<li><a class="reference internal" href="#writing-a-tokenizer">Escrevendo um tokenizador</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Tópico anterior</h4>
  <p class="topless"><a href="string.html"
                        title="capítulo anterior"><code class="xref py py-mod docutils literal notranslate"><span class="pre">string</span></code> — Operações comuns de strings</a></p>
  <h4>Próximo tópico</h4>
  <p class="topless"><a href="difflib.html"
                        title="próximo capítulo"><code class="xref py py-mod docutils literal notranslate"><span class="pre">difflib</span></code> — Helpers for computing deltas</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Relatar um erro</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.10/Doc/library/re.rst"
            rel="nofollow">Exibir código-fonte
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegação</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice geral"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="difflib.html" title="difflib — Helpers for computing deltas"
             accesskey="N">próximo</a> |</li>
        <li class="right" >
          <a href="string.html" title="string — Operações comuns de strings"
             accesskey="P">anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.10.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >A Biblioteca Padrão do Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="text.html" accesskey="U">Serviços de Processamento de Texto</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code> — Operações com expressões regulares</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Busca rápida" aria-label="Busca rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="module-re">
<span id="re-regular-expression-operations"></span><h1><a class="reference internal" href="#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> — Operações com expressões regulares<a class="headerlink" href="#module-re" title="Link permanente para este título">¶</a></h1>
<p><strong>Código-fonte:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.10/Lib/re.py">Lib/re.py</a></p>
<hr class="docutils" />
<p>Este módulo fornece operações para correspondência de expressões regulares semelhantes às encontradas em Perl. O nome do módulo vem das iniciais do termo em inglês <em>regular expressions</em>, RE. <em>Regular expressions</em> também são frequentemente chamadas de <em>regex</em>.</p>
<p>Ambos os padrões e strings a serem pesquisados podem ser strings Unicode (<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>) assim como strings de 8 bits (<a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>). No entanto, strings Unicode e strings de 8 bits não podem ser misturadas: ou seja, você não pode corresponder uma string Unicode com um padrão de bytes ou vice-versa; da mesma forma, ao solicitar uma substituição, a string de substituição deve ser do mesmo tipo que o padrão e a string de pesquisa.</p>
<p>Expressões regulares usam o caractere de contrabarra (<code class="docutils literal notranslate"><span class="pre">'\'</span></code>) para indicar formas especiais ou para permitir que caracteres especiais sejam usados sem invocar seu significado especial. Isso colide com o uso do Python do mesmo caractere para o mesmo propósito em literais de string; por exemplo, para corresponder a uma contrabarra literal, pode-se ter que escrever <code class="docutils literal notranslate"><span class="pre">'\\\\'</span></code> como a string de padrão, porque a expressão regular deve ser <code class="docutils literal notranslate"><span class="pre">\\</span></code>, e cada contrabarra deve ser expressa como <code class="docutils literal notranslate"><span class="pre">\\</span></code> dentro de um literal de string Python regular. Além disso, observe que quaisquer sequências de escape inválidas no uso do Python da contrabarra em literais de string agora levantam uma exceção <a class="reference internal" href="exceptions.html#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a> e no futuro isso se tornará um <a class="reference internal" href="exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a>. Esse comportamento acontecerá mesmo se for uma sequência de escape válida para uma expressão regular.</p>
<p>A solução é usar a notação de string bruta do Python para padrões de expressão regular; as contrabarras não são tratadas de nenhuma maneira especial em uma string literal com o prefixo <code class="docutils literal notranslate"><span class="pre">'r'</span></code>. Portanto, <code class="docutils literal notranslate"><span class="pre">r&quot;\n&quot;</span></code> é uma string de dois caracteres contendo <code class="docutils literal notranslate"><span class="pre">'\'</span></code> e <code class="docutils literal notranslate"><span class="pre">'n'</span></code>, enquanto <code class="docutils literal notranslate"><span class="pre">&quot;\n&quot;</span></code> é uma string de um caractere contendo um nova linha. Normalmente, os padrões serão expressos em código Python usando esta notação de string bruta.</p>
<p>É importante notar que a maioria das operações de expressão regular estão disponíveis como funções e métodos em nível de módulo em <a class="reference internal" href="#re-objects"><span class="std std-ref">expressões regulares compiladas</span></a>. As funções são atalhos que não exigem que você compile um objeto regex primeiro, mas perdem alguns parâmetros de ajuste fino.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver também</p>
<p>O módulo de terceiros <a class="reference external" href="https://pypi.org/project/regex/">regex</a> possui uma API compatível com o módulo da biblioteca padrão <a class="reference internal" href="#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a>, mas oferece funcionalidades adicionais e um suporte mais completo a Unicode.</p>
</div>
<section id="regular-expression-syntax">
<span id="re-syntax"></span><h2>Sintaxe de expressão regular<a class="headerlink" href="#regular-expression-syntax" title="Link permanente para este título">¶</a></h2>
<p>Uma expressão regular (ou ER) especifica um conjunto de strings que corresponde a ela; as funções neste módulo permitem que você verifique se uma determinada string corresponde a uma determinada expressão regular (ou se uma determinada expressão regular corresponde a uma determinada string, o que resulta na mesma coisa).</p>
<p>As expressões regulares podem ser concatenadas para formar novas expressões regulares; se <em>A</em> e <em>B</em> forem expressões regulares, então <em>AB</em> também será uma expressão regular. Em geral, se uma string <em>p</em> corresponder a <em>A</em> e outra string <em>q</em> corresponder a <em>B</em>, a string <em>pq</em> corresponderá a AB. Isso é válido, a menos que <em>A</em> ou <em>B</em> contenham operações de baixa precedência; condições de contorno entre <em>A</em> e <em>B</em>; ou ter referências de grupo numeradas. Assim, expressões complexas podem ser facilmente construídas a partir de expressões primitivas mais simples, como as descritas aqui. Para obter detalhes sobre a teoria e implementação de expressões regulares, consulte o livro de Friedl <a class="reference internal" href="#frie09" id="id1"><span>[Frie09]</span></a>, ou quase qualquer livro sobre construção de compiladores.</p>
<p>Segue uma breve explicação do formato das expressões regulares. Para mais informações e uma apresentação mais suave, consulte o <a class="reference internal" href="../howto/regex.html#regex-howto"><span class="std std-ref">Expressões Regulares HOWTO</span></a>.</p>
<p>As expressões regulares podem conter caracteres especiais e comuns. A maioria dos caracteres comuns, como <code class="docutils literal notranslate"><span class="pre">'A'</span></code>, <code class="docutils literal notranslate"><span class="pre">'a'</span></code> ou <code class="docutils literal notranslate"><span class="pre">'0'</span></code>, são as expressões regulares mais simples; eles simplesmente se correspondem. Você pode concatenar caracteres comuns, de forma que <code class="docutils literal notranslate"><span class="pre">último</span></code> corresponda à string <code class="docutils literal notranslate"><span class="pre">'último'</span></code>. (No restante desta seção, escreveremos ERs <code class="docutils literal notranslate"><span class="pre">neste</span> <span class="pre">estilo</span> <span class="pre">especial</span></code>, geralmente sem aspas, e strings para serem correspondidas <code class="docutils literal notranslate"><span class="pre">'entre</span> <span class="pre">aspas</span> <span class="pre">simples'</span></code>.)</p>
<p>Alguns caracteres, como <code class="docutils literal notranslate"><span class="pre">'|'</span></code> ou <code class="docutils literal notranslate"><span class="pre">'('</span></code>, são especiais. Os caracteres especiais representam classes de caracteres comuns ou afetam como as expressões regulares em torno deles são interpretadas.</p>
<p>Qualificadores de repetição (<code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">?</span></code>, <code class="docutils literal notranslate"><span class="pre">{m,n}</span></code> etc) não podem ser aninhados diretamente. Isso evita ambiguidade com o sufixo modificador não guloso <code class="docutils literal notranslate"><span class="pre">?</span></code>, e com outros modificadores em outras implementações. Para aplicar uma segunda repetição a uma repetição interna, podem ser usados parênteses. Por exemplo, a expressão <code class="docutils literal notranslate"><span class="pre">(?:a{6})*</span></code> corresponde a qualquer múltiplo de seis caracteres <code class="docutils literal notranslate"><span class="pre">'a'</span></code>.</p>
<p>Os caracteres especiais são:</p>
<dl class="simple" id="index-0">
<dt><code class="docutils literal notranslate"><span class="pre">.</span></code></dt><dd><p>(Ponto.) No modo padrão, corresponde a qualquer caractere, exceto uma nova linha. Se o sinalizador <a class="reference internal" href="#re.DOTALL" title="re.DOTALL"><code class="xref py py-const docutils literal notranslate"><span class="pre">DOTALL</span></code></a> foi especificado, ele corresponde a qualquer caractere, incluindo uma nova linha.</p>
</dd>
</dl>
<dl class="simple" id="index-1">
<dt><code class="docutils literal notranslate"><span class="pre">^</span></code></dt><dd><p>(Sinal de circunflexo.) Corresponde ao início da string, e no modo <a class="reference internal" href="#re.MULTILINE" title="re.MULTILINE"><code class="xref py py-const docutils literal notranslate"><span class="pre">MULTILINE</span></code></a> também corresponde imediatamente após cada nova linha.</p>
</dd>
</dl>
<dl class="simple" id="index-2">
<dt><code class="docutils literal notranslate"><span class="pre">$</span></code></dt><dd><p>Corresponde ao final da string ou logo antes da nova linha no final da string, e no modo <a class="reference internal" href="#re.MULTILINE" title="re.MULTILINE"><code class="xref py py-const docutils literal notranslate"><span class="pre">MULTILINE</span></code></a> também corresponde antes de uma nova linha. <code class="docutils literal notranslate"><span class="pre">foo</span></code> corresponde a ‘foo’ e ‘foobar’, enquanto a expressão regular <code class="docutils literal notranslate"><span class="pre">foo$</span></code> corresponde apenas a ‘foo’. Mais interessante, pesquisar por <code class="docutils literal notranslate"><span class="pre">foo.$</span></code> em <code class="docutils literal notranslate"><span class="pre">'foo1\nfoo2\n'</span></code> corresponde a ‘foo2’ normalmente, mas ‘foo1’ no modo <a class="reference internal" href="#re.MULTILINE" title="re.MULTILINE"><code class="xref py py-const docutils literal notranslate"><span class="pre">MULTILINE</span></code></a>; procurando por um único <code class="docutils literal notranslate"><span class="pre">$</span></code> em <code class="docutils literal notranslate"><span class="pre">'foo\n'</span></code> encontrará duas correspondências (vazias): uma logo antes da nova linha e uma no final da string.</p>
</dd>
</dl>
<dl class="simple" id="index-3">
<dt><code class="docutils literal notranslate"><span class="pre">*</span></code></dt><dd><p>Faz com que a ER resultante corresponda a 0 ou mais repetições da ER anterior, tantas repetições quantas forem possíveis. <code class="docutils literal notranslate"><span class="pre">ab*</span></code> corresponderá a ‘a’, ‘ab’ ou ‘a’ seguido por qualquer número de ‘b’s.</p>
</dd>
</dl>
<dl class="simple" id="index-4">
<dt><code class="docutils literal notranslate"><span class="pre">+</span></code></dt><dd><p>Faz com que a ER resultante corresponda a 1 ou mais repetições da ER anterior. <code class="docutils literal notranslate"><span class="pre">ab+</span></code> irá corresponder a ‘a’ seguido por qualquer número diferente de zero de ‘b’s; não corresponderá apenas a ‘a’.</p>
</dd>
</dl>
<dl class="simple" id="index-5">
<dt><code class="docutils literal notranslate"><span class="pre">?</span></code></dt><dd><p>Faz com que a ER resultante corresponda a 0 ou 1 repetição da ER anterior. <code class="docutils literal notranslate"><span class="pre">ab?</span></code> irá corresponder a ‘a’ ou ‘ab’.</p>
</dd>
</dl>
<dl class="simple" id="index-6">
<dt><code class="docutils literal notranslate"><span class="pre">*?</span></code>, <code class="docutils literal notranslate"><span class="pre">+?</span></code>, <code class="docutils literal notranslate"><span class="pre">??</span></code></dt><dd><p>Os qualificadores <code class="docutils literal notranslate"><span class="pre">'*'</span></code>, <code class="docutils literal notranslate"><span class="pre">'+'</span></code> e <code class="docutils literal notranslate"><span class="pre">'?'</span></code> são todos <em class="dfn">gulosos</em>; eles correspondem ao máximo de texto possível. Às vezes, esse comportamento não é desejado; se a ER <code class="docutils literal notranslate"><span class="pre">&lt;.*&gt;</span></code> for correspondida com <code class="docutils literal notranslate"><span class="pre">'&lt;a&gt;</span> <span class="pre">b</span> <span class="pre">&lt;c&gt;'</span></code>, ele irá corresponder a toda a string, e não apenas <code class="docutils literal notranslate"><span class="pre">'&lt;a&gt;'</span></code>. Adicionar <code class="docutils literal notranslate"><span class="pre">?</span></code> após o qualificador faz com que ele execute a correspondência da maneira <em class="dfn">não gulosa</em> ou <em class="dfn">minimalista</em>; tão <em>poucos</em> caracteres quanto possível serão correspondidos. Usando a <code class="docutils literal notranslate"><span class="pre">&lt;.*?&gt;</span></code> irá corresponder apenas <code class="docutils literal notranslate"><span class="pre">'&lt;a&gt;'</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="index-7">
<dt><code class="docutils literal notranslate"><span class="pre">{m}</span></code></dt><dd><p>Especifica que exatamente <em>m</em> cópias da ER anterior devem ser correspondidas; menos correspondências fazem com que toda a ER não seja correspondida. Por exemplo, <code class="docutils literal notranslate"><span class="pre">a{6}</span></code> irá corresponder exatamente a seis caracteres <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, mas não a cinco.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{m,n}</span></code></dt><dd><p>Faz com que a ER resultante corresponda de <em>m</em> a <em>n</em> repetições da ER precedente, tentando corresponder ao máximo de repetições possível. Por exemplo, <code class="docutils literal notranslate"><span class="pre">a{3,5}</span></code> irá corresponder de 3 a 5 caracteres <code class="docutils literal notranslate"><span class="pre">'a'</span></code>. A omissão de <em>m</em> especifica um limite inferior de zero e a omissão de <em>n</em> especifica um limite superior infinito. Como exemplo, <code class="docutils literal notranslate"><span class="pre">a{4,}b</span></code> irá corresponder a <code class="docutils literal notranslate"><span class="pre">'aaaab'</span></code> ou mil caracteres <code class="docutils literal notranslate"><span class="pre">'a'</span></code> seguidos por um <code class="docutils literal notranslate"><span class="pre">'b'</span></code>, mas não <code class="docutils literal notranslate"><span class="pre">'aaab'</span></code>. A vírgula não pode ser omitida ou o modificador será confundido com a forma descrita anteriormente.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{m,n}?</span></code></dt><dd><p>Faz com que a ER resultante corresponda de <em>m</em> a <em>n</em> repetições da ER precedente, tentando corresponder o mínimo de <em>poucas</em> repetições possível. Esta é a versão não gulosa do qualificador anterior. Por exemplo, na string de 6 caracteres <code class="docutils literal notranslate"><span class="pre">'aaaaaa'</span></code>, <code class="docutils literal notranslate"><span class="pre">a{3,5}</span></code> irá corresponder a 5 caracteres <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, enquanto <code class="docutils literal notranslate"><span class="pre">a{3,5}?</span></code> corresponderá apenas a 3 caracteres.</p>
</dd>
</dl>
<dl id="index-8">
<dt><code class="docutils literal notranslate"><span class="pre">\</span></code></dt><dd><p>Ou escapa caracteres especiais (permitindo que você corresponde a caracteres como <code class="docutils literal notranslate"><span class="pre">'*'</span></code>, <code class="docutils literal notranslate"><span class="pre">'?'</span></code> e assim por diante), ou sinaliza uma sequência especial; sequências especiais são discutidas abaixo.</p>
<p>Se você não estiver usando uma string bruta para expressar o padrão, lembre-se de que o Python também usa a contrabarra como uma sequência de escape em literais de string; se a sequência de escape não for reconhecida pelo analisador sintático do Python, a contrabarra e o caractere subsequente serão incluídos na string resultante. No entanto, se o Python reconhecer a sequência resultante, a contrabarra deve ser repetida duas vezes. Isso é complicado e difícil de entender, portanto, é altamente recomendável que você use strings bruta para todas as expressões, exceto as mais simples.</p>
</dd>
</dl>
<dl id="index-9">
<dt><code class="docutils literal notranslate"><span class="pre">[]</span></code></dt><dd><p>Usado para indicar um conjunto de caracteres. Em um conjunto:</p>
<ul class="simple">
<li><p>Caracteres podem ser listados individualmente, por exemplo, <code class="docutils literal notranslate"><span class="pre">[amk]</span></code> vai corresponder a <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, <code class="docutils literal notranslate"><span class="pre">'m'</span></code> ou <code class="docutils literal notranslate"><span class="pre">'k'</span></code>.</p></li>
</ul>
<ul class="simple" id="index-10">
<li><p>Intervalos de caracteres podem ser indicados fornecendo dois caracteres e separando-os por <code class="docutils literal notranslate"><span class="pre">'-'</span></code>, por exemplo <code class="docutils literal notranslate"><span class="pre">[a-z]</span></code> irá corresponder a qualquer letra ASCII minúscula, <code class="docutils literal notranslate"><span class="pre">[0-5][0-9]</span></code> irá corresponder a todos os números de dois dígitos de <code class="docutils literal notranslate"><span class="pre">00</span></code> a <code class="docutils literal notranslate"><span class="pre">59</span></code>, e <code class="docutils literal notranslate"><span class="pre">[0-9A-Fa-f]</span></code> irá corresponder a qualquer dígito hexadecimal. Se <code class="docutils literal notranslate"><span class="pre">-</span></code> for escapado (por exemplo, <code class="docutils literal notranslate"><span class="pre">[a\-z]</span></code>) ou se for colocado como o primeiro ou último caractere (por exemplo, <code class="docutils literal notranslate"><span class="pre">[-a]</span></code> ou <code class="docutils literal notranslate"><span class="pre">[a-]</span></code>), ele corresponderá a um literal <code class="docutils literal notranslate"><span class="pre">'-'</span></code>.</p></li>
<li><p>Os caracteres especiais perdem seu significado especial dentro dos conjuntos. Por exemplo, <code class="docutils literal notranslate"><span class="pre">[(+*)]</span></code> corresponderá a qualquer um dos caracteres literais <code class="docutils literal notranslate"><span class="pre">'('</span></code>, <code class="docutils literal notranslate"><span class="pre">'+'</span></code>, <code class="docutils literal notranslate"><span class="pre">'*'</span></code> ou <code class="docutils literal notranslate"><span class="pre">')'</span></code>.</p></li>
</ul>
<ul class="simple" id="index-11">
<li><p>Classes de caracteres como <code class="docutils literal notranslate"><span class="pre">\w</span></code> ou <code class="docutils literal notranslate"><span class="pre">\S</span></code> (definidas abaixo) também são aceitas dentro de um conjunto, embora os caracteres que correspondem dependam do modo <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> ou <a class="reference internal" href="#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">LOCALE</span></code></a> estar em vigor.</p></li>
</ul>
<ul class="simple" id="index-12">
<li><p>Os caracteres que não estão dentro de um intervalo podem ser correspondidos <em class="dfn">complementando</em> o conjunto. Se o primeiro caractere do conjunto for <code class="docutils literal notranslate"><span class="pre">'^'</span></code>, todos os caracteres que <em>não</em> estiverem no conjunto serão correspondidos. Por exemplo, <code class="docutils literal notranslate"><span class="pre">[^5]</span></code> irá corresponder a qualquer caractere exceto <code class="docutils literal notranslate"><span class="pre">'5'</span></code>, e <code class="docutils literal notranslate"><span class="pre">[^^]</span></code> irá corresponder a qualquer caractere exceto <code class="docutils literal notranslate"><span class="pre">'^'</span></code>. <code class="docutils literal notranslate"><span class="pre">^</span></code> não tem nenhum significado especial se não for o primeiro caractere do conjunto.</p></li>
<li><p>Para corresponder a um <code class="docutils literal notranslate"><span class="pre">']'</span></code> literal dentro de um conjunto, preceda-o com uma contrabarra ou coloque-o no início do conjunto. Por exemplo, <code class="docutils literal notranslate"><span class="pre">[()[\]{}]</span></code> e <code class="docutils literal notranslate"><span class="pre">[]()[{}]</span></code> ambos corresponderão a um parêntese.</p></li>
</ul>
<ul class="simple">
<li><p>Suporte de conjuntos aninhados e operações de conjunto como no <a class="reference external" href="https://unicode.org/reports/tr18/">Padrão Técnico do Unicode #18</a> podem ser adicionados no futuro. Isso mudaria a sintaxe, então para facilitar essa mudança uma <a class="reference internal" href="exceptions.html#FutureWarning" title="FutureWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FutureWarning</span></code></a> será levantada em casos ambíguos por enquanto. Isso inclui conjuntos que começam com um <code class="docutils literal notranslate"><span class="pre">'['</span></code> literal ou contendo sequências de caracteres literais <code class="docutils literal notranslate"><span class="pre">'--'</span></code>, <code class="docutils literal notranslate"><span class="pre">'&amp;&amp;'</span></code>, <code class="docutils literal notranslate"><span class="pre">'~~'</span></code> e <code class="docutils literal notranslate"><span class="pre">'||'</span></code>. Para evitar um aviso, escape-os com uma contrabarra.</p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.7: </span><a class="reference internal" href="exceptions.html#FutureWarning" title="FutureWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FutureWarning</span></code></a> é levantada se um conjunto de caracteres contém construções que mudarão semanticamente no futuro.</p>
</div>
</dd>
</dl>
<dl class="simple" id="index-13">
<dt><code class="docutils literal notranslate"><span class="pre">|</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">A|B</span></code>, onde <em>A</em> e <em>B</em> podem ser ERs arbitrárias, cria uma expressão regular que corresponderá a <em>A</em> ou <em>B</em>. Um número arbitrário de ERs pode ser separado por <code class="docutils literal notranslate"><span class="pre">'|'</span></code> desta forma. Isso também pode ser usado dentro de grupos (veja abaixo). Conforme a string alvo é percorrida, ERs separadas por <code class="docutils literal notranslate"><span class="pre">'|'</span></code> são tentadas da esquerda para a direita. Quando um padrão corresponde completamente, essa ramificação é aceita. Isso significa que, assim que <em>A</em> corresponder, <em>B</em> não será testado posteriormente, mesmo que produza uma correspondência geral mais longa. Em outras palavras, o operador <code class="docutils literal notranslate"><span class="pre">'|'</span></code> nunca é guloso. Para corresponder a um <code class="docutils literal notranslate"><span class="pre">'|'</span></code> literal, use <code class="docutils literal notranslate"><span class="pre">\|</span></code>, ou coloque-o dentro de uma classe de caractere, como em <code class="docutils literal notranslate"><span class="pre">[|]</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="index-14">
<dt><code class="docutils literal notranslate"><span class="pre">(...)</span></code></dt><dd><p>Corresponde a qualquer expressão regular que esteja entre parênteses e indica o início e o fim de um grupo; o conteúdo de um grupo pode ser recuperado após uma correspondência ter sido realizada e pode ser correspondido posteriormente na string com a sequência especial <code class="docutils literal notranslate"><span class="pre">\número</span></code>, descrita abaixo. Para corresponder aos literais <code class="docutils literal notranslate"><span class="pre">'('</span></code> ou <code class="docutils literal notranslate"><span class="pre">')'</span></code>, use <code class="docutils literal notranslate"><span class="pre">\(</span></code> ou <code class="docutils literal notranslate"><span class="pre">\)</span></code>, ou coloque-os dentro de uma classe de caracteres: <code class="docutils literal notranslate"><span class="pre">[(]</span></code>, <code class="docutils literal notranslate"><span class="pre">[)]</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="index-15">
<dt><code class="docutils literal notranslate"><span class="pre">(?...)</span></code></dt><dd><p>Esta é uma notação de extensão (um <code class="docutils literal notranslate"><span class="pre">'?'</span></code> seguindo um <code class="docutils literal notranslate"><span class="pre">'('</span></code> não é significativo de outra forma). O primeiro caractere após o <code class="docutils literal notranslate"><span class="pre">'?'</span></code> determina qual o significado e sintaxe posterior do construtor. As extensões normalmente não criam um novo grupo; <code class="docutils literal notranslate"><span class="pre">(?P&lt;nome&gt;...)</span></code> é a única exceção a esta regra. A seguir estão as extensões atualmente suportadas.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">(?aiLmsux)</span></code></dt><dd><p>(Uma ou mais letras do conjunto <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, <code class="docutils literal notranslate"><span class="pre">'i'</span></code>, <code class="docutils literal notranslate"><span class="pre">'L'</span></code>, <code class="docutils literal notranslate"><span class="pre">'m'</span></code>, <code class="docutils literal notranslate"><span class="pre">'s'</span></code>, <code class="docutils literal notranslate"><span class="pre">'u'</span></code>, <code class="docutils literal notranslate"><span class="pre">'x'</span></code>.) O grupo corresponde à string vazia; as letras definem os sinalizadores correspondentes: <a class="reference internal" href="#re.A" title="re.A"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.A</span></code></a> (correspondência somente ASCII), <a class="reference internal" href="#re.I" title="re.I"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.I</span></code></a> (não diferencia maiúsculas e minúsculas), <a class="reference internal" href="#re.L" title="re.L"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.L</span></code></a> (dependente do local), <a class="reference internal" href="#re.M" title="re.M"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.M</span></code></a> (multi-linha), <a class="reference internal" href="#re.S" title="re.S"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.S</span></code></a> (ponto corresponde a todos), <code class="xref py py-const docutils literal notranslate"><span class="pre">re.U</span></code> (correspondência Unicode) e <a class="reference internal" href="#re.X" title="re.X"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.X</span></code></a> (detalhado), para toda a expressão regular. (Os sinalizadores são descritos em <a class="reference internal" href="#contents-of-module-re"><span class="std std-ref">Conteúdo do módulo</span></a>.) Isso é útil se você deseja incluir os sinalizadores como parte da expressão regular, em vez de passar um argumento <em>flag</em> para função <a class="reference internal" href="#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.compile()</span></code></a>. Os sinalizadores devem ser usados primeiro na string de expressão.</p>
</dd>
</dl>
<dl id="index-16">
<dt><code class="docutils literal notranslate"><span class="pre">(?:...)</span></code></dt><dd><p>Uma versão sem captura de parênteses regulares. Corresponde a qualquer expressão regular que esteja entre parênteses, mas a substring correspondida pelo grupo <em>não pode</em> ser recuperada após realizar uma correspondência ou referenciada posteriormente no padrão.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">(?aiLmsux-imsx:...)</span></code></dt><dd><p>(Zero ou mais letras de o conjunto <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, <code class="docutils literal notranslate"><span class="pre">'i'</span></code>, <code class="docutils literal notranslate"><span class="pre">'L'</span></code>, <code class="docutils literal notranslate"><span class="pre">'m'</span></code>, <code class="docutils literal notranslate"><span class="pre">'s'</span></code>, <code class="docutils literal notranslate"><span class="pre">'u'</span></code>, <code class="docutils literal notranslate"><span class="pre">'x'</span></code>, opcionalmente seguido por <code class="docutils literal notranslate"><span class="pre">'-'</span></code> seguido por uma ou mais letras de <code class="docutils literal notranslate"><span class="pre">'i'</span></code>, <code class="docutils literal notranslate"><span class="pre">'m'</span></code>, <code class="docutils literal notranslate"><span class="pre">'s'</span></code>, <code class="docutils literal notranslate"><span class="pre">'x'</span></code>. ) As letras definem ou removem os sinalizadores correspondentes: <a class="reference internal" href="#re.A" title="re.A"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.A</span></code></a> (correspondência somente ASCII), <a class="reference internal" href="#re.I" title="re.I"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.I</span></code></a> (não diferencia maiúsculas e minúsculas), <a class="reference internal" href="#re.L" title="re.L"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.L</span></code></a> (dependente do local), <a class="reference internal" href="#re.M" title="re.M"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.M</span></code></a> (multi-linhas), <a class="reference internal" href="#re.S" title="re.S"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.S</span></code></a> (ponto corresponde a todos), <code class="xref py py-const docutils literal notranslate"><span class="pre">re.U</span></code> (correspondência Unicode) e <a class="reference internal" href="#re.X" title="re.X"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.X</span></code></a> (detalhamento), para a parte da expressão. (Os sinalizadores são descritos em <a class="reference internal" href="#contents-of-module-re"><span class="std std-ref">Conteúdo do módulo</span></a>.)</p>
<p>As letras <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, <code class="docutils literal notranslate"><span class="pre">'L'</span></code> e <code class="docutils literal notranslate"><span class="pre">'u'</span></code> são mutuamente exclusivas quando usadas como sinalizadores em linha, portanto, não podem ser correspondidas ou seguir <code class="docutils literal notranslate"><span class="pre">'-'</span></code>. Em vez disso, quando um deles aparece em um grupo embutido, ele substitui o modo de correspondência no grupo anexo. Em padrões Unicode <code class="docutils literal notranslate"><span class="pre">(?a:...)</span></code> muda para correspondência somente ASCII, e <code class="docutils literal notranslate"><span class="pre">(?u:...)</span></code> muda para correspondência Unicode (padrão). No padrão de byte <code class="docutils literal notranslate"><span class="pre">(?L:...)</span></code> muda para a localidade dependendo da correspondência, e <code class="docutils literal notranslate"><span class="pre">(?a:...)</span></code> muda para correspondência apenas ASCII (padrão). Esta substituição só tem efeito para o grupo estreito em linha e o modo de correspondência original é restaurado fora do grupo.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.6.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.7: </span>As letras <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, <code class="docutils literal notranslate"><span class="pre">'L'</span></code> e <code class="docutils literal notranslate"><span class="pre">'u'</span></code> também podem ser usadas em um grupo.</p>
</div>
</dd>
</dl>
<dl id="index-17">
<dt><code class="docutils literal notranslate"><span class="pre">(?P&lt;nome&gt;...)</span></code></dt><dd><p>Semelhante aos parênteses regulares, mas a substring correspondida pelo grupo é acessível por meio do nome de grupo simbólico <em>nome</em>. Os nomes de grupo devem ser identificadores Python válidos e cada nome de grupo deve ser definido apenas uma vez em uma expressão regular. Um grupo simbólico também é um grupo numerado, como se o grupo não tivesse um nome.</p>
<p>Grupos nomeados podem ser referenciados em três contextos. Se o padrão for <code class="docutils literal notranslate"><span class="pre">(?P&lt;quote&gt;['&quot;]).*?(?P=quote)</span></code> (ou seja, corresponder a uma string entre aspas simples ou duplas):</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 53%" />
<col style="width: 47%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Contexto de referência ao grupo “quote”</p></th>
<th class="head"><p>Formas de referenciá-lo</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>no mesmo padrão</p></td>
<td><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">(?P=quote)</span></code> (como mostrado)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">\1</span></code></p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>ao processar a correspondência do objeto <em>m</em></p></td>
<td><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">m.group('quote')</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">m.end('quote')</span></code> (etc.)</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>em uma string passada para o argumento <em>repl</em> de <code class="docutils literal notranslate"><span class="pre">re.sub()</span></code></p></td>
<td><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">\g&lt;quote&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">\g&lt;1&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">\1</span></code></p></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd>
</dl>
<dl class="simple" id="index-18">
<dt><code class="docutils literal notranslate"><span class="pre">(?P=name)</span></code></dt><dd><p>Uma referência anterior a um grupo nomeado; corresponde a qualquer texto que corresponda ao grupo anterior denominado <em>name</em>.</p>
</dd>
</dl>
<dl class="simple" id="index-19">
<dt><code class="docutils literal notranslate"><span class="pre">(?#...)</span></code></dt><dd><p>Um comentário; o conteúdo dos parênteses é simplesmente ignorado.</p>
</dd>
</dl>
<dl class="simple" id="index-20">
<dt><code class="docutils literal notranslate"><span class="pre">(?=...)</span></code></dt><dd><p>Corresponde se <code class="docutils literal notranslate"><span class="pre">...</span></code> corresponder a próxima, mas não consome nada da string. Isso é chamado de <em class="dfn">asserção preditiva</em>. Por exemplo, <code class="docutils literal notranslate"><span class="pre">Isaac</span> <span class="pre">(?=Asimov)</span></code> corresponderá a <code class="docutils literal notranslate"><span class="pre">'Isaac</span> <span class="pre">'</span></code> apenas se for seguido por <code class="docutils literal notranslate"><span class="pre">'Asimov'</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="index-21">
<dt><code class="docutils literal notranslate"><span class="pre">(?!...)</span></code></dt><dd><p>Corresponde se <code class="docutils literal notranslate"><span class="pre">...</span></code> não corresponder a próxima. Isso é uma <em class="dfn">asserção preditiva negativa</em>. Por exemplo, <code class="docutils literal notranslate"><span class="pre">Isaac</span> <span class="pre">(?!Asimov)</span></code> corresponderá a <code class="docutils literal notranslate"><span class="pre">'Isaac</span> <span class="pre">'</span></code> apenas se <em>não</em> for seguido por <code class="docutils literal notranslate"><span class="pre">'Asimov'</span></code>.</p>
</dd>
</dl>
<dl id="index-22">
<dt><code class="docutils literal notranslate"><span class="pre">(?&lt;=...)</span></code></dt><dd><p>Corresponde se a posição atual na string for precedida por uma correspondência para <code class="docutils literal notranslate"><span class="pre">...</span></code> que termina na posição atual. Isso é chamado de <em class="dfn">asserção retroativa positiva</em>. <code class="docutils literal notranslate"><span class="pre">(?&lt;=abc)def</span></code> irá encontrar uma correspondência em <code class="docutils literal notranslate"><span class="pre">'abcdef'</span></code>, uma vez que a expressão regular vai voltar 3 caracteres e verificar se o padrão contido corresponde. O padrão contido deve corresponder apenas a strings de algum comprimento fixo, o que significa que <code class="docutils literal notranslate"><span class="pre">abc</span></code> ou <code class="docutils literal notranslate"><span class="pre">a|b</span></code> são permitidos, mas <code class="docutils literal notranslate"><span class="pre">a*</span></code> e <code class="docutils literal notranslate"><span class="pre">a{3,4}</span></code> não são. Observe que os padrões que começam com asserções retroativas positivas não corresponderão ao início da string que está sendo pesquisada; você provavelmente desejará usar a função <a class="reference internal" href="#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">search()</span></code></a> em vez da função <a class="reference internal" href="#re.match" title="re.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">match()</span></code></a>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">re</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;(?&lt;=abc)def&#39;</span><span class="p">,</span> <span class="s1">&#39;abcdef&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">&#39;def&#39;</span>
</pre></div>
</div>
<p>Este exemplo procura por uma palavra logo após um hífen:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(?&lt;=-)\w+&#39;</span><span class="p">,</span> <span class="s1">&#39;spam-egg&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">&#39;egg&#39;</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.5: </span>Adicionado suporte para referências de grupo de comprimento fixo.</p>
</div>
</dd>
</dl>
<dl class="simple" id="index-23">
<dt><code class="docutils literal notranslate"><span class="pre">(?&lt;!...)</span></code></dt><dd><p>Corresponde se a posição atual na string não for precedida por uma correspondência para <code class="docutils literal notranslate"><span class="pre">...</span></code>. Isso é chamado de <em class="dfn">asserção retroativa negativa</em>. Semelhante às asserções retroativas positivas, o padrão contido deve corresponder apenas a strings de algum comprimento fixo. Os padrões que começam com asserções retroativas negativas podem corresponder ao início da string que está sendo pesquisada.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">(?(id/nome)padrão-sim|padrão-não)</span></code></dt><dd><p>Tentará corresponder com <code class="docutils literal notranslate"><span class="pre">padrão-sim</span></code> se o grupo com determinado <em>id</em> ou <em>nome</em> existir, e com <code class="docutils literal notranslate"><span class="pre">padrão-não</span></code> se não existir. <code class="docutils literal notranslate"><span class="pre">padrão-não</span></code> é opcional e pode ser omitido. Por exemplo,  <code class="docutils literal notranslate"><span class="pre">(&lt;)?(\w+&#64;\w+(?:\.\w+)+)(?(1)&gt;|$)</span></code> é um padrão ruim de correspondência de e-mail, que corresponderá com <code class="docutils literal notranslate"><span class="pre">'&lt;usuario&#64;host.com&gt;'</span></code> bem como <code class="docutils literal notranslate"><span class="pre">'usuario&#64;host.com'</span></code>, mas não com <code class="docutils literal notranslate"><span class="pre">'&lt;usuario&#64;host.com&gt;'</span></code> nem <code class="docutils literal notranslate"><span class="pre">'usuario&#64;host.com&gt;'</span></code>.</p>
</dd>
</dl>
<p>As sequências especiais consistem em <code class="docutils literal notranslate"><span class="pre">'\'</span></code> e um caractere da lista abaixo. Se o caractere comum não for um dígito ASCII ou uma letra ASCII, a ER resultante corresponderá ao segundo caractere. Por exemplo, <code class="docutils literal notranslate"><span class="pre">\$</span></code> corresponde ao caractere <code class="docutils literal notranslate"><span class="pre">'$'</span></code>.</p>
<dl class="simple" id="index-24">
<dt><code class="docutils literal notranslate"><span class="pre">\número</span></code></dt><dd><p>Corresponde ao conteúdo do grupo de mesmo número. Os grupos são numerados a partir de 1. Por exemplo, <code class="docutils literal notranslate"><span class="pre">(.+)</span> <span class="pre">\1</span></code> corresponde a <code class="docutils literal notranslate"><span class="pre">'de</span> <span class="pre">de'</span></code> ou <code class="docutils literal notranslate"><span class="pre">'55</span> <span class="pre">55'</span></code>, mas não <code class="docutils literal notranslate"><span class="pre">'dede'</span></code> (note o espaço após o grupo). Esta sequência especial só pode ser usada para corresponder a um dos primeiros 99 grupos. Se o primeiro dígito de <em>número</em> for 0, ou <em>número</em> tiver 3 dígitos octais de comprimento, ele não será interpretado como uma correspondência de grupo, mas como o caractere com <em>número</em> de valor octal. Dentro de <code class="docutils literal notranslate"><span class="pre">'['</span></code> e <code class="docutils literal notranslate"><span class="pre">']'</span></code> de uma classe de caracteres, todos os escapes numéricos são tratados como caracteres.</p>
</dd>
</dl>
<dl class="simple" id="index-25">
<dt><code class="docutils literal notranslate"><span class="pre">\A</span></code></dt><dd><p>Corresponde apenas ao início da string.</p>
</dd>
</dl>
<dl id="index-26">
<dt><code class="docutils literal notranslate"><span class="pre">\b</span></code></dt><dd><p>Corresponde à string vazia, mas apenas no início ou no final de uma palavra. Uma palavra é definida como uma sequência de caracteres de palavras. Observe que, formalmente, <code class="docutils literal notranslate"><span class="pre">\b</span></code> é definido como a fronteira entre um caractere <code class="docutils literal notranslate"><span class="pre">\w</span></code> e um <code class="docutils literal notranslate"><span class="pre">\W</span></code> (ou vice-versa), ou entre <code class="docutils literal notranslate"><span class="pre">\w</span></code> e o início/fim da string. Isso significa que <code class="docutils literal notranslate"><span class="pre">r'\bfoo\b'</span></code> corresponde a <code class="docutils literal notranslate"><span class="pre">'foo'</span></code>, <code class="docutils literal notranslate"><span class="pre">'foo.'</span></code>, <code class="docutils literal notranslate"><span class="pre">'(foo)'</span></code>, <code class="docutils literal notranslate"><span class="pre">'bar</span> <span class="pre">foo</span> <span class="pre">baz'</span></code>, mas não a <code class="docutils literal notranslate"><span class="pre">'foobar'</span></code> ou <code class="docutils literal notranslate"><span class="pre">'foo3'</span></code>.</p>
<p>Por padrão, os alfanuméricos Unicode são aqueles usados nos padrões Unicode, mas isso pode ser alterado usando o sinalizador <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a>. Os limites das palavras são determinados pela localidade atual se o sinalizador <a class="reference internal" href="#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">LOCALE</span></code></a> for usado. Dentro de um intervalo de caracteres, <code class="docutils literal notranslate"><span class="pre">\b</span></code> representa o caractere de backspace, para compatibilidade com os literais de string do Python.</p>
</dd>
</dl>
<dl class="simple" id="index-27">
<dt><code class="docutils literal notranslate"><span class="pre">\B</span></code></dt><dd><p>Corresponde à string vazia, mas apenas quando <em>não</em> estiver no início ou no final de uma palavra. Isso significa que <code class="docutils literal notranslate"><span class="pre">r'py\B'</span></code> corresponde a <code class="docutils literal notranslate"><span class="pre">'python'</span></code>, <code class="docutils literal notranslate"><span class="pre">'py3'</span></code>, <code class="docutils literal notranslate"><span class="pre">'py2'</span></code>, mas não <code class="docutils literal notranslate"><span class="pre">'py'</span></code>, <code class="docutils literal notranslate"><span class="pre">'py.'</span></code> ou <code class="docutils literal notranslate"><span class="pre">'py!'</span></code>. <code class="docutils literal notranslate"><span class="pre">\B</span></code> é exatamente o oposto de <code class="docutils literal notranslate"><span class="pre">\b</span></code>, então caracteres de palavras em padrões Unicode são alfanuméricos Unicode ou o sublinhado, embora isso possa ser alterado usando o sinalizador <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a>. Os limites das palavras são determinados pela localidade atual se o sinalizador <a class="reference internal" href="#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">LOCALE</span></code></a> for usado.</p>
</dd>
</dl>
<dl class="simple" id="index-28">
<dt><code class="docutils literal notranslate"><span class="pre">\d</span></code></dt><dd><dl class="simple">
<dt>Para padrões (str) Unicode:</dt><dd><p>Corresponde a qualquer dígito decimal Unicode (ou seja, qualquer caractere na categoria de caractere Unicode [Nd]). Isso inclui <code class="docutils literal notranslate"><span class="pre">[0-9]</span></code>, e também muitos outros caracteres de dígitos. Se o sinalizador <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> for usado, apenas <code class="docutils literal notranslate"><span class="pre">[0-9]</span></code> será correspondido.</p>
</dd>
<dt>Para padrões de 8 bits (isto é, bytes):</dt><dd><p>Corresponde a qualquer dígito decimal; isso é equivalente a <code class="docutils literal notranslate"><span class="pre">[0-9]</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="simple" id="index-29">
<dt><code class="docutils literal notranslate"><span class="pre">\D</span></code></dt><dd><p>Corresponde a qualquer caractere que não seja um dígito decimal. Este é o oposto de <code class="docutils literal notranslate"><span class="pre">\d</span></code>. Se o sinalizador <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> for usado, isso se tornará o equivalente a <code class="docutils literal notranslate"><span class="pre">[^0-9]</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="index-30">
<dt><code class="docutils literal notranslate"><span class="pre">\s</span></code></dt><dd><dl class="simple">
<dt>Para padrões (str) Unicode:</dt><dd><p>Corresponde a caracteres de espaço em branco Unicode (que inclui <code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">\t\n\r\f\v]</span></code>, e também muitos outros caracteres, como, por exemplo, os espaços não separáveis exigidos pelas regras de tipografia em muitos idiomas). Se o sinalizador <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> for usado, apenas <code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">\t\n\r\f\v]</span></code> é correspondido.</p>
</dd>
<dt>Para padrões de 8 bits (isto é, bytes):</dt><dd><p>Corresponde a caracteres considerados espaços em branco no conjunto de caracteres ASCII; isso é equivalente a <code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">\t\n\r\f\v]</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="simple" id="index-31">
<dt><code class="docutils literal notranslate"><span class="pre">\S</span></code></dt><dd><p>Corresponde a qualquer caractere que não seja um caractere de espaço em branco. Este é o oposto de <code class="docutils literal notranslate"><span class="pre">\s</span></code>. Se o sinalizador <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> for usado, isso se tornará o equivalente a <code class="docutils literal notranslate"><span class="pre">[^</span> <span class="pre">\t\n\r\f\v]</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="index-32">
<dt><code class="docutils literal notranslate"><span class="pre">\w</span></code></dt><dd><dl class="simple">
<dt>Para padrões (str) Unicode:</dt><dd><p>Corresponde a caracteres de palavras Unicode; isso inclui a maioria dos caracteres que podem fazer parte de uma palavra em qualquer idioma, bem como números e sublinhado. Se o sinalizador <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> for usado, apenas <code class="docutils literal notranslate"><span class="pre">[a-zA-Z0-9_]</span></code> será correspondido.</p>
</dd>
<dt>Para padrões de 8 bits (isto é, bytes):</dt><dd><p>Corresponde a caracteres considerados alfanuméricos no conjunto de caracteres ASCII; isso é equivalente a <code class="docutils literal notranslate"><span class="pre">[a-zA-Z0-9_]</span></code>. Se o sinalizador <a class="reference internal" href="#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">LOCALE</span></code></a> for usado, corresponde aos caracteres considerados alfanuméricos na localidade atual e o sublinhado.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="simple" id="index-33">
<dt><code class="docutils literal notranslate"><span class="pre">\W</span></code></dt><dd><p>Corresponde a qualquer caractere que não seja um caractere de palavra. Este é o oposto de <code class="docutils literal notranslate"><span class="pre">\w</span></code>. Se o sinalizador <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> for usado, ele se tornará o equivalente a <code class="docutils literal notranslate"><span class="pre">[^a-zA-Z0-9_]</span></code>. Se o sinalizador <a class="reference internal" href="#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">LOCALE</span></code></a> for usado, corresponde a caracteres que não são alfanuméricos na localidade local atual nem o sublinhado.</p>
</dd>
</dl>
<dl class="simple" id="index-34">
<dt><code class="docutils literal notranslate"><span class="pre">\Z</span></code></dt><dd><p>Corresponde apenas ao final da string.</p>
</dd>
</dl>
<p id="index-35">A maioria dos escapes padrão suportados por literais de string Python também são aceitos pelo analisador sintático de expressão regular:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span>\<span class="n">a</span>      \<span class="n">b</span>      \<span class="n">f</span>      \<span class="n">n</span>
\<span class="n">N</span>      \<span class="n">r</span>      \<span class="n">t</span>      \<span class="n">u</span>
\<span class="n">U</span>      \<span class="n">v</span>      \<span class="n">x</span>      \\
</pre></div>
</div>
<p>(Observe que <code class="docutils literal notranslate"><span class="pre">\b</span></code> é usado para representar limites de palavras e significa fazer “backspace” apenas dentro das classes de caracteres.)</p>
<p>As sequências de escape <code class="docutils literal notranslate"><span class="pre">'\u'</span></code>, <code class="docutils literal notranslate"><span class="pre">'\U'</span></code> e <code class="docutils literal notranslate"><span class="pre">'\N'</span></code> são reconhecidas apenas em padrões Unicode. Em padrões de bytes, eles são erros. Escapes desconhecidos de letras ASCII são reservados para uso futuro e tratados como erros.</p>
<p>Os escapes octais são incluídos em um formulário limitado. Se o primeiro dígito for 0, ou se houver três dígitos octais, é considerado um escape octal. Caso contrário, é uma referência de grupo. Quanto aos literais de string, os escapes octais têm sempre no máximo três dígitos.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.3: </span>As sequências de escape <code class="docutils literal notranslate"><span class="pre">'\u'</span></code> e <code class="docutils literal notranslate"><span class="pre">'\U'</span></code> foram adicionadas.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.6: </span>Escapes desconhecidos consistindo em <code class="docutils literal notranslate"><span class="pre">'\'</span></code> e uma letra ASCII agora são erros.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.8: </span>A sequência de escape <code class="docutils literal notranslate"><span class="pre">'\N{nome}'</span></code> foi adicionada. Como em literais de string, ela se expande para o caractere Unicode nomeado (por exemplo, <code class="docutils literal notranslate"><span class="pre">'\N{EM</span> <span class="pre">DASH}'</span></code>).</p>
</div>
</section>
<section id="module-contents">
<span id="contents-of-module-re"></span><h2>Conteúdo do módulo<a class="headerlink" href="#module-contents" title="Link permanente para este título">¶</a></h2>
<p>O módulo define várias funções, constantes e uma exceção. Algumas das funções são versões simplificadas dos métodos completos para expressões regulares compiladas. A maioria das aplicações não triviais sempre usa a forma compilada.</p>
<section id="flags">
<h3>Flags<a class="headerlink" href="#flags" title="Link permanente para este título">¶</a></h3>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.6: </span>Constantes de sinalizadores agora são instâncias de <code class="xref py py-class docutils literal notranslate"><span class="pre">RegexFlag</span></code>, que é uma subclasse de <a class="reference internal" href="enum.html#enum.IntFlag" title="enum.IntFlag"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.IntFlag</span></code></a>.</p>
</div>
<dl class="py data">
<dt id="re.A">
<code class="sig-prename descclassname">re.</code><code class="sig-name descname">A</code><a class="headerlink" href="#re.A" title="Link permanente para esta definição">¶</a></dt>
<dt id="re.ASCII">
<code class="sig-prename descclassname">re.</code><code class="sig-name descname">ASCII</code><a class="headerlink" href="#re.ASCII" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Faz com que <code class="docutils literal notranslate"><span class="pre">\w</span></code>, <code class="docutils literal notranslate"><span class="pre">\W</span></code>, <code class="docutils literal notranslate"><span class="pre">\b</span></code>, <code class="docutils literal notranslate"><span class="pre">\B</span></code>, <code class="docutils literal notranslate"><span class="pre">\d</span></code>, <code class="docutils literal notranslate"><span class="pre">\D</span></code>, <code class="docutils literal notranslate"><span class="pre">\s</span></code> e <code class="docutils literal notranslate"><span class="pre">\S</span></code> executem a correspondência somente ASCII em vez da correspondência Unicode completa. Isso é significativo apenas para padrões Unicode e é ignorado para padrões de bytes. Corresponde ao sinalizador em linha <code class="docutils literal notranslate"><span class="pre">(?a)</span></code>.</p>
<p>Observe que, para compatibilidade com versões anteriores, o sinalizador <code class="xref py py-const docutils literal notranslate"><span class="pre">re.U</span></code> ainda existe (bem como seu sinônimo <code class="xref py py-const docutils literal notranslate"><span class="pre">re.UNICODE</span></code> e sua contraparte incorporada <code class="docutils literal notranslate"><span class="pre">(?u)</span></code>), mas estes são redundantes em Python 3, pois as correspondências são Unicode por padrão para strings (e a correspondência Unicode não é permitida para bytes).</p>
</dd></dl>

<dl class="py data">
<dt id="re.DEBUG">
<code class="sig-prename descclassname">re.</code><code class="sig-name descname">DEBUG</code><a class="headerlink" href="#re.DEBUG" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Exibe informações de depuração sobre a expressão compilada. Nenhum sinalizador em linha correspondente.</p>
</dd></dl>

<dl class="py data">
<dt id="re.I">
<code class="sig-prename descclassname">re.</code><code class="sig-name descname">I</code><a class="headerlink" href="#re.I" title="Link permanente para esta definição">¶</a></dt>
<dt id="re.IGNORECASE">
<code class="sig-prename descclassname">re.</code><code class="sig-name descname">IGNORECASE</code><a class="headerlink" href="#re.IGNORECASE" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Executa uma correspondência que não diferencia maiúsculas de minúsculas; expressões como <code class="docutils literal notranslate"><span class="pre">[A-Z]</span></code> também corresponderão a letras minúsculas. A correspondência Unicode completa (como <code class="docutils literal notranslate"><span class="pre">Ü</span></code> correspondendo a <code class="docutils literal notranslate"><span class="pre">ü</span></code>) também funciona, a menos que o sinalizador <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.ASCII</span></code></a> seja usado para desabilitar correspondências não ASCII. A localidade atual não muda o efeito deste sinalizador a menos que o sinalizador <a class="reference internal" href="#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.LOCALE</span></code></a> também seja usado. Corresponde ao sinalizador em linha <code class="docutils literal notranslate"><span class="pre">(?i)</span></code>.</p>
<p>Observe que quando os padrões Unicode <code class="docutils literal notranslate"><span class="pre">[a-z]</span></code> ou <code class="docutils literal notranslate"><span class="pre">[A-Z]</span></code> são usados em combinação com o sinalizador <a class="reference internal" href="#re.IGNORECASE" title="re.IGNORECASE"><code class="xref py py-const docutils literal notranslate"><span class="pre">IGNORECASE</span></code></a>, eles corresponderão às 52 letras ASCII e 4 letras não ASCII adicionais: ‘İ’ (U+0130, letra latina I maiúscula com ponto em cima), ‘ı’ (U+0131, letra latina i minúscula sem ponto), ‘ſ’ (U+017F, letra latina s minúscula longa) e ‘K’ (U+212A, sinal de Kelvin). Se o sinalizador <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> for usado, apenas as letras ‘a’ a ‘z’ e ‘A’ a ‘Z’ serão correspondidas.</p>
</dd></dl>

<dl class="py data">
<dt id="re.L">
<code class="sig-prename descclassname">re.</code><code class="sig-name descname">L</code><a class="headerlink" href="#re.L" title="Link permanente para esta definição">¶</a></dt>
<dt id="re.LOCALE">
<code class="sig-prename descclassname">re.</code><code class="sig-name descname">LOCALE</code><a class="headerlink" href="#re.LOCALE" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Faz <code class="docutils literal notranslate"><span class="pre">\w</span></code>, <code class="docutils literal notranslate"><span class="pre">\W</span></code>, <code class="docutils literal notranslate"><span class="pre">\b</span></code>, <code class="docutils literal notranslate"><span class="pre">\B</span></code> e a correspondência sem diferença entre maiúsculas e minúsculas dependente do local atual. Este sinalizador pode ser usado apenas com padrões de bytes. O uso desse sinalizador é desencorajado porque o mecanismo de localidade não é confiável, ele só lida com uma “cultura” por vez e só funciona com localidades de 8 bits. A correspondência Unicode já está habilitada por padrão no Python 3 para padrões Unicode (str) e é capaz de lidar com diferentes localidades/idiomas. Corresponde ao sinalizador em linha <code class="docutils literal notranslate"><span class="pre">(?L)</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.6: </span><a class="reference internal" href="#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.LOCALE</span></code></a> pode ser usado apenas com padrões de bytes e não é compatível com <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.ASCII</span></code></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.7: </span>Objetos expressão regular compilados com o sinalizador <a class="reference internal" href="#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.LOCALE</span></code></a> não dependem mais da localidade em tempo de compilação. Apenas a localidade no momento da correspondência afeta o resultado da correspondência.</p>
</div>
</dd></dl>

<dl class="py data">
<dt id="re.M">
<code class="sig-prename descclassname">re.</code><code class="sig-name descname">M</code><a class="headerlink" href="#re.M" title="Link permanente para esta definição">¶</a></dt>
<dt id="re.MULTILINE">
<code class="sig-prename descclassname">re.</code><code class="sig-name descname">MULTILINE</code><a class="headerlink" href="#re.MULTILINE" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Quando especificado, o caractere padrão <code class="docutils literal notranslate"><span class="pre">'^'</span></code> corresponde ao início da string e ao início de cada linha (imediatamente após cada nova linha); e o caractere padrão <code class="docutils literal notranslate"><span class="pre">'$'</span></code> corresponde ao final da string e ao final de cada linha (imediatamente antes de cada nova linha). Por padrão, <code class="docutils literal notranslate"><span class="pre">'^'</span></code> corresponde apenas no início da string, e <code class="docutils literal notranslate"><span class="pre">'$'</span></code> apenas no final da string e imediatamente antes da nova linha (se houver) no final da string. Corresponde ao sinalizador em linha <code class="docutils literal notranslate"><span class="pre">(?m)</span></code>.</p>
</dd></dl>

<dl class="py data">
<dt id="re.S">
<code class="sig-prename descclassname">re.</code><code class="sig-name descname">S</code><a class="headerlink" href="#re.S" title="Link permanente para esta definição">¶</a></dt>
<dt id="re.DOTALL">
<code class="sig-prename descclassname">re.</code><code class="sig-name descname">DOTALL</code><a class="headerlink" href="#re.DOTALL" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Faz o caractere especial <code class="docutils literal notranslate"><span class="pre">'.'</span></code> corresponder a qualquer caractere, incluindo uma nova linha; sem este sinalizador, <code class="docutils literal notranslate"><span class="pre">'.'</span></code> irá corresponder a qualquer coisa <em>exceto</em> uma nova linha. Corresponde ao sinalizador em linha <code class="docutils literal notranslate"><span class="pre">(?s)</span></code>.</p>
</dd></dl>

<dl class="py data">
<dt id="re.X">
<code class="sig-prename descclassname">re.</code><code class="sig-name descname">X</code><a class="headerlink" href="#re.X" title="Link permanente para esta definição">¶</a></dt>
<dt id="re.VERBOSE">
<code class="sig-prename descclassname">re.</code><code class="sig-name descname">VERBOSE</code><a class="headerlink" href="#re.VERBOSE" title="Link permanente para esta definição">¶</a></dt>
<dd><p id="index-36">Este sinalizador permite que você escreva expressões regulares que parecem mais agradáveis e são mais legíveis, permitindo que você separe visualmente seções lógicas do padrão e adicione comentários. O espaço em branco dentro do padrão é ignorado, exceto quando em uma classe de caractere, ou quando precedido por uma contrabarra sem escape, ou dentro de tokens como <code class="docutils literal notranslate"><span class="pre">*?</span></code>, <code class="docutils literal notranslate"><span class="pre">(?:</span></code> ou <code class="docutils literal notranslate"><span class="pre">(?P&lt;...&gt;</span></code>. Quando uma linha contém um <code class="docutils literal notranslate"><span class="pre">#</span></code> que não está em uma classe de caractere e não é precedido por uma contrabarra sem escape, todos os caracteres da extremidade esquerda, como <code class="docutils literal notranslate"><span class="pre">#</span></code> até o final da linha são ignorados.</p>
<p>Isso significa que os dois seguintes objetos expressão regular que correspondem a um número decimal são funcionalmente iguais:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;&quot;&quot;\d +  # the integral part</span>
<span class="s2">                   \.    # the decimal point</span>
<span class="s2">                   \d *  # some fractional digits&quot;&quot;&quot;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">X</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\d+\.\d*&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Corresponde ao sinalizador em linha <code class="docutils literal notranslate"><span class="pre">(?x)</span></code>.</p>
</dd></dl>

</section>
<section id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Link permanente para este título">¶</a></h3>
<dl class="py function">
<dt id="re.compile">
<code class="sig-prename descclassname">re.</code><code class="sig-name descname">compile</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pattern</span></em>, <em class="sig-param"><span class="n">flags</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.compile" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Compila um padrão de expressão regular em um <a class="reference internal" href="#re-objects"><span class="std std-ref">objeto expressão regular</span></a>, que pode ser usado para correspondência usando seu <a class="reference internal" href="#re.Pattern.match" title="re.Pattern.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">match()</span></code></a>, <a class="reference internal" href="#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">search()</span></code></a> e outros métodos, descritos abaixo.</p>
<p>O comportamento da expressão pode ser modificado especificando um valor <em>flags</em>. Os valores podem ser qualquer uma das seguintes variáveis, correspondidas usando OU bit a bit (o operador <code class="docutils literal notranslate"><span class="pre">|</span></code>).</p>
<p>A sequência</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">prog</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">prog</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
</pre></div>
</div>
<p>é equivalente a:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">string</span><span class="p">)</span>
</pre></div>
</div>
<p>mas usar <a class="reference internal" href="#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.compile()</span></code></a> e salvar o objeto expressão regular resultante para reutilização é mais eficiente quando a expressão será usada várias vezes em um único programa.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>As versões compiladas dos padrões mais recentes passados para <a class="reference internal" href="#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.compile()</span></code></a> e as funções de correspondência em nível de módulo são armazenadas em cache, de modo que programas que usam apenas algumas expressões regulares por vez não precisam se preocupar em compilar expressões regulares.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="re.search">
<code class="sig-prename descclassname">re.</code><code class="sig-name descname">search</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pattern</span></em>, <em class="sig-param"><span class="n">string</span></em>, <em class="sig-param"><span class="n">flags</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.search" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Percorre a <em>string</em> procurando o primeiro local onde o padrão <em>pattern</em> de expressão regular produz uma correspondência e retorna um <a class="reference internal" href="#match-objects"><span class="std std-ref">objeto correspondência</span></a> encontrado. Retorna <code class="docutils literal notranslate"><span class="pre">None</span></code> se nenhuma posição na string corresponder ao padrão; observe que isso é diferente de encontrar uma correspondência de comprimento zero em algum ponto da string.</p>
</dd></dl>

<dl class="py function">
<dt id="re.match">
<code class="sig-prename descclassname">re.</code><code class="sig-name descname">match</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pattern</span></em>, <em class="sig-param"><span class="n">string</span></em>, <em class="sig-param"><span class="n">flags</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.match" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Se zero ou mais caracteres no início da <em>string</em> corresponderem ao padrão <em>pattern</em> da expressão regular, retorna um <a class="reference internal" href="#match-objects"><span class="std std-ref">objeto correspondência</span></a> encontrado. Retorna <code class="docutils literal notranslate"><span class="pre">None</span></code> se a string não corresponder ao padrão; observe que isso é diferente de uma correspondência de comprimento zero.</p>
<p>Observe que mesmo no modo <a class="reference internal" href="#re.MULTILINE" title="re.MULTILINE"><code class="xref py py-const docutils literal notranslate"><span class="pre">MULTILINE</span></code></a>, <a class="reference internal" href="#re.match" title="re.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.match()</span></code></a> irá corresponder apenas no início da string e não no início de cada linha.</p>
<p>Se você quiser localizar uma correspondência em qualquer lugar em <em>string</em>, use <a class="reference internal" href="#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">search()</span></code></a> (veja também <a class="reference internal" href="#search-vs-match"><span class="std std-ref">search() vs. match()</span></a>).</p>
</dd></dl>

<dl class="py function">
<dt id="re.fullmatch">
<code class="sig-prename descclassname">re.</code><code class="sig-name descname">fullmatch</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pattern</span></em>, <em class="sig-param"><span class="n">string</span></em>, <em class="sig-param"><span class="n">flags</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.fullmatch" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Se toda a <em>string</em> corresponder ao padrão <em>pattern</em> da expressão regular, retorna um <a class="reference internal" href="#match-objects"><span class="std std-ref">objeto correspondência</span></a> encontrado. Retorna <code class="docutils literal notranslate"><span class="pre">None</span></code> se a string não corresponder ao padrão; observe que isso é diferente de uma correspondência de comprimento zero.</p>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.4.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="re.split">
<code class="sig-prename descclassname">re.</code><code class="sig-name descname">split</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pattern</span></em>, <em class="sig-param"><span class="n">string</span></em>, <em class="sig-param"><span class="n">maxsplit</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">flags</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.split" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Divide a <em>string</em> pelas ocorrências do padrão <em>pattern</em>. Se parênteses de captura forem usados em <em>pattern</em>, o texto de todos os grupos no padrão também será retornado como parte da lista resultante. Se <em>maxsplit</em> for diferente de zero, no máximo <em>maxsplit</em> divisões ocorrerão e o restante da string será retornado como o elemento final da lista.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\W+&#39;</span><span class="p">,</span> <span class="s1">&#39;Words, words, words.&#39;</span><span class="p">)</span>
<span class="go">[&#39;Words&#39;, &#39;words&#39;, &#39;words&#39;, &#39;&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\W+)&#39;</span><span class="p">,</span> <span class="s1">&#39;Words, words, words.&#39;</span><span class="p">)</span>
<span class="go">[&#39;Words&#39;, &#39;, &#39;, &#39;words&#39;, &#39;, &#39;, &#39;words&#39;, &#39;.&#39;, &#39;&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\W+&#39;</span><span class="p">,</span> <span class="s1">&#39;Words, words, words.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">[&#39;Words&#39;, &#39;words, words.&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;[a-f]+&#39;</span><span class="p">,</span> <span class="s1">&#39;0a3B9&#39;</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
<span class="go">[&#39;0&#39;, &#39;3&#39;, &#39;9&#39;]</span>
</pre></div>
</div>
<p>Se houver grupos de captura no separador e ele corresponder ao início da string, o resultado começará com uma string vazia. O mesmo vale para o final da string:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\W+)&#39;</span><span class="p">,</span> <span class="s1">&#39;...words, words...&#39;</span><span class="p">)</span>
<span class="go">[&#39;&#39;, &#39;...&#39;, &#39;words&#39;, &#39;, &#39;, &#39;words&#39;, &#39;...&#39;, &#39;&#39;]</span>
</pre></div>
</div>
<p>Dessa forma, os componentes do separador são sempre encontrados nos mesmos índices relativos na lista de resultados.</p>
<p>As correspondências vazias para o padrão dividem a string apenas quando não adjacente a uma correspondência vazia anterior.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\b&#39;</span><span class="p">,</span> <span class="s1">&#39;Words, words, words.&#39;</span><span class="p">)</span>
<span class="go">[&#39;&#39;, &#39;Words&#39;, &#39;, &#39;, &#39;words&#39;, &#39;, &#39;, &#39;words&#39;, &#39;.&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\W*&#39;</span><span class="p">,</span> <span class="s1">&#39;...words...&#39;</span><span class="p">)</span>
<span class="go">[&#39;&#39;, &#39;&#39;, &#39;w&#39;, &#39;o&#39;, &#39;r&#39;, &#39;d&#39;, &#39;s&#39;, &#39;&#39;, &#39;&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\W*)&#39;</span><span class="p">,</span> <span class="s1">&#39;...words...&#39;</span><span class="p">)</span>
<span class="go">[&#39;&#39;, &#39;...&#39;, &#39;&#39;, &#39;&#39;, &#39;w&#39;, &#39;&#39;, &#39;o&#39;, &#39;&#39;, &#39;r&#39;, &#39;&#39;, &#39;d&#39;, &#39;&#39;, &#39;s&#39;, &#39;...&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;]</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.1: </span>Adicionado o argumento de sinalizadores opcionais.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.7: </span>Adicionado suporte de divisão em um padrão que pode corresponder a uma string vazia.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="re.findall">
<code class="sig-prename descclassname">re.</code><code class="sig-name descname">findall</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pattern</span></em>, <em class="sig-param"><span class="n">string</span></em>, <em class="sig-param"><span class="n">flags</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.findall" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Return all non-overlapping matches of <em>pattern</em> in <em>string</em>, as a list of
strings or tuples.  The <em>string</em> is scanned left-to-right, and matches
are returned in the order found.  Empty matches are included in the result.</p>
<p>The result depends on the number of capturing groups in the pattern.
If there are no groups, return a list of strings matching the whole
pattern.  If there is exactly one group, return a list of strings
matching that group.  If multiple groups are present, return a list
of tuples of strings matching the groups.  Non-capturing groups do not
affect the form of the result.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\bf[a-z]*&#39;</span><span class="p">,</span> <span class="s1">&#39;which foot or hand fell fastest&#39;</span><span class="p">)</span>
<span class="go">[&#39;foot&#39;, &#39;fell&#39;, &#39;fastest&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\w+)=(\d+)&#39;</span><span class="p">,</span> <span class="s1">&#39;set width=20 and height=10&#39;</span><span class="p">)</span>
<span class="go">[(&#39;width&#39;, &#39;20&#39;), (&#39;height&#39;, &#39;10&#39;)]</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.7: </span>Correspondências não vazias agora podem começar logo após uma correspondência vazia anterior.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="re.finditer">
<code class="sig-prename descclassname">re.</code><code class="sig-name descname">finditer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pattern</span></em>, <em class="sig-param"><span class="n">string</span></em>, <em class="sig-param"><span class="n">flags</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.finditer" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna um <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterador</span></a> produzindo <a class="reference internal" href="#match-objects"><span class="std std-ref">objetos correspondência</span></a> sobre todas as correspondências não sobrepostas para o padrão <em>pattern</em> de ER na <em>string</em>. A <em>string</em> é percorrida da esquerda para a direita e as correspondências são retornadas na ordem encontrada. Correspondências vazias são incluídas no resultado.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.7: </span>Correspondências não vazias agora podem começar logo após uma correspondência vazia anterior.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="re.sub">
<code class="sig-prename descclassname">re.</code><code class="sig-name descname">sub</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pattern</span></em>, <em class="sig-param"><span class="n">repl</span></em>, <em class="sig-param"><span class="n">string</span></em>, <em class="sig-param"><span class="n">count</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">flags</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.sub" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna a string obtida substituindo as ocorrências não sobrepostas da extremidade esquerda do padrão <em>pattern</em> na <em>string</em> pela substituição <em>repl</em>. Se o padrão não for encontrado, <em>string</em> será retornado inalterado. <em>repl</em> pode ser uma string ou uma função; se for uma string, qualquer escape de contrabarra será processado. Ou seja, <code class="docutils literal notranslate"><span class="pre">\n</span></code> é convertido em um único caractere de nova linha, <code class="docutils literal notranslate"><span class="pre">\r</span></code> é convertido em um retorno de carro e assim por diante. Escapes desconhecidos de letras ASCII são reservados para uso futuro e tratados como erros. Outros escapes desconhecidos como <code class="docutils literal notranslate"><span class="pre">\&amp;</span></code> são deixados como estão. Referências anteriores, como <code class="docutils literal notranslate"><span class="pre">\6</span></code>, são substituídos pela substring correspondida pelo grupo 6 no padrão. Por exemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;def\s+([a-zA-Z_][a-zA-Z_0-9]*)\s*\(\s*\):&#39;</span><span class="p">,</span>
<span class="gp">... </span>       <span class="sa">r</span><span class="s1">&#39;static PyObject*\npy_\1(void)\n{&#39;</span><span class="p">,</span>
<span class="gp">... </span>       <span class="s1">&#39;def myfunc():&#39;</span><span class="p">)</span>
<span class="go">&#39;static PyObject*\npy_myfunc(void)\n{&#39;</span>
</pre></div>
</div>
<p>Se <em>repl</em> for uma função, ela será chamada para cada ocorrência não sobreposta do padrão <em>pattern</em>. A função recebe um único argumento <a class="reference internal" href="#match-objects"><span class="std std-ref">objeto correspondência</span></a> e retorna a string de substituição. Por exemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">dashrepl</span><span class="p">(</span><span class="n">matchobj</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">matchobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span> <span class="k">return</span> <span class="s1">&#39; &#39;</span>
<span class="gp">... </span>    <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="s1">&#39;-&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;-{1,2}&#39;</span><span class="p">,</span> <span class="n">dashrepl</span><span class="p">,</span> <span class="s1">&#39;pro----gram-files&#39;</span><span class="p">)</span>
<span class="go">&#39;pro--gram files&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\sAND\s&#39;</span><span class="p">,</span> <span class="s1">&#39; &amp; &#39;</span><span class="p">,</span> <span class="s1">&#39;Baked Beans And Spam&#39;</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
<span class="go">&#39;Baked Beans &amp; Spam&#39;</span>
</pre></div>
</div>
<p>O padrão pode ser uma string ou um <a class="reference internal" href="#re-objects"><span class="std std-ref">objeto de padrão</span></a>.</p>
<p>O argumento opcional <em>count</em> é o número máximo de ocorrências de padrão a serem substituídas; <em>count</em> deve ser um número inteiro não negativo. Se omitido ou zero, todas as ocorrências serão substituídas. As correspondências vazias para o padrão são substituídas apenas quando não adjacentes a uma correspondência vazia anterior, então <code class="docutils literal notranslate"><span class="pre">sub('x*',</span> <span class="pre">'-',</span> <span class="pre">'abxd')</span></code> retorna <code class="docutils literal notranslate"><span class="pre">'-a-b--d-'</span></code>.</p>
<p id="index-37">Em argumentos <em>repl</em> do tipo string, além dos escapes de caractere e referências anteriores descritas acima, <code class="docutils literal notranslate"><span class="pre">\g&lt;nome&gt;</span></code> usará a substring correspondida pelo grupo denominado <code class="docutils literal notranslate"><span class="pre">nome</span></code>, conforme definido pela sintaxe <code class="docutils literal notranslate"><span class="pre">(?P&lt;nome&gt;...)</span></code>. <code class="docutils literal notranslate"><span class="pre">\g&lt;número&gt;</span></code> usa o número do grupo correspondente; <code class="docutils literal notranslate"><span class="pre">\g&lt;2&gt;</span></code> é portanto equivalente a <code class="docutils literal notranslate"><span class="pre">\2</span></code>, mas não é ambíguo em uma substituição como <code class="docutils literal notranslate"><span class="pre">\g&lt;2&gt;0</span></code>. <code class="docutils literal notranslate"><span class="pre">\20</span></code> seria interpretado como uma referência ao grupo 20, não uma referência ao grupo 2 seguida pelo caractere literal <code class="docutils literal notranslate"><span class="pre">'0'</span></code>. A referência anterior <code class="docutils literal notranslate"><span class="pre">\g6</span></code> substitui em toda a substring correspondida pela ER.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.1: </span>Adicionado o argumento de sinalizadores opcionais.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.5: </span>Grupos sem correspondência são substituídos por uma string vazia.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.6: </span>Escapes desconhecidos no padrão <em>pattern</em> consistindo em <code class="docutils literal notranslate"><span class="pre">'\'</span></code> e uma letra ASCII agora são erros.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.7: </span>Escapes desconhecidos em <em>repl</em> consistindo em <code class="docutils literal notranslate"><span class="pre">'\'</span></code> e uma letra ASCII agora são erros.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.7: </span>As correspondências vazias para o padrão são substituídas quando adjacentes a uma correspondência não vazia anterior.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="re.subn">
<code class="sig-prename descclassname">re.</code><code class="sig-name descname">subn</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pattern</span></em>, <em class="sig-param"><span class="n">repl</span></em>, <em class="sig-param"><span class="n">string</span></em>, <em class="sig-param"><span class="n">count</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">flags</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.subn" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Executa a mesma operação que <a class="reference internal" href="#re.sub" title="re.sub"><code class="xref py py-func docutils literal notranslate"><span class="pre">sub()</span></code></a>, mas retorna uma tupla <code class="docutils literal notranslate"><span class="pre">(new_string,</span> <span class="pre">number_of_subs_made)</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.1: </span>Adicionado o argumento de sinalizadores opcionais.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.5: </span>Grupos sem correspondência são substituídos por uma string vazia.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="re.escape">
<code class="sig-prename descclassname">re.</code><code class="sig-name descname">escape</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pattern</span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.escape" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Escape caracteres especiais no padrão <em>pattern</em>. Isso é útil se você deseja corresponder uma string literal arbitrária que pode conter metacaracteres de expressão reguladora. Por exemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="s1">&#39;https://www.python.org&#39;</span><span class="p">))</span>
<span class="go">https://www\.python\.org</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">legal_chars</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">ascii_lowercase</span> <span class="o">+</span> <span class="n">string</span><span class="o">.</span><span class="n">digits</span> <span class="o">+</span> <span class="s2">&quot;!#$%&amp;&#39;*+-.^_`|~:&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;[</span><span class="si">%s</span><span class="s1">]+&#39;</span> <span class="o">%</span> <span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">legal_chars</span><span class="p">))</span>
<span class="go">[abcdefghijklmnopqrstuvwxyz0123456789!\#\$%\&amp;&#39;\*\+\-\.\^_`\|\~:]+</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">operators</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="s1">&#39;**&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;|&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">operators</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">))))</span>
<span class="go">/|\-|\+|\*\*|\*</span>
</pre></div>
</div>
<p>Esta função não deve ser usada para a string de substituição em <a class="reference internal" href="#re.sub" title="re.sub"><code class="xref py py-func docutils literal notranslate"><span class="pre">sub()</span></code></a> e <a class="reference internal" href="#re.subn" title="re.subn"><code class="xref py py-func docutils literal notranslate"><span class="pre">subn()</span></code></a>, apenas contrabarras devem ser escapadas. Por exemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">digits_re</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;\d+&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sample</span> <span class="o">=</span> <span class="s1">&#39;/usr/sbin/sendmail - 0 errors, 12 warnings&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">digits_re</span><span class="p">,</span> <span class="n">digits_re</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">),</span> <span class="n">sample</span><span class="p">))</span>
<span class="go">/usr/sbin/sendmail - \d+ errors, \d+ warnings</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.3: </span>O caractere <code class="docutils literal notranslate"><span class="pre">'_'</span></code> não é mais escapado.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.7: </span>Somente caracteres que podem ter um significado especial em uma expressão regular são escapados. Como um resultado, <code class="docutils literal notranslate"><span class="pre">'!'</span></code>, <code class="docutils literal notranslate"><span class="pre">'&quot;'</span></code>, <code class="docutils literal notranslate"><span class="pre">'%'</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;'&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">','</span></code>, <code class="docutils literal notranslate"><span class="pre">'/'</span></code>, <code class="docutils literal notranslate"><span class="pre">':'</span></code>, <code class="docutils literal notranslate"><span class="pre">';'</span></code>, <code class="docutils literal notranslate"><span class="pre">'&lt;'</span></code>, <code class="docutils literal notranslate"><span class="pre">'='</span></code>, <code class="docutils literal notranslate"><span class="pre">'&gt;'</span></code>, <code class="docutils literal notranslate"><span class="pre">'&#64;'</span></code>, e <code class="docutils literal notranslate"><span class="pre">&quot;`&quot;</span></code> não são mais escapados.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="re.purge">
<code class="sig-prename descclassname">re.</code><code class="sig-name descname">purge</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#re.purge" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Limpa o cache de expressão regular.</p>
</dd></dl>

</section>
<section id="exceptions">
<h3>Exceptions<a class="headerlink" href="#exceptions" title="Link permanente para este título">¶</a></h3>
<dl class="py exception">
<dt id="re.error">
<em class="property">exception </em><code class="sig-prename descclassname">re.</code><code class="sig-name descname">error</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">msg</span></em>, <em class="sig-param"><span class="n">pattern</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">pos</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.error" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Exceção levantada quando uma string passada para uma das funções aqui não é uma expressão regular válida (por exemplo, ela pode conter parênteses não correspondentes) ou quando algum outro erro ocorre durante a compilação ou correspondência. Nunca é um erro se uma string não contém correspondência para um padrão. A instância de erro possui os seguintes atributos adicionais:</p>
<dl class="py attribute">
<dt id="re.error.msg">
<code class="sig-name descname">msg</code><a class="headerlink" href="#re.error.msg" title="Link permanente para esta definição">¶</a></dt>
<dd><p>A mensagem de erro não formatada.</p>
</dd></dl>

<dl class="py attribute">
<dt id="re.error.pattern">
<code class="sig-name descname">pattern</code><a class="headerlink" href="#re.error.pattern" title="Link permanente para esta definição">¶</a></dt>
<dd><p>O padrão da expressão regular.</p>
</dd></dl>

<dl class="py attribute">
<dt id="re.error.pos">
<code class="sig-name descname">pos</code><a class="headerlink" href="#re.error.pos" title="Link permanente para esta definição">¶</a></dt>
<dd><p>O índice no padrão <em>pattern</em> no qual a compilação falhou (pode ser <code class="docutils literal notranslate"><span class="pre">None</span></code>).</p>
</dd></dl>

<dl class="py attribute">
<dt id="re.error.lineno">
<code class="sig-name descname">lineno</code><a class="headerlink" href="#re.error.lineno" title="Link permanente para esta definição">¶</a></dt>
<dd><p>A linha correspondente a <em>pos</em> (pode ser <code class="docutils literal notranslate"><span class="pre">None</span></code>).</p>
</dd></dl>

<dl class="py attribute">
<dt id="re.error.colno">
<code class="sig-name descname">colno</code><a class="headerlink" href="#re.error.colno" title="Link permanente para esta definição">¶</a></dt>
<dd><p>A coluna correspondente a <em>pos</em> (pode ser <code class="docutils literal notranslate"><span class="pre">None</span></code>).</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.5: </span>Adicionados os atributos adicionais.</p>
</div>
</dd></dl>

</section>
</section>
<section id="regular-expression-objects">
<span id="re-objects"></span><h2>Objetos expressão regular<a class="headerlink" href="#regular-expression-objects" title="Link permanente para este título">¶</a></h2>
<p>Objetos expressão regular compilados oferecem suporte aos seguintes métodos e atributos:</p>
<dl class="py method">
<dt id="re.Pattern.search">
<code class="sig-prename descclassname">Pattern.</code><code class="sig-name descname">search</code><span class="sig-paren">(</span><em class="sig-param">string</em><span class="optional">[</span>, <em class="sig-param">pos</em><span class="optional">[</span>, <em class="sig-param">endpos</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#re.Pattern.search" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Percorre a <em>string</em> procurando o primeiro local onde esta expressão regular produz uma correspondência e retorna um <a class="reference internal" href="#match-objects"><span class="std std-ref">objeto correspondência</span></a> encontrado. Retorna <code class="docutils literal notranslate"><span class="pre">None</span></code> se nenhuma posição na string corresponder ao padrão; observe que isso é diferente de encontrar uma correspondência de comprimento zero em algum ponto da string.</p>
<p>O segundo parâmetro opcional <em>pos</em> fornece um índice na string onde a pesquisa deve começar; o padrão é <code class="docutils literal notranslate"><span class="pre">0</span></code>. Isso não é totalmente equivalente a fatiar a string; o caractere padrão <code class="docutils literal notranslate"><span class="pre">'^'</span></code> corresponde no início real da string e nas posições logo após uma nova linha, mas não necessariamente no índice onde a pesquisa deve começar.</p>
<p>O parâmetro opcional <em>endpos</em> limita o quão longe a string será pesquisada; será como se a string tivesse <em>endpos</em> caracteres, então apenas os caracteres de <em>pos</em> a <code class="docutils literal notranslate"><span class="pre">endpos</span> <span class="pre">-</span> <span class="pre">1</span></code> serão procurados por uma correspondência. Se <em>endpos</em> for menor que <em>pos</em>, nenhuma correspondência será encontrada; caso contrário, se <em>rx</em> é um objeto de expressão regular compilado, <code class="docutils literal notranslate"><span class="pre">rx.search(string,</span> <span class="pre">0,</span> <span class="pre">50)</span></code> é equivalente a <code class="docutils literal notranslate"><span class="pre">rx.search(string[:50],</span> <span class="pre">0)</span></code>.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;d&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;dog&quot;</span><span class="p">)</span>     <span class="c1"># Match at index 0</span>
<span class="go">&lt;re.Match object; span=(0, 1), match=&#39;d&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;dog&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># No match; search doesn&#39;t include the &quot;d&quot;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="re.Pattern.match">
<code class="sig-prename descclassname">Pattern.</code><code class="sig-name descname">match</code><span class="sig-paren">(</span><em class="sig-param">string</em><span class="optional">[</span>, <em class="sig-param">pos</em><span class="optional">[</span>, <em class="sig-param">endpos</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#re.Pattern.match" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Se zero ou mais caracteres no <em>início</em> da <em>string</em> corresponderem a esta expressão regular, retorna um <a class="reference internal" href="#match-objects"><span class="std std-ref">objeto correspondência</span></a> encontrado. Retorna <code class="docutils literal notranslate"><span class="pre">None</span></code> se a string não corresponder ao padrão; observe que isso é diferente de uma correspondência de comprimento zero.</p>
<p>Os parâmetros opcionais <em>pos</em> e <em>endpos</em> têm o mesmo significado que para o método <a class="reference internal" href="#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a>.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;o&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;dog&quot;</span><span class="p">)</span>      <span class="c1"># No match as &quot;o&quot; is not at the start of &quot;dog&quot;.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;dog&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>   <span class="c1"># Match as &quot;o&quot; is the 2nd character of &quot;dog&quot;.</span>
<span class="go">&lt;re.Match object; span=(1, 2), match=&#39;o&#39;&gt;</span>
</pre></div>
</div>
<p>Se você quiser localizar uma correspondência em qualquer lugar em <em>string</em>, use <a class="reference internal" href="#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a> ao invés (veja também <a class="reference internal" href="#search-vs-match"><span class="std std-ref">search() vs. match()</span></a>).</p>
</dd></dl>

<dl class="py method">
<dt id="re.Pattern.fullmatch">
<code class="sig-prename descclassname">Pattern.</code><code class="sig-name descname">fullmatch</code><span class="sig-paren">(</span><em class="sig-param">string</em><span class="optional">[</span>, <em class="sig-param">pos</em><span class="optional">[</span>, <em class="sig-param">endpos</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#re.Pattern.fullmatch" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Se toda a <em>string</em> corresponder a esta expressão regular, retorna um <a class="reference internal" href="#match-objects"><span class="std std-ref">objeto correspondência</span></a> encontrado. Retorna <code class="docutils literal notranslate"><span class="pre">None</span></code> se a string não corresponder ao padrão; observe que isso é diferente de uma correspondência de comprimento zero.</p>
<p>Os parâmetros opcionais <em>pos</em> e <em>endpos</em> têm o mesmo significado que para o método <a class="reference internal" href="#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a>.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;o[gh]&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="s2">&quot;dog&quot;</span><span class="p">)</span>      <span class="c1"># No match as &quot;o&quot; is not at the start of &quot;dog&quot;.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="s2">&quot;ogre&quot;</span><span class="p">)</span>     <span class="c1"># No match as not the full string matches.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="s2">&quot;doggie&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>   <span class="c1"># Matches within given limits.</span>
<span class="go">&lt;re.Match object; span=(1, 3), match=&#39;og&#39;&gt;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.4.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="re.Pattern.split">
<code class="sig-prename descclassname">Pattern.</code><code class="sig-name descname">split</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">string</span></em>, <em class="sig-param"><span class="n">maxsplit</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.Pattern.split" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Idêntico à função <a class="reference internal" href="#re.split" title="re.split"><code class="xref py py-func docutils literal notranslate"><span class="pre">split()</span></code></a>, usando o padrão compilado.</p>
</dd></dl>

<dl class="py method">
<dt id="re.Pattern.findall">
<code class="sig-prename descclassname">Pattern.</code><code class="sig-name descname">findall</code><span class="sig-paren">(</span><em class="sig-param">string</em><span class="optional">[</span>, <em class="sig-param">pos</em><span class="optional">[</span>, <em class="sig-param">endpos</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#re.Pattern.findall" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Semelhante à função <a class="reference internal" href="#re.findall" title="re.findall"><code class="xref py py-func docutils literal notranslate"><span class="pre">findall()</span></code></a>, usando o padrão compilado, mas também aceita os parâmetros <em>pos</em> e <em>endpos</em> opcionais que limitam a região de pesquisa como para <a class="reference internal" href="#re.search" title="re.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="re.Pattern.finditer">
<code class="sig-prename descclassname">Pattern.</code><code class="sig-name descname">finditer</code><span class="sig-paren">(</span><em class="sig-param">string</em><span class="optional">[</span>, <em class="sig-param">pos</em><span class="optional">[</span>, <em class="sig-param">endpos</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#re.Pattern.finditer" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Semelhante à função <a class="reference internal" href="#re.finditer" title="re.finditer"><code class="xref py py-func docutils literal notranslate"><span class="pre">finditer()</span></code></a>, usando o padrão compilado, mas também aceita os parâmetros <em>pos</em> e <em>endpos</em> opcionais que limitam a região de pesquisa como para <a class="reference internal" href="#re.search" title="re.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="re.Pattern.sub">
<code class="sig-prename descclassname">Pattern.</code><code class="sig-name descname">sub</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">repl</span></em>, <em class="sig-param"><span class="n">string</span></em>, <em class="sig-param"><span class="n">count</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.Pattern.sub" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Idêntico à função <a class="reference internal" href="#re.sub" title="re.sub"><code class="xref py py-func docutils literal notranslate"><span class="pre">sub()</span></code></a>, usando o padrão compilado.</p>
</dd></dl>

<dl class="py method">
<dt id="re.Pattern.subn">
<code class="sig-prename descclassname">Pattern.</code><code class="sig-name descname">subn</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">repl</span></em>, <em class="sig-param"><span class="n">string</span></em>, <em class="sig-param"><span class="n">count</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.Pattern.subn" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Idêntico à função <a class="reference internal" href="#re.subn" title="re.subn"><code class="xref py py-func docutils literal notranslate"><span class="pre">subn()</span></code></a>, usando o padrão compilado.</p>
</dd></dl>

<dl class="py attribute">
<dt id="re.Pattern.flags">
<code class="sig-prename descclassname">Pattern.</code><code class="sig-name descname">flags</code><a class="headerlink" href="#re.Pattern.flags" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Os sinalizadores de correspondência de regex. Esta é uma combinação dos sinalizadores fornecidos para <a class="reference internal" href="#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a>, qualquer sinalizador em linha <code class="docutils literal notranslate"><span class="pre">(?...)</span></code> no padrão e sinalizadores implícitos como <code class="xref py py-data docutils literal notranslate"><span class="pre">UNICODE</span></code> se o padrão for uma string Unicode.</p>
</dd></dl>

<dl class="py attribute">
<dt id="re.Pattern.groups">
<code class="sig-prename descclassname">Pattern.</code><code class="sig-name descname">groups</code><a class="headerlink" href="#re.Pattern.groups" title="Link permanente para esta definição">¶</a></dt>
<dd><p>O número de grupos de captura no padrão.</p>
</dd></dl>

<dl class="py attribute">
<dt id="re.Pattern.groupindex">
<code class="sig-prename descclassname">Pattern.</code><code class="sig-name descname">groupindex</code><a class="headerlink" href="#re.Pattern.groupindex" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Um dicionário que mapeia qualquer nome de grupo simbólico definido por <code class="docutils literal notranslate"><span class="pre">(?P&lt;id&gt;)</span></code> para números de grupo. O dicionário estará vazio se nenhum grupo simbólico for usado no padrão.</p>
</dd></dl>

<dl class="py attribute">
<dt id="re.Pattern.pattern">
<code class="sig-prename descclassname">Pattern.</code><code class="sig-name descname">pattern</code><a class="headerlink" href="#re.Pattern.pattern" title="Link permanente para esta definição">¶</a></dt>
<dd><p>A string de padrão da qual o objeto de padrão foi compilado.</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.7: </span>Adicionado suporte de <a class="reference internal" href="copy.html#copy.copy" title="copy.copy"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy.copy()</span></code></a> e <a class="reference internal" href="copy.html#copy.deepcopy" title="copy.deepcopy"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy.deepcopy()</span></code></a>. Os objetos expressão regular compilados são considerados atômicos.</p>
</div>
</section>
<section id="match-objects">
<span id="id2"></span><h2>Objetos correspondência<a class="headerlink" href="#match-objects" title="Link permanente para este título">¶</a></h2>
<p>Objetos correspondência sempre têm um valor booleano de <code class="docutils literal notranslate"><span class="pre">True</span></code>. Como <a class="reference internal" href="#re.Pattern.match" title="re.Pattern.match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">match()</span></code></a> e <a class="reference internal" href="#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a> retornam <code class="docutils literal notranslate"><span class="pre">None</span></code> quando não há correspondência, você pode testar se houve uma correspondência com uma simples instrução <code class="docutils literal notranslate"><span class="pre">if</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">string</span><span class="p">)</span>
<span class="k">if</span> <span class="n">match</span><span class="p">:</span>
    <span class="n">process</span><span class="p">(</span><span class="n">match</span><span class="p">)</span>
</pre></div>
</div>
<p>Os objetos correspondência oferecem suporte aos seguintes métodos e atributos:</p>
<dl class="py method">
<dt id="re.Match.expand">
<code class="sig-prename descclassname">Match.</code><code class="sig-name descname">expand</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">template</span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.Match.expand" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna a string obtida fazendo a substituição da contrabarra na string modelo <em>template</em>, como feito pelo método <a class="reference internal" href="#re.Pattern.sub" title="re.Pattern.sub"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sub()</span></code></a>. Escapes como <code class="docutils literal notranslate"><span class="pre">\n</span></code> são convertidos para os caracteres apropriados, e referências anteriores numéricas (<code class="docutils literal notranslate"><span class="pre">\1</span></code>, <code class="docutils literal notranslate"><span class="pre">\2</span></code>) e referências anteriores nomeadas (<code class="docutils literal notranslate"><span class="pre">\g&lt;1&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">\g&lt;nome&gt;</span></code>) são substituídas pelo conteúdo do grupo correspondente.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.5: </span>Grupos sem correspondência são substituídos por uma string vazia.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="re.Match.group">
<code class="sig-prename descclassname">Match.</code><code class="sig-name descname">group</code><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param">group1</em>, <em class="sig-param">...</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#re.Match.group" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna um ou mais subgrupos da correspondência. Se houver um único argumento, o resultado será uma única string; se houver vários argumentos, o resultado é uma tupla com um item por argumento. Sem argumentos, <em>group1</em> padroniza para zero (toda a correspondência é retornada). Se um argumento <em>groupN</em> for zero, o valor de retorno correspondente será toda a string correspondente; se estiver no intervalo inclusivo [1..99], é a string que corresponde ao grupo entre parênteses correspondente. Se um número de grupo for negativo ou maior do que o número de grupos definidos no padrão, uma exceção <a class="reference internal" href="exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a> é levantada. Se um grupo estiver contido em uma parte do padrão que não correspondeu, o resultado correspondente será <code class="docutils literal notranslate"><span class="pre">None</span></code>. Se um grupo estiver contido em uma parte do padrão que correspondeu várias vezes, a última correspondência será retornada.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\w+) (\w+)&quot;</span><span class="p">,</span> <span class="s2">&quot;Isaac Newton, physicist&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>       <span class="c1"># The entire match</span>
<span class="go">&#39;Isaac Newton&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>       <span class="c1"># The first parenthesized subgroup.</span>
<span class="go">&#39;Isaac&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>       <span class="c1"># The second parenthesized subgroup.</span>
<span class="go">&#39;Newton&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>    <span class="c1"># Multiple arguments give us a tuple.</span>
<span class="go">(&#39;Isaac&#39;, &#39;Newton&#39;)</span>
</pre></div>
</div>
<p>Se a expressão regular usa a sintaxe <code class="docutils literal notranslate"><span class="pre">(?P&lt;name&gt;...)</span></code>, os argumentos <em>groupN</em> também podem ser strings que identificam grupos por seus nomes de grupo. Se um argumento string não for usado como um nome de grupo no padrão, uma exceção <a class="reference internal" href="exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a> é levantada.</p>
<p>Um exemplo moderadamente complicado:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(?P&lt;first_name&gt;\w+) (?P&lt;last_name&gt;\w+)&quot;</span><span class="p">,</span> <span class="s2">&quot;Malcolm Reynolds&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;first_name&#39;</span><span class="p">)</span>
<span class="go">&#39;Malcolm&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;last_name&#39;</span><span class="p">)</span>
<span class="go">&#39;Reynolds&#39;</span>
</pre></div>
</div>
<p>Grupos nomeados também podem ser referidos por seu índice:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">&#39;Malcolm&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">&#39;Reynolds&#39;</span>
</pre></div>
</div>
<p>Se um grupo corresponder várias vezes, apenas a última correspondência estará acessível:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(..)+&quot;</span><span class="p">,</span> <span class="s2">&quot;a1b2c3&quot;</span><span class="p">)</span>  <span class="c1"># Matches 3 times.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>                        <span class="c1"># Returns only the last match.</span>
<span class="go">&#39;c3&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="re.Match.__getitem__">
<code class="sig-prename descclassname">Match.</code><code class="sig-name descname">__getitem__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">g</span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.Match.__getitem__" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Isso é idêntico a <code class="docutils literal notranslate"><span class="pre">m.group(g)</span></code>. Isso permite acesso mais fácil a um grupo individual de uma correspondência:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\w+) (\w+)&quot;</span><span class="p">,</span> <span class="s2">&quot;Isaac Newton, physicist&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>       <span class="c1"># The entire match</span>
<span class="go">&#39;Isaac Newton&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>       <span class="c1"># The first parenthesized subgroup.</span>
<span class="go">&#39;Isaac&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>       <span class="c1"># The second parenthesized subgroup.</span>
<span class="go">&#39;Newton&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Novo na versão 3.6.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="re.Match.groups">
<code class="sig-prename descclassname">Match.</code><code class="sig-name descname">groups</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">default</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.Match.groups" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna uma tupla contendo todos os subgrupos da correspondência, de 1 até quantos grupos estiverem no padrão. O argumento <em>default</em> é usado para grupos que não participaram da correspondência; o padrão é <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>Por exemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\d+)\.(\d+)&quot;</span><span class="p">,</span> <span class="s2">&quot;24.1632&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>
<span class="go">(&#39;24&#39;, &#39;1632&#39;)</span>
</pre></div>
</div>
<p>Se colocarmos a casa decimal e tudo depois dela opcional, nem todos os grupos podem participar da correspondência. Esses grupos serão padronizados como <code class="docutils literal notranslate"><span class="pre">None</span></code>, a menos que o argumento <em>default</em> seja fornecido:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\d+)\.?(\d+)?&quot;</span><span class="p">,</span> <span class="s2">&quot;24&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>      <span class="c1"># Second group defaults to None.</span>
<span class="go">(&#39;24&#39;, None)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">groups</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">)</span>   <span class="c1"># Now, the second group defaults to &#39;0&#39;.</span>
<span class="go">(&#39;24&#39;, &#39;0&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="re.Match.groupdict">
<code class="sig-prename descclassname">Match.</code><code class="sig-name descname">groupdict</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">default</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.Match.groupdict" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna um dicionário contendo todos os subgrupos <em>nomeados</em> da correspondência, tendo como chave o nome do subgrupo. O argumento <em>default</em> usado para grupos que não participaram da correspondência; o padrão é <code class="docutils literal notranslate"><span class="pre">None</span></code>. Por exemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(?P&lt;first_name&gt;\w+) (?P&lt;last_name&gt;\w+)&quot;</span><span class="p">,</span> <span class="s2">&quot;Malcolm Reynolds&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">groupdict</span><span class="p">()</span>
<span class="go">{&#39;first_name&#39;: &#39;Malcolm&#39;, &#39;last_name&#39;: &#39;Reynolds&#39;}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="re.Match.start">
<code class="sig-prename descclassname">Match.</code><code class="sig-name descname">start</code><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param">group</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#re.Match.start" title="Link permanente para esta definição">¶</a></dt>
<dt id="re.Match.end">
<code class="sig-prename descclassname">Match.</code><code class="sig-name descname">end</code><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param">group</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#re.Match.end" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Retorna os índices de início e fim da substring correspondidos pelo grupo <em>group</em>; <em>group</em> tem como padrão  zero (o que significa que toda a substring é correspondida). Retorna <code class="docutils literal notranslate"><span class="pre">-1</span></code> se <em>group</em> existe, mas não contribuiu para a correspondência. Para um objeto correspondência <em>m</em> e um grupo <em>g</em> que contribuiu para a correspondência, a substring correspondida pelo grupo <em>g</em> (equivalente a <code class="docutils literal notranslate"><span class="pre">m.group(g)</span></code>) é</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">m</span><span class="o">.</span><span class="n">string</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="n">g</span><span class="p">):</span><span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">(</span><span class="n">g</span><span class="p">)]</span>
</pre></div>
</div>
<p>Observe que <code class="docutils literal notranslate"><span class="pre">m.start(group)</span></code> será igual a <code class="docutils literal notranslate"><span class="pre">m.end(group)</span></code> se <em>group</em> correspondeu a uma string nula. Por exemplo, após <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">=</span> <span class="pre">re.search('b(c?)',</span> <span class="pre">'cba')</span></code>, <code class="docutils literal notranslate"><span class="pre">m.start(0)</span></code> é 1, <code class="docutils literal notranslate"><span class="pre">m.end(0)</span></code> é 2, <code class="docutils literal notranslate"><span class="pre">m.start(1)</span></code> e <code class="docutils literal notranslate"><span class="pre">m.end(1)</span></code> são 2, e <code class="docutils literal notranslate"><span class="pre">m.start(2)</span></code> levanta uma exceção <a class="reference internal" href="exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a>.</p>
<p>Um exemplo que removerá <em>remove_this</em> dos endereços de e-mail:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">email</span> <span class="o">=</span> <span class="s2">&quot;tony@tiremove_thisger.net&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;remove_this&quot;</span><span class="p">,</span> <span class="n">email</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">email</span><span class="p">[:</span><span class="n">m</span><span class="o">.</span><span class="n">start</span><span class="p">()]</span> <span class="o">+</span> <span class="n">email</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">():]</span>
<span class="go">&#39;tony@tiger.net&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="re.Match.span">
<code class="sig-prename descclassname">Match.</code><code class="sig-name descname">span</code><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param">group</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#re.Match.span" title="Link permanente para esta definição">¶</a></dt>
<dd><p>Para uma correspondência <em>m</em>, retorna a tupla de dois <code class="docutils literal notranslate"><span class="pre">(m.start(group),</span> <span class="pre">m.end(group))</span></code>. Observe que se <em>group</em> não contribuiu para a correspondência, isso é <code class="docutils literal notranslate"><span class="pre">(-1,</span> <span class="pre">-1)</span></code>. <em>group</em> tem como padrão zero, a correspondência inteira.</p>
</dd></dl>

<dl class="py attribute">
<dt id="re.Match.pos">
<code class="sig-prename descclassname">Match.</code><code class="sig-name descname">pos</code><a class="headerlink" href="#re.Match.pos" title="Link permanente para esta definição">¶</a></dt>
<dd><p>O valor de <em>pos</em> que foi passado para o método <a class="reference internal" href="#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a> ou <a class="reference internal" href="#re.Pattern.match" title="re.Pattern.match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">match()</span></code></a> de um <a class="reference internal" href="#re-objects"><span class="std std-ref">objeto de regex</span></a>. Este é o índice da string na qual o mecanismo de ER começou a procurar uma correspondência.</p>
</dd></dl>

<dl class="py attribute">
<dt id="re.Match.endpos">
<code class="sig-prename descclassname">Match.</code><code class="sig-name descname">endpos</code><a class="headerlink" href="#re.Match.endpos" title="Link permanente para esta definição">¶</a></dt>
<dd><p>O valor de <em>endpos</em> que foi passado para o método <a class="reference internal" href="#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a> ou <a class="reference internal" href="#re.Pattern.match" title="re.Pattern.match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">match()</span></code></a> de um <a class="reference internal" href="#re-objects"><span class="std std-ref">objeto de regex</span></a>. Este é o índice da string após o qual o mecanismo de ER não vai chegar.</p>
</dd></dl>

<dl class="py attribute">
<dt id="re.Match.lastindex">
<code class="sig-prename descclassname">Match.</code><code class="sig-name descname">lastindex</code><a class="headerlink" href="#re.Match.lastindex" title="Link permanente para esta definição">¶</a></dt>
<dd><p>O índice em número inteiro do último grupo de captura correspondido, ou <code class="docutils literal notranslate"><span class="pre">None</span></code> se nenhum grupo foi correspondido. Por exemplo, as expressões <code class="docutils literal notranslate"><span class="pre">(a)b</span></code>, <code class="docutils literal notranslate"><span class="pre">((a)(b))</span></code> e <code class="docutils literal notranslate"><span class="pre">((ab))</span></code> terão <code class="docutils literal notranslate"><span class="pre">lastindex</span> <span class="pre">==</span> <span class="pre">1</span></code> se aplicadas à string <code class="docutils literal notranslate"><span class="pre">'ab'</span></code>, enquanto a expressão <code class="docutils literal notranslate"><span class="pre">(a)(b)</span></code> terá <code class="docutils literal notranslate"><span class="pre">lastindex</span> <span class="pre">==</span> <span class="pre">2</span></code>, se aplicada à mesma string.</p>
</dd></dl>

<dl class="py attribute">
<dt id="re.Match.lastgroup">
<code class="sig-prename descclassname">Match.</code><code class="sig-name descname">lastgroup</code><a class="headerlink" href="#re.Match.lastgroup" title="Link permanente para esta definição">¶</a></dt>
<dd><p>O nome do último grupo de captura correspondido, ou <code class="docutils literal notranslate"><span class="pre">None</span></code> se o grupo não tinha um nome, ou se nenhum grupo foi correspondido.</p>
</dd></dl>

<dl class="py attribute">
<dt id="re.Match.re">
<code class="sig-prename descclassname">Match.</code><code class="sig-name descname">re</code><a class="headerlink" href="#re.Match.re" title="Link permanente para esta definição">¶</a></dt>
<dd><p>O <a class="reference internal" href="#re-objects"><span class="std std-ref">objeto expressão regular</span></a> cujo método <a class="reference internal" href="#re.Pattern.match" title="re.Pattern.match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">match()</span></code></a> ou <a class="reference internal" href="#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a> produziu esta instância de correspondência.</p>
</dd></dl>

<dl class="py attribute">
<dt id="re.Match.string">
<code class="sig-prename descclassname">Match.</code><code class="sig-name descname">string</code><a class="headerlink" href="#re.Match.string" title="Link permanente para esta definição">¶</a></dt>
<dd><p>A string passada para <a class="reference internal" href="#re.Pattern.match" title="re.Pattern.match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">match()</span></code></a> ou <a class="reference internal" href="#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a>.</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.7: </span>Adicionado suporte de <a class="reference internal" href="copy.html#copy.copy" title="copy.copy"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy.copy()</span></code></a> e <a class="reference internal" href="copy.html#copy.deepcopy" title="copy.deepcopy"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy.deepcopy()</span></code></a>. Objetos correspondência são considerados atômicos.</p>
</div>
</section>
<section id="regular-expression-examples">
<span id="re-examples"></span><h2>Exemplos de expressão regular<a class="headerlink" href="#regular-expression-examples" title="Link permanente para este título">¶</a></h2>
<section id="checking-for-a-pair">
<h3>Verificando por um par<a class="headerlink" href="#checking-for-a-pair" title="Link permanente para este título">¶</a></h3>
<p>Neste exemplo, usaremos a seguinte função auxiliar para exibir objetos correspondência com um pouco mais de elegância:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">displaymatch</span><span class="p">(</span><span class="n">match</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="s1">&#39;&lt;Match: </span><span class="si">%r</span><span class="s1">, groups=</span><span class="si">%r</span><span class="s1">&gt;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(),</span> <span class="n">match</span><span class="o">.</span><span class="n">groups</span><span class="p">())</span>
</pre></div>
</div>
<p>Suponha que você esteja escrevendo um programa de pôquer onde a mão de um jogador é representada como uma string de 5 caracteres com cada caractere representando uma carta, “a” para ás, “k” para rei, “q” para dama, “j” para valete, “t” para 10 e “2” a “9” representando a carta com esse valor.</p>
<p>Para ver se uma determinada string é uma mão válida, pode-se fazer o seguinte:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">valid</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;^[a2-9tjqk]</span><span class="si">{5}</span><span class="s2">$&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">displaymatch</span><span class="p">(</span><span class="n">valid</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;akt5q&quot;</span><span class="p">))</span>  <span class="c1"># Valid.</span>
<span class="go">&quot;&lt;Match: &#39;akt5q&#39;, groups=()&gt;&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">displaymatch</span><span class="p">(</span><span class="n">valid</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;akt5e&quot;</span><span class="p">))</span>  <span class="c1"># Invalid.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">displaymatch</span><span class="p">(</span><span class="n">valid</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;akt&quot;</span><span class="p">))</span>    <span class="c1"># Invalid.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">displaymatch</span><span class="p">(</span><span class="n">valid</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;727ak&quot;</span><span class="p">))</span>  <span class="c1"># Valid.</span>
<span class="go">&quot;&lt;Match: &#39;727ak&#39;, groups=()&gt;&quot;</span>
</pre></div>
</div>
<p>Essa última mão, <code class="docutils literal notranslate"><span class="pre">&quot;727ak&quot;</span></code>, continha um par, ou duas cartas com o mesmo valor. Para combinar isso com uma expressão regular, pode-se usar referências anteriores como:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pair</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;.*(.).*\1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">displaymatch</span><span class="p">(</span><span class="n">pair</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;717ak&quot;</span><span class="p">))</span>     <span class="c1"># Pair of 7s.</span>
<span class="go">&quot;&lt;Match: &#39;717&#39;, groups=(&#39;7&#39;,)&gt;&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">displaymatch</span><span class="p">(</span><span class="n">pair</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;718ak&quot;</span><span class="p">))</span>     <span class="c1"># No pairs.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">displaymatch</span><span class="p">(</span><span class="n">pair</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;354aa&quot;</span><span class="p">))</span>     <span class="c1"># Pair of aces.</span>
<span class="go">&quot;&lt;Match: &#39;354aa&#39;, groups=(&#39;a&#39;,)&gt;&quot;</span>
</pre></div>
</div>
<p>Para descobrir em que carta o par consiste, pode-se usar o método <a class="reference internal" href="#re.Match.group" title="re.Match.group"><code class="xref py py-meth docutils literal notranslate"><span class="pre">group()</span></code></a> do objeto correspondência da seguinte maneira:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pair</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;.*(.).*\1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pair</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;717ak&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">&#39;7&#39;</span>

<span class="go"># Error because re.match() returns None, which doesn&#39;t have a group() method:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pair</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;718ak&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;pyshell#23&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
    <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;.*(.).*\1&quot;</span><span class="p">,</span> <span class="s2">&quot;718ak&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gr">AttributeError</span>: <span class="n">&#39;NoneType&#39; object has no attribute &#39;group&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">pair</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;354aa&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">&#39;a&#39;</span>
</pre></div>
</div>
</section>
<section id="simulating-scanf">
<h3>Simulando scanf()<a class="headerlink" href="#simulating-scanf" title="Link permanente para este título">¶</a></h3>
<p id="index-38">Python atualmente não possui um equivalente a <code class="xref c c-func docutils literal notranslate"><span class="pre">scanf()</span></code>. Expressões regulares são geralmente mais poderosas, embora também mais detalhadas, do que strings de formato <code class="xref c c-func docutils literal notranslate"><span class="pre">scanf()</span></code>. A tabela abaixo oferece alguns mapeamentos mais ou menos equivalentes entre os tokens de formato <code class="xref c c-func docutils literal notranslate"><span class="pre">scanf()</span></code> e expressões regulares.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 42%" />
<col style="width: 58%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Token <code class="xref c c-func docutils literal notranslate"><span class="pre">scanf()</span></code></p></th>
<th class="head"><p>Expressão regular</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">%c</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">.</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">%5c</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">.{5}</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">%d</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">[-+]?\d+</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">%e</span></code>, <code class="docutils literal notranslate"><span class="pre">%E</span></code>, <code class="docutils literal notranslate"><span class="pre">%f</span></code>, <code class="docutils literal notranslate"><span class="pre">%g</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">[-+]?(\d+(\.\d*)?|\.\d+)([eE][-+]?\d+)?</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">%i</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">[-+]?(0[xX][\dA-Fa-f]+|0[0-7]*|\d+)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">%o</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">[-+]?[0-7]+</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">%s</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">\S+</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">%u</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">\d+</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">%x</span></code>, <code class="docutils literal notranslate"><span class="pre">%X</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">[-+]?(0[xX])?[\dA-Fa-f]+</span></code></p></td>
</tr>
</tbody>
</table>
<p>Para extrair um nome de arquivo e números de uma string como</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">sbin</span><span class="o">/</span><span class="n">sendmail</span> <span class="o">-</span> <span class="mi">0</span> <span class="n">errors</span><span class="p">,</span> <span class="mi">4</span> <span class="n">warnings</span>
</pre></div>
</div>
<p>você usaria um formato de <code class="xref c c-func docutils literal notranslate"><span class="pre">scanf()</span></code> como</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">s</span> <span class="o">-</span> <span class="o">%</span><span class="n">d</span> <span class="n">errors</span><span class="p">,</span> <span class="o">%</span><span class="n">d</span> <span class="n">warnings</span>
</pre></div>
</div>
<p>A expressão regular equivalente seria</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">(</span>\<span class="n">S</span><span class="o">+</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span>\<span class="n">d</span><span class="o">+</span><span class="p">)</span> <span class="n">errors</span><span class="p">,</span> <span class="p">(</span>\<span class="n">d</span><span class="o">+</span><span class="p">)</span> <span class="n">warnings</span>
</pre></div>
</div>
</section>
<section id="search-vs-match">
<span id="id3"></span><h3>search() vs. match()<a class="headerlink" href="#search-vs-match" title="Link permanente para este título">¶</a></h3>
<p>Python oferece duas operações primitivas diferentes baseadas em expressões regulares: <a class="reference internal" href="#re.match" title="re.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.match()</span></code></a> verifica se há uma correspondência apenas no início da string, enquanto <a class="reference internal" href="#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.search()</span></code></a> verifica se há uma correspondência em qualquer lugar da string (isto é o que o Perl faz por padrão).</p>
<p>Por exemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="s2">&quot;abcdef&quot;</span><span class="p">)</span>    <span class="c1"># No match</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="s2">&quot;abcdef&quot;</span><span class="p">)</span>   <span class="c1"># Match</span>
<span class="go">&lt;re.Match object; span=(2, 3), match=&#39;c&#39;&gt;</span>
</pre></div>
</div>
<p>Expressões regulares começando com <code class="docutils literal notranslate"><span class="pre">'^'</span></code> podem ser usadas com <a class="reference internal" href="#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">search()</span></code></a> para restringir a correspondência no início da string:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="s2">&quot;abcdef&quot;</span><span class="p">)</span>    <span class="c1"># No match</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;^c&quot;</span><span class="p">,</span> <span class="s2">&quot;abcdef&quot;</span><span class="p">)</span>  <span class="c1"># No match</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;^a&quot;</span><span class="p">,</span> <span class="s2">&quot;abcdef&quot;</span><span class="p">)</span>  <span class="c1"># Match</span>
<span class="go">&lt;re.Match object; span=(0, 1), match=&#39;a&#39;&gt;</span>
</pre></div>
</div>
<p>Observe, entretanto, que no modo <a class="reference internal" href="#re.MULTILINE" title="re.MULTILINE"><code class="xref py py-const docutils literal notranslate"><span class="pre">MULTILINE</span></code></a> <a class="reference internal" href="#re.match" title="re.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">match()</span></code></a> apenas corresponde ao início da string, enquanto que usar <a class="reference internal" href="#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">search()</span></code></a> com uma expressão regular começando com <code class="docutils literal notranslate"><span class="pre">'^'</span></code> irá corresponder em no início de cada linha.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;A</span><span class="se">\n</span><span class="s1">B</span><span class="se">\n</span><span class="s1">X&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span>  <span class="c1"># No match</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;^X&#39;</span><span class="p">,</span> <span class="s1">&#39;A</span><span class="se">\n</span><span class="s1">B</span><span class="se">\n</span><span class="s1">X&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span>  <span class="c1"># Match</span>
<span class="go">&lt;re.Match object; span=(4, 5), match=&#39;X&#39;&gt;</span>
</pre></div>
</div>
</section>
<section id="making-a-phonebook">
<h3>Criando uma lista telefônica<a class="headerlink" href="#making-a-phonebook" title="Link permanente para este título">¶</a></h3>
<p><a class="reference internal" href="#re.split" title="re.split"><code class="xref py py-func docutils literal notranslate"><span class="pre">split()</span></code></a> divide uma string em uma lista delimitada pelo padrão passado. O método é inestimável para converter dados textuais em estruturas de dados que podem ser facilmente lidas e modificadas pelo Python, conforme demonstrado no exemplo a seguir que cria uma lista telefônica.</p>
<p>Primeiro, aqui está a entrada. Normalmente pode vir de um arquivo, aqui estamos usando a sintaxe de string entre aspas triplas</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;Ross McFluff: 834.345.1254 155 Elm Street</span>
<span class="gp">...</span><span class="s2"></span>
<span class="gp">... </span><span class="s2">Ronald Heathmore: 892.345.3428 436 Finley Avenue</span>
<span class="gp">... </span><span class="s2">Frank Burger: 925.541.7625 662 South Dogwood Way</span>
<span class="gp">...</span><span class="s2"></span>
<span class="gp">...</span><span class="s2"></span>
<span class="gp">... </span><span class="s2">Heather Albrecht: 548.326.4584 919 Park Place&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>As entradas são separadas por uma ou mais novas linhas. Agora, convertemos a string em uma lista com cada linha não vazia tendo sua própria entrada:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">entries</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">+&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entries</span>
<span class="go">[&#39;Ross McFluff: 834.345.1254 155 Elm Street&#39;,</span>
<span class="go">&#39;Ronald Heathmore: 892.345.3428 436 Finley Avenue&#39;,</span>
<span class="go">&#39;Frank Burger: 925.541.7625 662 South Dogwood Way&#39;,</span>
<span class="go">&#39;Heather Albrecht: 548.326.4584 919 Park Place&#39;]</span>
</pre></div>
</div>
<p>Finalmente, divida cada entrada em uma lista com nome, sobrenome, número de telefone e endereço. Usamos o parâmetro <code class="docutils literal notranslate"><span class="pre">maxsplit</span></code> de <a class="reference internal" href="#re.split" title="re.split"><code class="xref py py-func docutils literal notranslate"><span class="pre">split()</span></code></a> porque o endereço contém espaços, nosso padrão de divisão:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:? &quot;</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">entries</span><span class="p">]</span>
<span class="go">[[&#39;Ross&#39;, &#39;McFluff&#39;, &#39;834.345.1254&#39;, &#39;155 Elm Street&#39;],</span>
<span class="go">[&#39;Ronald&#39;, &#39;Heathmore&#39;, &#39;892.345.3428&#39;, &#39;436 Finley Avenue&#39;],</span>
<span class="go">[&#39;Frank&#39;, &#39;Burger&#39;, &#39;925.541.7625&#39;, &#39;662 South Dogwood Way&#39;],</span>
<span class="go">[&#39;Heather&#39;, &#39;Albrecht&#39;, &#39;548.326.4584&#39;, &#39;919 Park Place&#39;]]</span>
</pre></div>
</div>
<p>O padrão <code class="docutils literal notranslate"><span class="pre">:?</span></code> corresponde ao caractere de dois pontos após o sobrenome, de modo que não ocorre na lista de resultados. Com um <code class="docutils literal notranslate"><span class="pre">maxsplit</span></code> de <code class="docutils literal notranslate"><span class="pre">4</span></code>, podemos separar o número da casa do nome da rua:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:? &quot;</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">entries</span><span class="p">]</span>
<span class="go">[[&#39;Ross&#39;, &#39;McFluff&#39;, &#39;834.345.1254&#39;, &#39;155&#39;, &#39;Elm Street&#39;],</span>
<span class="go">[&#39;Ronald&#39;, &#39;Heathmore&#39;, &#39;892.345.3428&#39;, &#39;436&#39;, &#39;Finley Avenue&#39;],</span>
<span class="go">[&#39;Frank&#39;, &#39;Burger&#39;, &#39;925.541.7625&#39;, &#39;662&#39;, &#39;South Dogwood Way&#39;],</span>
<span class="go">[&#39;Heather&#39;, &#39;Albrecht&#39;, &#39;548.326.4584&#39;, &#39;919&#39;, &#39;Park Place&#39;]]</span>
</pre></div>
</div>
</section>
<section id="text-munging">
<h3>Mastigação de texto<a class="headerlink" href="#text-munging" title="Link permanente para este título">¶</a></h3>
<p><a class="reference internal" href="#re.sub" title="re.sub"><code class="xref py py-func docutils literal notranslate"><span class="pre">sub()</span></code></a> substitui cada ocorrência de um padrão por uma string ou o resultado de uma função. Este exemplo demonstra o uso de <a class="reference internal" href="#re.sub" title="re.sub"><code class="xref py py-func docutils literal notranslate"><span class="pre">sub()</span></code></a> com uma função para “mastigar” o texto ou aleatorizar a ordem de todos os caracteres em cada palavra de uma frase, exceto o primeiro e o último caracteres:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">repl</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">inner_word</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">... </span>    <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">inner_word</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">inner_word</span><span class="p">)</span> <span class="o">+</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;Professor Abdolmalek, please report your absences promptly.&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\w)(\w+)(\w)&quot;</span><span class="p">,</span> <span class="n">repl</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
<span class="go">&#39;Poefsrosr Aealmlobdk, pslaee reorpt your abnseces plmrptoy.&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\w)(\w+)(\w)&quot;</span><span class="p">,</span> <span class="n">repl</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
<span class="go">&#39;Pofsroser Aodlambelk, plasee reoprt yuor asnebces potlmrpy.&#39;</span>
</pre></div>
</div>
</section>
<section id="finding-all-adverbs">
<h3>Encontrando todos os advérbios<a class="headerlink" href="#finding-all-adverbs" title="Link permanente para este título">¶</a></h3>
<p><a class="reference internal" href="#re.findall" title="re.findall"><code class="xref py py-func docutils literal notranslate"><span class="pre">findall()</span></code></a> corresponde a <em>todas</em> as ocorrências de um padrão, não apenas a primeira como <a class="reference internal" href="#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">search()</span></code></a> faz. Por exemplo, se um escritor deseja encontrar todos os advérbios em algum texto, ele pode usar <a class="reference internal" href="#re.findall" title="re.findall"><code class="xref py py-func docutils literal notranslate"><span class="pre">findall()</span></code></a> da seguinte maneira:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;He was carefully disguised but captured quickly by police.&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\w+ly\b&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
<span class="go">[&#39;carefully&#39;, &#39;quickly&#39;]</span>
</pre></div>
</div>
</section>
<section id="finding-all-adverbs-and-their-positions">
<h3>Encontrando todos os advérbios e suas posições<a class="headerlink" href="#finding-all-adverbs-and-their-positions" title="Link permanente para este título">¶</a></h3>
<p>Caso seja desejado obter mais informações sobre todas as correspondências de um padrão do que o texto correspondido, <a class="reference internal" href="#re.finditer" title="re.finditer"><code class="xref py py-func docutils literal notranslate"><span class="pre">finditer()</span></code></a> é útil, pois fornece <a class="reference internal" href="#match-objects"><span class="std std-ref">objetos correspondência</span></a> em vez de strings. Continuando com o exemplo anterior, se um escritor quisesse encontrar todos os advérbios <em>e suas posições</em> em algum texto, ele usaria <a class="reference internal" href="#re.finditer" title="re.finditer"><code class="xref py py-func docutils literal notranslate"><span class="pre">finditer()</span></code></a> da seguinte maneira:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;He was carefully disguised but captured quickly by police.&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\w+ly\b&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%02d</span><span class="s1">-</span><span class="si">%02d</span><span class="s1">: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> <span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span>
<span class="go">07-16: carefully</span>
<span class="go">40-47: quickly</span>
</pre></div>
</div>
</section>
<section id="raw-string-notation">
<h3>Notação de string bruta<a class="headerlink" href="#raw-string-notation" title="Link permanente para este título">¶</a></h3>
<p>A notação de string bruta (<code class="docutils literal notranslate"><span class="pre">r&quot;texto&quot;</span></code>) mantém as expressões regulares sãs. Sem ele, cada contrabarra (<code class="docutils literal notranslate"><span class="pre">'\'</span></code>) em uma expressão regular teria que ser prefixada com outra para escapar dela. Por exemplo, as duas linhas de código a seguir são funcionalmente idênticas:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\W(.)\1\W&quot;</span><span class="p">,</span> <span class="s2">&quot; ff &quot;</span><span class="p">)</span>
<span class="go">&lt;re.Match object; span=(0, 4), match=&#39; ff &#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">W(.)</span><span class="se">\\</span><span class="s2">1</span><span class="se">\\</span><span class="s2">W&quot;</span><span class="p">,</span> <span class="s2">&quot; ff &quot;</span><span class="p">)</span>
<span class="go">&lt;re.Match object; span=(0, 4), match=&#39; ff &#39;&gt;</span>
</pre></div>
</div>
<p>Quando se deseja corresponder a uma contrabarra literal, ela deve ser escapada na expressão regular. Com a notação de string bruta, isso significa <code class="docutils literal notranslate"><span class="pre">r&quot;\\&quot;</span></code>. Sem a notação de string bruta, deve-se usar <code class="docutils literal notranslate"><span class="pre">&quot;\\\\&quot;</span></code>, tornando as seguintes linhas de código funcionalmente idênticas:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="go">&lt;re.Match object; span=(0, 1), match=&#39;\\&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\\\\</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="go">&lt;re.Match object; span=(0, 1), match=&#39;\\&#39;&gt;</span>
</pre></div>
</div>
</section>
<section id="writing-a-tokenizer">
<h3>Escrevendo um tokenizador<a class="headerlink" href="#writing-a-tokenizer" title="Link permanente para este título">¶</a></h3>
<p>Um <a class="reference external" href="https://en.wikipedia.org/wiki/Lexical_analysis">tokenizador, tokenizer ou scanner</a> analisa uma string para categorizar grupos de caracteres. Este é um primeiro passo útil para escrever um compilador ou interpretador.</p>
<p>As categorias de texto são especificadas com expressões regulares. A técnica é combiná-las em uma única expressão regular mestre e fazer um loop em correspondências sucessivas:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">NamedTuple</span>
<span class="kn">import</span> <span class="nn">re</span>

<span class="k">class</span> <span class="nc">Token</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="nb">type</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">value</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">line</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">column</span><span class="p">:</span> <span class="nb">int</span>

<span class="k">def</span> <span class="nf">tokenize</span><span class="p">(</span><span class="n">code</span><span class="p">):</span>
    <span class="n">keywords</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;IF&#39;</span><span class="p">,</span> <span class="s1">&#39;THEN&#39;</span><span class="p">,</span> <span class="s1">&#39;ENDIF&#39;</span><span class="p">,</span> <span class="s1">&#39;FOR&#39;</span><span class="p">,</span> <span class="s1">&#39;NEXT&#39;</span><span class="p">,</span> <span class="s1">&#39;GOSUB&#39;</span><span class="p">,</span> <span class="s1">&#39;RETURN&#39;</span><span class="p">}</span>
    <span class="n">token_specification</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="s1">&#39;NUMBER&#39;</span><span class="p">,</span>   <span class="sa">r</span><span class="s1">&#39;\d+(\.\d*)?&#39;</span><span class="p">),</span>  <span class="c1"># Integer or decimal number</span>
        <span class="p">(</span><span class="s1">&#39;ASSIGN&#39;</span><span class="p">,</span>   <span class="sa">r</span><span class="s1">&#39;:=&#39;</span><span class="p">),</span>           <span class="c1"># Assignment operator</span>
        <span class="p">(</span><span class="s1">&#39;END&#39;</span><span class="p">,</span>      <span class="sa">r</span><span class="s1">&#39;;&#39;</span><span class="p">),</span>            <span class="c1"># Statement terminator</span>
        <span class="p">(</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span>       <span class="sa">r</span><span class="s1">&#39;[A-Za-z]+&#39;</span><span class="p">),</span>    <span class="c1"># Identifiers</span>
        <span class="p">(</span><span class="s1">&#39;OP&#39;</span><span class="p">,</span>       <span class="sa">r</span><span class="s1">&#39;[+\-*/]&#39;</span><span class="p">),</span>      <span class="c1"># Arithmetic operators</span>
        <span class="p">(</span><span class="s1">&#39;NEWLINE&#39;</span><span class="p">,</span>  <span class="sa">r</span><span class="s1">&#39;\n&#39;</span><span class="p">),</span>           <span class="c1"># Line endings</span>
        <span class="p">(</span><span class="s1">&#39;SKIP&#39;</span><span class="p">,</span>     <span class="sa">r</span><span class="s1">&#39;[ \t]+&#39;</span><span class="p">),</span>       <span class="c1"># Skip over spaces and tabs</span>
        <span class="p">(</span><span class="s1">&#39;MISMATCH&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;.&#39;</span><span class="p">),</span>            <span class="c1"># Any other character</span>
    <span class="p">]</span>
    <span class="n">tok_regex</span> <span class="o">=</span> <span class="s1">&#39;|&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;(?P&lt;</span><span class="si">%s</span><span class="s1">&gt;</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="n">pair</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">token_specification</span><span class="p">)</span>
    <span class="n">line_num</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">line_start</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">mo</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="n">tok_regex</span><span class="p">,</span> <span class="n">code</span><span class="p">):</span>
        <span class="n">kind</span> <span class="o">=</span> <span class="n">mo</span><span class="o">.</span><span class="n">lastgroup</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">mo</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
        <span class="n">column</span> <span class="o">=</span> <span class="n">mo</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="o">-</span> <span class="n">line_start</span>
        <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;NUMBER&#39;</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">if</span> <span class="s1">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">value</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;ID&#39;</span> <span class="ow">and</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">keywords</span><span class="p">:</span>
            <span class="n">kind</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;NEWLINE&#39;</span><span class="p">:</span>
            <span class="n">line_start</span> <span class="o">=</span> <span class="n">mo</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
            <span class="n">line_num</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">continue</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;SKIP&#39;</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;MISMATCH&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">value</span><span class="si">!r}</span><span class="s1"> unexpected on line </span><span class="si">{</span><span class="n">line_num</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">Token</span><span class="p">(</span><span class="n">kind</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">line_num</span><span class="p">,</span> <span class="n">column</span><span class="p">)</span>

<span class="n">statements</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="s1">    IF quantity THEN</span>
<span class="s1">        total := total + price * quantity;</span>
<span class="s1">        tax := price * 0.05;</span>
<span class="s1">    ENDIF;</span>
<span class="s1">&#39;&#39;&#39;</span>

<span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">tokenize</span><span class="p">(</span><span class="n">statements</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
</pre></div>
</div>
<p>O tokenizador produz a seguinte saída:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;IF&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;IF&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;quantity&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;THEN&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;THEN&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;total&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ASSIGN&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;:=&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;total&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">17</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;OP&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">23</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;price&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">25</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;OP&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">31</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;quantity&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">33</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;END&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;;&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">41</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;tax&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ASSIGN&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;:=&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;price&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;OP&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">21</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;NUMBER&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">23</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;END&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;;&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">27</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ENDIF&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;ENDIF&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;END&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;;&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">9</span><span class="p">)</span>
</pre></div>
</div>
<dl class="citation">
<dt class="label" id="frie09"><span class="brackets"><a class="fn-backref" href="#id1">Frie09</a></span></dt>
<dd><p>Friedl, Jeffrey. Mastering Regular Expressions. 3ª ed., O’Reilly Media, 2009. A terceira edição do livro não cobre mais o Python, mas a primeira edição cobriu a escrita de bons padrões de expressão regular em grandes detalhes.</p>
</dd>
</dl>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Tabela de Conteúdo</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code> — Operações com expressões regulares</a><ul>
<li><a class="reference internal" href="#regular-expression-syntax">Sintaxe de expressão regular</a></li>
<li><a class="reference internal" href="#module-contents">Conteúdo do módulo</a><ul>
<li><a class="reference internal" href="#flags">Flags</a></li>
<li><a class="reference internal" href="#functions">Functions</a></li>
<li><a class="reference internal" href="#exceptions">Exceptions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#regular-expression-objects">Objetos expressão regular</a></li>
<li><a class="reference internal" href="#match-objects">Objetos correspondência</a></li>
<li><a class="reference internal" href="#regular-expression-examples">Exemplos de expressão regular</a><ul>
<li><a class="reference internal" href="#checking-for-a-pair">Verificando por um par</a></li>
<li><a class="reference internal" href="#simulating-scanf">Simulando scanf()</a></li>
<li><a class="reference internal" href="#search-vs-match">search() vs. match()</a></li>
<li><a class="reference internal" href="#making-a-phonebook">Criando uma lista telefônica</a></li>
<li><a class="reference internal" href="#text-munging">Mastigação de texto</a></li>
<li><a class="reference internal" href="#finding-all-adverbs">Encontrando todos os advérbios</a></li>
<li><a class="reference internal" href="#finding-all-adverbs-and-their-positions">Encontrando todos os advérbios e suas posições</a></li>
<li><a class="reference internal" href="#raw-string-notation">Notação de string bruta</a></li>
<li><a class="reference internal" href="#writing-a-tokenizer">Escrevendo um tokenizador</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Tópico anterior</h4>
  <p class="topless"><a href="string.html"
                        title="capítulo anterior"><code class="xref py py-mod docutils literal notranslate"><span class="pre">string</span></code> — Operações comuns de strings</a></p>
  <h4>Próximo tópico</h4>
  <p class="topless"><a href="difflib.html"
                        title="próximo capítulo"><code class="xref py py-mod docutils literal notranslate"><span class="pre">difflib</span></code> — Helpers for computing deltas</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Relatar um erro</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.10/Doc/library/re.rst"
            rel="nofollow">Exibir código-fonte
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegação</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice geral"
             >índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="difflib.html" title="difflib — Helpers for computing deltas"
             >próximo</a> |</li>
        <li class="right" >
          <a href="string.html" title="string — Operações comuns de strings"
             >anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.10.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >A Biblioteca Padrão do Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="text.html" >Serviços de Processamento de Texto</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code> — Operações com expressões regulares</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Busca rápida" aria-label="Busca rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Direitos autorais</a> 2001-2022, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    Última atualização em jun. 04, 2022.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.4.3.
    </div>

  </body>
</html>